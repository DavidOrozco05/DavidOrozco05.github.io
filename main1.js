!function(t) {
    var e = {};
    function n(i) {
        if (e[i])
            return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n),
        r.l = !0,
        r.exports
    }
    n.m = t,
    n.c = e,
    n.d = function(t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }
    ,
    n.r = function(t) {
        'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: 'Module'
        }),
        Object.defineProperty(t, '__esModule', {
            value: !0
        })
    }
    ,
    n.t = function(t, e) {
        if (1 & e && (t = n(t)),
        8 & e)
            return t;
        if (4 & e && 'object' == typeof t && t && t.__esModule)
            return t;
        var i = Object.create(null);
        if (n.r(i),
        Object.defineProperty(i, 'default', {
            enumerable: !0,
            value: t
        }),
        2 & e && 'string' != typeof t)
            for (var r in t)
                n.d(i, r, function(e) {
                    return t[e]
                }
                .bind(null, r));
        return i
    }
    ,
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, 'a', e),
        e
    }
    ,
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    n.p = '',
    n(n.s = 6)
}([function(t, e, n) {
    'use strict';
    var i, r, o, a, s, l, c;
    Object.defineProperty(e, '__esModule', {
        value: !0
    }),
    function(t) {
        t[t.INTENSITY = 0] = 'INTENSITY',
        t[t.FOCUS = 1] = 'FOCUS',
        t[t.TRACE = 2] = 'TRACE'
    }(i = e.AdjustMode || (e.AdjustMode = {})),
    function(t) {
        t[t.CH1 = 0] = 'CH1',
        t[t.CH2 = 1] = 'CH2',
        t[t.DUAL = 2] = 'DUAL',
        t[t.ADD = 3] = 'ADD',
        t[t.XY = 4] = 'XY'
    }(r = e.DisplayChannelMode || (e.DisplayChannelMode = {})),
    function(t) {
        t[t.MOUSEDOWN = 0] = 'MOUSEDOWN',
        t[t.KEYDOWN = 1] = 'KEYDOWN',
        t[t.MOUSEWHEEL = 2] = 'MOUSEWHEEL',
        t[t.DOMMOUSESCROLL = 3] = 'DOMMOUSESCROLL',
        t[t.TOUCHSTART = 4] = 'TOUCHSTART'
    }(e.AcceptedEvent || (e.AcceptedEvent = {})),
    function(t) {
        t.CH1 = 'CH1',
        t.CH2 = 'CH2',
        t.EXT = 'EXT',
        t.NONE = 'NONE'
    }(o = e.TriggerChannel || (e.TriggerChannel = {})),
    function(t) {
        t.AC = 'AC',
        t.DC = 'DC',
        t.LF = 'LF'
    }(a = e.TriggerMode || (e.TriggerMode = {})),
    function(t) {
        t[t.SINUS = 0] = 'SINUS',
        t[t.RECTANGLE = 1] = 'RECTANGLE',
        t[t.TRIANGLE = 2] = 'TRIANGLE',
        t[t.SAW_TOOTH = 3] = 'SAW_TOOTH'
    }(s = e.FunctionMode || (e.FunctionMode = {})),
    function(t) {
        t.CH1 = 'ch1',
        t.CH2 = 'ch2',
        t.EXT = 'ext'
    }(e.OscilloscopeChannelMode || (e.OscilloscopeChannelMode = {})),
    function(t) {
        t.CH1 = 'ch1',
        t.CH2 = 'ch2',
        t.CH3 = 'ch3'
    }(l = e.ChannelMode || (e.ChannelMode = {})),
    function(t) {
        t[t.NORM = 0] = 'NORM',
        t[t.AUTO = 1] = 'AUTO'
    }(c = e.AutoTriggerMode || (e.AutoTriggerMode = {}));
    const h = {
        frequency: 1,
        frequencyUnit: 0,
        phaseshift: 0,
        phaseshiftUnit: 0,
        amplitude: 2,
        amplitudeUnit: 0,
        offset: 0,
        offsetUnit: 0,
        fun: s.SINUS
    }
      , u = {
        adjustMode: i.FOCUS,
        adjustValue: {
            focus: 50,
            intensity: 50,
            trace: 50
        },
        displayChannelMode: r.CH1,
        functionGenerator: {
            ch1: Object.assign({}, h),
            ch2: Object.assign({}, h),
            ch3: Object.assign({}, h),
            activeChannel: l.CH1
        },
        connections: {
            ch1: {
                target: l.CH1,
                colorIdx: 0
            },
            ch2: {
                target: l.CH2,
                colorIdx: 1
            }
        },
        controlPane: {
            ch1: {
                AC: !1,
                GND: !1
            },
            ch2: {
                AC: !1,
                GND: !1,
                INV: !1
            }
        },
        rotaryPane: {
            position1: 0,
            position2: 0,
            xPosition: 0,
            voltsCH1: 1,
            voltsCH2: 1,
            time: .1
        },
        triggerSettings: {
            channel: o.NONE,
            mode: a.AC,
            triggerLevel: 0,
            slope: !1,
            auto: c.AUTO
        },
        xMag: !1
    }
      , p = 'state';
    const d = function() {
        const t = JSON.parse(localStorage.getItem(p));
        return function t(e, n) {
            const i = Object.keys(null != e ? e : {}).sort()
              , r = Object.keys(null != n ? n : {}).sort();
            if (JSON.stringify(i) === JSON.stringify(r))
                return void 0 === i.find(i=>'connections' !== i && 'object' == typeof e[i] && !t(e[i], n[i]));
            return !1
        }(u, t) ? t : (localStorage.setItem(p, JSON.stringify(u)),
        u)
    }()
      , f = {
        get(t, e, n) {
            try {
                return new Proxy(t[e],f)
            } catch (i) {
                return Reflect.get(t, e, n)
            }
        },
        defineProperty(t, e, n) {
            const i = Reflect.defineProperty(t, e, n);
            return g(),
            i
        },
        deleteProperty(t, e) {
            const n = Reflect.deleteProperty(t, e);
            return g(),
            n
        }
    }
      , m = [];
    function g() {
        localStorage.setItem(p, JSON.stringify(d)),
        m.forEach(t=>t())
    }
    e.addListener = function(t) {
        m.push(t)
    }
    ;
    const v = new Proxy(d,f);
    e.globalState = v
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = n(3)
      , o = n(9)
      , a = n(10);
    class s {
        constructor() {
            this.onFrequency = (t,e)=>{
                this.model[this.model.activeChannel].frequency = t / 1e3,
                this.model[this.model.activeChannel].frequencyUnit = e
            }
            ,
            this.onPhaseshift = (t,e)=>{
                this.model[this.model.activeChannel].phaseshift = t / 1e3,
                this.model[this.model.activeChannel].phaseshiftUnit = e
            }
            ,
            this.onAmplitude = (t,e)=>{
                this.model[this.model.activeChannel].amplitude = t,
                this.model[this.model.activeChannel].amplitudeUnit = e
            }
            ,
            this.onOffset = (t,e)=>{
                this.model[this.model.activeChannel].offset = t,
                this.model[this.model.activeChannel].offsetUnit = e
            }
            ,
            this.onFunction = t=>{
                this.model[this.model.activeChannel].fun = t
            }
            ,
            this.onChannel = t=>{
                this.model.activeChannel = t,
                this.setControls()
            }
            ,
            this.model = i.globalState.functionGenerator,
            this.display = new a.DisplayControl,
            this.functions = new r.FunctionControl,
            this.channels = new o.ChannelControl,
            this.setControls(),
            this.channels.handleChange(this.model.activeChannel),
            this.display.onFrequencyChange(this.onFrequency),
            this.display.onPhaseshiftChange(this.onPhaseshift),
            this.display.onAmplitudeChange(this.onAmplitude),
            this.display.onOffsetChange(this.onOffset),
            this.functions.onChange(this.onFunction),
            this.channels.onChannelChange(this.onChannel)
        }
        setControls() {
            this.display.initElements(this.model[this.model.activeChannel]),
            this.functions.handleChange(this.model[this.model.activeChannel].fun)
        }
        static selectFunction(t) {
            switch (t) {
            case i.FunctionMode.SINUS:
                return r.sinus;
            case i.FunctionMode.RECTANGLE:
                return r.rectangle;
            case i.FunctionMode.TRIANGLE:
                return r.triangle;
            case i.FunctionMode.SAW_TOOTH:
                return r.sawTooth
            }
        }
        getCH1Function() {
            return this.getFunction(this.model.ch1, i.ChannelMode.CH1)
        }
        getCH2Function() {
            return this.getFunction(this.model.ch2, i.ChannelMode.CH2)
        }
        getCH3Function() {
            return this.getFunction(this.model.ch3, i.ChannelMode.CH3)
        }
        getFunction(t, e) {
            var n;
            const r = s.selectFunction(t.fun)
              , o = Object.keys(i.globalState.connections).find(t=>{
                var n;
                return (null === (n = i.globalState.connections[t]) || void 0 === n ? void 0 : n.target) === e
            }
            );
            return r({
                frequency: t.frequency * Math.pow(10, t.frequencyUnit),
                phaseshift: t.phaseshift * Math.pow(10, t.phaseshiftUnit),
                amplitude: t.amplitude * Math.pow(10, t.amplitudeUnit),
                offset: (null === (n = i.globalState.controlPane[o]) || void 0 === n ? void 0 : n.AC) ? 0 : t.offset * Math.pow(10, t.offsetUnit)
            })
        }
    }
    const l = new s;
    e.functionGenerator = l
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    }),
    function(t) {
        t[t.VOLTAGE = 0] = 'VOLTAGE',
        t[t.TIME = 1] = 'TIME',
        t[t.STANDARD = 2] = 'STANDARD'
    }(e.RotaryButtonType || (e.RotaryButtonType = {})),
    n(4),
    n(5),
    n(17)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0);
    e.sinus = function(t) {
        const {frequency: e, phaseshift: n, amplitude: i, offset: r} = t
          , o = 2 * Math.PI * n * 1e3 / 360;
        return t=>i * Math.sin(2 * Math.PI * e * t + o) + r
    }
    ,
    e.rectangle = function(t) {
        const {frequency: e, phaseshift: n, amplitude: i, offset: r} = t
          , o = 2 * Math.PI * n * 1e3 / 360;
        return t=>i * Math.sign(Math.sin(2 * Math.PI * e * t + o)) + r
    }
    ,
    e.triangle = function(t) {
        const {frequency: e, phaseshift: n, amplitude: i, offset: r} = t
          , o = 1 / e;
        return t=>{
            const e = Math.floor(2 * t / o + .5);
            return i * (4 / o) * (t - o / 2 * Math.floor(e)) * Math.pow(-1, e) + r
        }
    }
    ,
    e.sawTooth = function(t) {
        const {frequency: e, phaseshift: n, amplitude: i, offset: r} = t
          , o = 1 / e
          , a = o * (1e3 * n) / 360;
        return t=>i * ((t + a) / o - Math.floor((t + a) / o)) + r - i / 2
    }
    ;
    e.FunctionControl = class {
        constructor() {
            this.sinus = document.getElementById('sinus-fun'),
            this.rectangle = document.getElementById('rectangle-fun'),
            this.triangle = document.getElementById('triangle-fun'),
            this.sawThooth = document.getElementById('saw-tooth-fun'),
            this.activeMode = i.FunctionMode.SINUS,
            this.registerHandler()
        }
        removeActiveClass(t) {
            switch (t) {
            case i.FunctionMode.SINUS:
                this.sinus.classList.remove('active');
                break;
            case i.FunctionMode.RECTANGLE:
                this.rectangle.classList.remove('active');
                break;
            case i.FunctionMode.TRIANGLE:
                this.triangle.classList.remove('active');
                break;
            case i.FunctionMode.SAW_TOOTH:
                this.sawThooth.classList.remove('active')
            }
        }
        addActiveClass(t) {
            switch (t) {
            case i.FunctionMode.SINUS:
                this.sinus.classList.add('active');
                break;
            case i.FunctionMode.RECTANGLE:
                this.rectangle.classList.add('active');
                break;
            case i.FunctionMode.TRIANGLE:
                this.triangle.classList.add('active');
                break;
            case i.FunctionMode.SAW_TOOTH:
                this.sawThooth.classList.add('active')
            }
        }
        registerHandler() {
            this.sinus.onclick = ()=>this.handleChange(i.FunctionMode.SINUS),
            this.rectangle.onclick = ()=>this.handleChange(i.FunctionMode.RECTANGLE),
            this.triangle.onclick = ()=>this.handleChange(i.FunctionMode.TRIANGLE),
            this.sawThooth.onclick = ()=>this.handleChange(i.FunctionMode.SAW_TOOTH)
        }
        handleChange(t) {
            var e;
            this.removeActiveClass(this.activeMode),
            this.activeMode = t,
            this.addActiveClass(t),
            null === (e = this.changeHandler) || void 0 === e || e.call(this, t)
        }
        onChange(t) {
            this.changeHandler = t
        }
    }
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(2);
    e.Pointer = class {
        constructor(t, e, n) {
            switch (this.tick = 1,
            this.fineMode = !1,
            this.svgRotaryDoc = e,
            this.valueKey = 0,
            this.type = t,
            this.givenValues = new Map,
            this.type) {
            case i.RotaryButtonType.VOLTAGE:
                this.setDefaultVoltageMap(),
                this.setInitialValue(n);
                break;
            case i.RotaryButtonType.TIME:
                this.setDefaultTimeMap(),
                this.setInitialValue(n);
                break;
            case i.RotaryButtonType.STANDARD:
                this.setActualValue(null != n ? n : this.tick)
            }
        }
        getSvgRotaryDoc() {
            return this.svgRotaryDoc
        }
        getActualValue() {
            return this.actualValue
        }
        setActualValue(t) {
            this.actualValue = t
        }
        getFineMode() {
            return this.fineMode
        }
        toggleFineMode() {
            this.fineMode = !this.fineMode
        }
        getKeyOfNearesVal(t) {
            let e = 0
              , n = this.givenValues.get(0).val;
            return this.givenValues.forEach((i,r)=>{
                Math.abs(i.val - t) < Math.abs(n - t) && (n = i.val,
                e = r)
            }
            ),
            e
        }
        containsValueInMap(t) {
            let e = !1;
            return this.givenValues.forEach(n=>{
                t === n.val && (e = !0)
            }
            ),
            e
        }
        setInitialValue(t) {
            void 0 === t ? this.setActualValue(this.givenValues.get(this.valueKey).val) : (this.setActualValue(t),
            this.valueKey = this.getKeyOfNearesVal(t),
            this.valueKeyBeforeFineMode = this.valueKey,
            this.actualElementIdInFineMode = this.givenValues.get(this.valueKey).elementId,
            this.containsValueInMap(t) || (this.toggleFineMode(),
            this.buildRangeInFineMode()))
        }
        enableIndicator() {
            const t = this.svgRotaryDoc.getElementById(this.givenValues.get(this.valueKey).elementId);
            this.fineMode || (t.classList.remove('blink_me'),
            t.setAttribute('fill', 'url(#grad1)')),
            this.fineMode && t.classList.add('blink_me')
        }
        disableIndicator() {
            if (this.fineMode) {
                this.svgRotaryDoc.getElementById(this.actualElementIdInFineMode).setAttribute('fill', '#3B393E')
            } else {
                this.svgRotaryDoc.getElementById(this.givenValues.get(this.valueKey).elementId).setAttribute('fill', '#3B393E')
            }
        }
        goSmaller() {
            this.type !== i.RotaryButtonType.STANDARD ? 0 !== this.valueKey && (this.fineMode || this.disableIndicator(),
            this.valueKey = this.valueKey - 1,
            this.setActualValue(this.givenValues.get(this.valueKey).val),
            this.fineMode || this.enableIndicator()) : this.actualValue > -100 && this.setActualValue(this.actualValue - this.tick)
        }
        goGreater() {
            this.type !== i.RotaryButtonType.STANDARD ? this.valueKey < this.givenValues.size - 1 && (this.fineMode || this.disableIndicator(),
            this.valueKey = this.valueKey + 1,
            this.setActualValue(this.givenValues.get(this.valueKey).val),
            this.fineMode || this.enableIndicator()) : this.actualValue < 100 && this.setActualValue(this.actualValue + this.tick)
        }
        buildRangeInFineMode() {
            let t, e;
            this.actualElementIdInFineMode = this.givenValues.get(this.valueKey).elementId,
            this.fineMode = !0,
            this.enableIndicator(),
            this.valueKeyBeforeFineMode = this.valueKey,
            t = this.valueKey < this.givenValues.size - 1 ? this.valueKey + 1 : this.valueKey,
            e = this.valueKey > 0 ? this.valueKey - 1 : this.valueKey;
            const n = (this.givenValues.get(t).val - this.givenValues.get(e).val) / 100;
            let i = parseFloat(this.givenValues.get(e).val.toFixed(5));
            this.givenValues.clear();
            for (let t = 0; t <= 100; t += 1)
                this.givenValues.set(t, {
                    elementId: 'dummy',
                    val: i
                }),
                i = parseFloat((i + n).toFixed(5));
            this.valueKey = this.getKeyOfNearesVal(this.actualValue)
        }
        setDefaultVoltageMap() {
            this.actualElementIdInFineMode = null,
            this.fineMode && (this.valueKey = this.valueKeyBeforeFineMode),
            this.givenValues.clear(),
            this.givenValues.set(0, {
                elementId: 'c1mV',
                val: .001
            }),
            this.givenValues.set(1, {
                elementId: 'c2mV',
                val: .002
            }),
            this.givenValues.set(2, {
                elementId: 'c5mV',
                val: .005
            }),
            this.givenValues.set(3, {
                elementId: 'c10mV',
                val: .01
            }),
            this.givenValues.set(4, {
                elementId: 'c20mV',
                val: .02
            }),
            this.givenValues.set(5, {
                elementId: 'c50mV',
                val: .05
            }),
            this.givenValues.set(6, {
                elementId: 'c.1V',
                val: .1
            }),
            this.givenValues.set(7, {
                elementId: 'c.2V',
                val: .2
            }),
            this.givenValues.set(8, {
                elementId: 'c.5V',
                val: .5
            }),
            this.givenValues.set(9, {
                elementId: 'c1V',
                val: 1
            }),
            this.givenValues.set(10, {
                elementId: 'c2V',
                val: 2
            }),
            this.givenValues.set(11, {
                elementId: 'c5V',
                val: 5
            }),
            this.givenValues.set(12, {
                elementId: 'c10V',
                val: 10
            }),
            this.givenValues.set(13, {
                elementId: 'c20V',
                val: 20
            })
        }
        setDefaultTimeMap() {
            this.actualElementIdInFineMode = null,
            this.fineMode && (this.valueKey = this.valueKeyBeforeFineMode),
            this.givenValues.clear(),
            this.givenValues.set(0, {
                elementId: 'c.1mues',
                val: 1e-4
            }),
            this.givenValues.set(1, {
                elementId: 'c.2mues',
                val: 2e-4
            }),
            this.givenValues.set(2, {
                elementId: 'c.5mues',
                val: 5e-4
            }),
            this.givenValues.set(3, {
                elementId: 'c1mues',
                val: .001
            }),
            this.givenValues.set(4, {
                elementId: 'c2mues',
                val: .002
            }),
            this.givenValues.set(5, {
                elementId: 'c5mues',
                val: .005
            }),
            this.givenValues.set(6, {
                elementId: 'c10mues',
                val: .01
            }),
            this.givenValues.set(7, {
                elementId: 'c20mues',
                val: .02
            }),
            this.givenValues.set(8, {
                elementId: 'c50mues',
                val: .05
            }),
            this.givenValues.set(9, {
                elementId: 'c.1ms',
                val: .1
            }),
            this.givenValues.set(10, {
                elementId: 'c.2ms',
                val: .2
            }),
            this.givenValues.set(11, {
                elementId: 'c.5ms',
                val: .5
            }),
            this.givenValues.set(12, {
                elementId: 'c1ms',
                val: 1
            }),
            this.givenValues.set(13, {
                elementId: 'c2ms',
                val: 2
            }),
            this.givenValues.set(14, {
                elementId: 'c5ms',
                val: 5
            }),
            this.givenValues.set(15, {
                elementId: 'c10ms',
                val: 10
            }),
            this.givenValues.set(16, {
                elementId: 'c20ms',
                val: 20
            }),
            this.givenValues.set(17, {
                elementId: 'c50ms',
                val: 50
            }),
            this.givenValues.set(18, {
                elementId: 'c.1s',
                val: 100
            }),
            this.givenValues.set(19, {
                elementId: 'c.2s',
                val: 200
            })
        }
    }
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(4)
      , r = n(2);
    e.RotaryKnob = class {
        constructor(t, e, n, r, o) {
            this.name = e,
            this.type = n,
            this.onChange = r,
            this.getHandler = t=>'mouseover' === t.type ? this.showTooltip(t) : 'mouseout' === t.type ? this.hideTooltip(t) : 'DOMMouseScroll' === t.type || 'mousewheel' === t.type ? this.changePosition(t) : 'keydown' === t.type || 'mousedown' === t.type ? this.fineMode() : void 0,
            window.addEventListener('load', ()=>{
                this.pointer = new i.Pointer(n,t,o);
                const e = this.pointer.getSvgRotaryDoc().getElementById(this.name);
                this.midPoint = {
                    x: e.cx.baseVal.value,
                    y: e.cy.baseVal.value
                },
                this.register()
            }
            ),
            this.posTick = 0,
            this.tickRatio = 28.8
        }
        register() {
            this.addEvents()
        }
        getPointer() {
            return this.pointer
        }
        changePosition(t) {
            t.preventDefault(),
            (-t.detail || t.wheelDeltaY) < 0 ? (this.pointer.goGreater(),
            this.posTick = (this.posTick + this.tickRatio) % 360) : (this.pointer.goSmaller(),
            this.posTick = (this.posTick - this.tickRatio) % 360),
            this.onChange(this.pointer.getActualValue()),
            this.spin(),
            this.showTooltip(t)
        }
        addEvents() {
            const t = this.pointer.getSvgRotaryDoc().getElementById(this.name);
            this.type !== r.RotaryButtonType.STANDARD && (t.addEventListener('mousedown', this.getHandler, !0),
            t.addEventListener('keydown', this.getHandler, !0)),
            t.addEventListener('mousewheel', this.getHandler, !0),
            t.addEventListener('DOMMouseScroll', this.getHandler, !0),
            t.addEventListener('mouseover', this.getHandler, !0),
            t.addEventListener('mouseout', this.getHandler, !0),
            this.type !== r.RotaryButtonType.STANDARD && this.pointer.enableIndicator()
        }
        removeEvents() {
            const t = this.pointer.getSvgRotaryDoc().getElementById(this.name);
            this.type !== r.RotaryButtonType.STANDARD && (t.removeEventListener('mousedown', this.getHandler, !0),
            t.removeEventListener('keydown', this.getHandler, !0)),
            t.removeEventListener('mousewheel', this.getHandler, !0),
            t.removeEventListener('DOMMouseScroll', this.getHandler, !0),
            t.removeEventListener('mouseover', this.getHandler, !0),
            t.removeEventListener('mouseout', this.getHandler, !0),
            this.pointer.disableIndicator()
        }
        showTooltip(t) {
            const e = document.getElementById(this.getIdOfTooltip());
            e.style.visibility = 'visible',
            e.innerHTML = this.pointer.getActualValue().toString()
        }
        hideTooltip(t) {
            document.getElementById(this.getIdOfTooltip()).style.visibility = 'hidden'
        }
        getIdOfTooltip() {
            switch (this.name) {
            case 'rotary-button-CH1':
                return 'tooltip-CH1';
            case 'rotary-button-CH2':
                return 'tooltip-CH2';
            case 'rotary-button-TIME':
                return 'tooltip-TIME';
            case 'rotary-button-POS1':
                return 'tooltip-POS1';
            case 'rotary-button-POS2':
                return 'tooltip-POS2';
            case 'rotary-button-XPOS':
                return 'tooltip-XPOS';
            case 'rotary-button-TL':
                return 'tooltip-TL'
            }
        }
        fineMode() {
            if (this.pointer.getFineMode()) {
                switch (this.type) {
                case r.RotaryButtonType.VOLTAGE:
                    this.pointer.disableIndicator(),
                    this.pointer.setDefaultVoltageMap();
                    break;
                case r.RotaryButtonType.TIME:
                    this.pointer.setDefaultTimeMap()
                }
                this.pointer.toggleFineMode(),
                this.pointer.enableIndicator()
            } else
                this.pointer.buildRangeInFineMode()
        }
        spin() {
            this.getPointer().getSvgRotaryDoc().getElementById('knob-texture').setAttribute('transform', `rotate(${this.posTick} ${this.midPoint.x} ${this.midPoint.y})`)
        }
    }
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    }),
    n(7),
    n(8),
    n(21),
    n(11),
    n(12),
    n(13),
    n(14),
    n(16),
    n(2),
    n(18),
    n(19),
    n(20)
}
, function(t, e, n) {}
, function(t, e, n) {}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0);
    e.ChannelControl = class {
        constructor() {
            this.ch1 = document.getElementById('fun-ch1'),
            this.ch2 = document.getElementById('fun-ch2'),
            this.ch3 = document.getElementById('fun-ch3'),
            this.activeMode = i.ChannelMode.CH1,
            this.registerHandler(),
            this.handleChange(this.activeMode)
        }
        removeActiveClass(t) {
            switch (t) {
            case i.ChannelMode.CH1:
                this.ch1.classList.remove('active');
                break;
            case i.ChannelMode.CH2:
                this.ch2.classList.remove('active');
                break;
            case i.ChannelMode.CH3:
                this.ch3.classList.remove('active')
            }
        }
        addActiveClass(t) {
            switch (t) {
            case i.ChannelMode.CH1:
                this.ch1.classList.add('active');
                break;
            case i.ChannelMode.CH2:
                this.ch2.classList.add('active');
                break;
            case i.ChannelMode.CH3:
                this.ch3.classList.add('active')
            }
        }
        registerHandler() {
            this.ch1.onclick = ()=>this.handleChange(i.ChannelMode.CH1),
            this.ch2.onclick = ()=>this.handleChange(i.ChannelMode.CH2),
            this.ch3.onclick = ()=>this.handleChange(i.ChannelMode.CH3)
        }
        handleChange(t) {
            var e;
            this.removeActiveClass(this.activeMode),
            this.activeMode = t,
            this.addActiveClass(t),
            null === (e = this.channelChangeHandler) || void 0 === e || e.call(this, t)
        }
        onChannelChange(t) {
            this.channelChangeHandler = t
        }
    }
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    class i {
        constructor() {
            this.frequency = {
                value: document.getElementById('frequency-value'),
                unit: document.getElementById('frequency-unit')
            },
            this.phaseshift = {
                value: document.getElementById('phase-shift-value'),
                unit: document.getElementById('phase-shift-unit')
            },
            this.amplitude = {
                value: document.getElementById('amplitude-value'),
                unit: document.getElementById('amplitude-unit')
            },
            this.offset = {
                value: document.getElementById('offset-value'),
                unit: document.getElementById('offset-unit')
            },
            this.registerHandler()
        }
        static onChange(t, e) {
            var n;
            const i = t.value.valueAsNumber
              , r = parseInt(t.unit.value, 10);
            null === (n = e) || void 0 === n || n(i, r)
        }
        registerHandler() {
            const t = ()=>{
                i.onChange(this.frequency, this.frequencyChangeHandler)
            }
              , e = ()=>{
                i.onChange(this.phaseshift, this.phaseshiftChangeHandler)
            }
              , n = ()=>{
                i.onChange(this.amplitude, this.amplitudeChangeHandler)
            }
              , r = ()=>{
                i.onChange(this.offset, this.offsetChangeHandler)
            }
            ;
            this.frequency.value.onchange = t,
            this.frequency.unit.onchange = t,
            this.phaseshift.value.onchange = e,
            this.phaseshift.unit.onchange = e,
            this.amplitude.value.onchange = n,
            this.amplitude.unit.onchange = n,
            this.offset.value.onchange = r,
            this.offset.unit.onchange = r
        }
        initElements(t) {
            this.frequency.value.valueAsNumber = 1e3 * t.frequency,
            this.frequency.unit.value = t.frequencyUnit.toString(),
            this.phaseshift.value.valueAsNumber = 1e3 * t.phaseshift,
            this.phaseshift.unit.value = t.phaseshiftUnit.toString(),
            this.amplitude.value.valueAsNumber = t.amplitude,
            this.amplitude.unit.value = t.amplitudeUnit.toString(),
            this.offset.value.valueAsNumber = t.offset,
            this.offset.unit.value = t.offsetUnit.toString()
        }
        onFrequencyChange(t) {
            this.frequencyChangeHandler = t
        }
        onPhaseshiftChange(t) {
            this.phaseshiftChangeHandler = t
        }
        onAmplitudeChange(t) {
            this.amplitudeChangeHandler = t
        }
        onOffsetChange(t) {
            this.offsetChangeHandler = t
        }
    }
    e.DisplayControl = i
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = document.getElementById('button-CH1')
      , o = document.getElementById('button-CH2')
      , a = document.getElementById('button-DUAL')
      , s = document.getElementById('button-ADD')
      , l = document.getElementById('button-XY');
    function c(t) {
        switch (i.globalState.displayChannelMode = t,
        r.classList.remove('active'),
        o.classList.remove('active'),
        a.classList.remove('active'),
        s.classList.remove('active'),
        l.classList.remove('active'),
        t) {
        case i.DisplayChannelMode.CH1:
            r.classList.add('active');
            break;
        case i.DisplayChannelMode.CH2:
            o.classList.add('active');
            break;
        case i.DisplayChannelMode.DUAL:
            a.classList.add('active');
            break;
        case i.DisplayChannelMode.ADD:
            s.classList.add('active');
            break;
        case i.DisplayChannelMode.XY:
            l.classList.add('active')
        }
    }
    r.onclick = ()=>c(i.DisplayChannelMode.CH1),
    o.onclick = ()=>c(i.DisplayChannelMode.CH2),
    a.onclick = ()=>c(i.DisplayChannelMode.DUAL),
    s.onclick = ()=>c(i.DisplayChannelMode.ADD),
    l.onclick = ()=>c(i.DisplayChannelMode.XY),
    c(i.globalState.displayChannelMode)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = document.getElementById('button-CH1-AC')
      , o = document.getElementById('button-CH2-AC')
      , a = document.getElementById('button-CH1-GND')
      , s = document.getElementById('button-CH2-GND')
      , l = document.getElementById('button-CH2-INV');
    i.globalState.controlPane.ch1.AC && r.classList.add('active'),
    i.globalState.controlPane.ch1.GND && a.classList.add('active'),
    i.globalState.controlPane.ch2.AC && o.classList.add('active'),
    i.globalState.controlPane.ch2.GND && s.classList.add('active'),
    i.globalState.controlPane.ch2.INV && l.classList.add('active'),
    r.onclick = ()=>{
        i.globalState.controlPane.ch1.AC ? (r.classList.remove('active'),
        i.globalState.controlPane.ch1.AC = !1) : (r.classList.add('active'),
        i.globalState.controlPane.ch1.AC = !0)
    }
    ,
    o.onclick = ()=>{
        i.globalState.controlPane.ch2.AC ? (o.classList.remove('active'),
        i.globalState.controlPane.ch2.AC = !1) : (o.classList.add('active'),
        i.globalState.controlPane.ch2.AC = !0)
    }
    ,
    a.onclick = ()=>{
        i.globalState.controlPane.ch1.GND ? (a.classList.remove('active'),
        i.globalState.controlPane.ch1.GND = !1) : (a.classList.add('active'),
        i.globalState.controlPane.ch1.GND = !0)
    }
    ,
    s.onclick = ()=>{
        i.globalState.controlPane.ch2.GND ? (s.classList.remove('active'),
        i.globalState.controlPane.ch2.GND = !1) : (s.classList.add('active'),
        i.globalState.controlPane.ch2.GND = !0)
    }
    ,
    l.onclick = ()=>{
        i.globalState.controlPane.ch2.INV ? (l.classList.remove('active'),
        i.globalState.controlPane.ch2.INV = !1) : (l.classList.add('active'),
        i.globalState.controlPane.ch2.INV = !0)
    }
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    }),
    n(3),
    n(1)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(15)
      , r = n(0);
    e.oscilloscopeCH1 = 'button-input-CH1',
    e.oscilloscopeCH2 = 'button-input-CH2',
    e.oscilloscopeEXT = 'button-input-EXT',
    e.functionGeneratorCH1 = 'fun-channel-ch1',
    e.functionGeneratorCH2 = 'fun-channel-ch2',
    e.functionGeneratorCH3 = 'fun-channel-ch3';
    const o = [e.oscilloscopeCH1, e.oscilloscopeCH2, e.oscilloscopeEXT]
      , a = new Map;
    a.set(e.oscilloscopeCH1, r.OscilloscopeChannelMode.CH1),
    a.set(e.oscilloscopeCH2, r.OscilloscopeChannelMode.CH2),
    a.set(e.oscilloscopeEXT, r.OscilloscopeChannelMode.EXT),
    a.set(e.functionGeneratorCH1, r.ChannelMode.CH1),
    a.set(e.functionGeneratorCH2, r.ChannelMode.CH2),
    a.set(e.functionGeneratorCH3, r.ChannelMode.CH3);
    const s = ['#F0D58C', '#38E7FF', '#9d363f']; //38E7FF
    function l() {
        return .4 * document.getElementById(e.oscilloscopeCH1).clientWidth
    }
    function c() {
        return .5 * l()
    }
    const h = document.getElementsByTagName('body').item(0)
      , u = i.jsPlumb.getInstance({
        Container: h
    });
    function p() {
        !function() {
            const t = {
                isSource: !0,
                isTarget: !0,
                anchor: 'Center',
                maxConnections: 1,
                endpoint: 'Dot'
            };
            let e = 0;
            for (const n of document.getElementsByClassName('channel'))
                'input-pane' === n.parentElement.id && (t.connectorStyle = {
                    stroke: s[e],
                    strokeWidth: c()
                },
                t.endpointStyle = {
                    stroke: s[e],
                    fill: s[e],
                    radius: l()
                },
                e += 1),
                u.makeSource(n, Object.assign({}, t), null, h),
                u.makeTarget(n, Object.assign({}, t))
        }(),
        function() {
            var t;
            for (const e of Object.keys(r.globalState.connections)) {
                const n = y(e)
                  , i = x(null === (t = r.globalState.connections[e]) || void 0 === t ? void 0 : t.target);
                if (void 0 !== i) {
                    const t = s[b(e)];
                    u.connect({
                        source: n,
                        target: i
                    }).endpoints.forEach(e=>f(e, t))
                }
            }
        }(),
        u.bind('connection', d),
        u.bind('connectionMoved', t=>{
            !function(t, e, n, i) {
                g(t, e),
                m(n, i)
            }(t.originalSourceId, t.originalTargetId, t.newSourceId, t.newTargetId)
        }
        ),
        u.bind('connectionDetached', t=>{
            g(t.sourceId, t.targetId)
        }
        )
    }
    function d(t) {
        if (t.sourceId.startsWith(t.targetId.substring(0, 3)))
            return void u.deleteConnection(t.connection);
        const e = function(t) {
            var e, n;
            if (v(t.sourceId))
                return null === (e = t.sourceEndpoint.getPaintStyle()) || void 0 === e ? void 0 : e.stroke;
            return null === (n = t.targetEndpoint.getPaintStyle()) || void 0 === n ? void 0 : n.stroke
        }(t);
        f(t.sourceEndpoint, e),
        f(t.targetEndpoint, e),
        function(t, e) {
            t.setPaintStyle({
                stroke: e,
                strokeWidth: c()
            })
        }(t.connection, e),
        m(t.sourceId, t.targetId)
    }
    function f(t, e) {
        t.setPaintStyle({
            stroke: e,
            fill: e,
            radius: l()
        })
    }
    function m(t, e) {
        if (v(t)) {
            const n = a.get(t)
              , i = a.get(e);
            r.globalState.connections[n] = {
                colorIdx: 0,
                target: i
            }
        } else {
            const n = a.get(e)
              , i = a.get(t);
            r.globalState.connections[n] = {
                colorIdx: 0,
                target: i
            }
        }
    }
    function g(t, e) {
        if (v(t)) {
            const e = a.get(t);
            r.globalState.connections[e] = void 0
        } else {
            const t = a.get(e);
            r.globalState.connections[t] = void 0
        }
    }
    function v(t) {
        return void 0 !== o.find(e=>t === e)
    }
    function y(t) {
        for (const e of a.keys())
            if (v(e) && a.get(e) === t)
                return e
    }
    function x(t) {
        for (const e of a.keys())
            if (!v(e) && a.get(e) === t)
                return e
    }
    function b(t) {
        switch (t) {
        case 'ch1':
            return 0;
        case 'ch2':
            return 1;
        case 'ext':
            return 2;
        default:
            return
        }
    }
    u.ready(p),
    window.addEventListener('resize', ()=>{
        u.reset(),
        p()
    }
    )
}
, function(t, e, n) {
    (function() {
        void 0 === Math.sgn && (Math.sgn = function(t) {
            return 0 == t ? 0 : t > 0 ? 1 : -1
        }
        );
        var t = function(t, e) {
            return {
                x: t.x - e.x,
                y: t.y - e.y
            }
        }
          , n = function(t, e) {
            return t.x * e.x + t.y * e.y
        }
          , i = function(t) {
            return Math.sqrt(t.x * t.x + t.y * t.y)
        }
          , r = function(t, e) {
            return {
                x: t.x * e,
                y: t.y * e
            }
        }
          , o = Math.pow(2, -65)
          , a = function(e, n) {
            for (var r = [], o = s(e, n), a = n.length - 1, c = l(o, 2 * a - 1, r, 0), h = t(e, n[0]), u = i(h), d = 0, f = 0; f < c; f++) {
                h = t(e, p(n, a, r[f], null, null));
                var m = i(h);
                m < u && (u = m,
                d = r[f])
            }
            return h = t(e, n[a]),
            (m = i(h)) < u && (u = m,
            d = 1),
            {
                location: d,
                distance: u
            }
        }
          , s = function(e, i) {
            for (var o = i.length - 1, a = 2 * o - 1, s = [], l = [], c = [], h = [], u = [[1, .6, .3, .1], [.4, .6, .6, .4], [.1, .3, .6, 1]], p = 0; p <= o; p++)
                s[p] = t(i[p], e);
            for (p = 0; p <= o - 1; p++)
                l[p] = t(i[p + 1], i[p]),
                l[p] = r(l[p], 3);
            for (var d = 0; d <= o - 1; d++)
                for (var f = 0; f <= o; f++)
                    c[d] || (c[d] = []),
                    c[d][f] = n(l[d], s[f]);
            for (p = 0; p <= a; p++)
                h[p] || (h[p] = []),
                h[p].y = 0,
                h[p].x = parseFloat(p) / a;
            for (var m = o, g = o - 1, v = 0; v <= m + g; v++) {
                var y = Math.max(0, v - g)
                  , x = Math.min(v, m);
                for (p = y; p <= x; p++) {
                    var b = v - p;
                    h[p + b].y += c[b][p] * u[b][p]
                }
            }
            return h
        }
          , l = function(t, e, n, i) {
            var r, o, a = [], s = [], d = [], f = [];
            switch (c(t, e)) {
            case 0:
                return 0;
            case 1:
                if (i >= 64)
                    return n[0] = (t[0].x + t[e].x) / 2,
                    1;
                if (h(t, e))
                    return n[0] = u(t, e),
                    1
            }
            p(t, e, .5, a, s),
            r = l(a, e, d, i + 1),
            o = l(s, e, f, i + 1);
            for (var m = 0; m < r; m++)
                n[m] = d[m];
            for (m = 0; m < o; m++)
                n[m + r] = f[m];
            return r + o
        }
          , c = function(t, e) {
            var n, i, r = 0;
            n = i = Math.sgn(t[0].y);
            for (var o = 1; o <= e; o++)
                (n = Math.sgn(t[o].y)) != i && r++,
                i = n;
            return r
        }
          , h = function(t, e) {
            var n, i, r, a, s, l, c, h, u;
            a = t[0].y - t[e].y,
            s = t[e].x - t[0].x,
            l = t[0].x * t[e].y - t[e].x * t[0].y,
            h = u = 0;
            for (var p = 1; p < e; p++) {
                var d = a * t[p].x + s * t[p].y + l;
                d > h ? h = d : d < u && (u = d)
            }
            return 0,
            1,
            0,
            n = (1 * (l - h) - 0 * (c = s)) * (1 / (0 * c - 1 * a)),
            i = (1 * (l - u) - 0 * (c = s)) * (1 / (0 * c - 1 * a)),
            r = Math.min(n, i),
            Math.max(n, i) - r < o ? 1 : 0
        }
          , u = function(t, e) {
            var n = t[e].x - t[0].x
              , i = t[e].y - t[0].y
              , r = t[0].x - 0;
            return 0 + 1 * ((n * (t[0].y - 0) - i * r) * (1 / (0 * n - 1 * i)))
        }
          , p = function(t, e, n, i, r) {
            for (var o = [[]], a = 0; a <= e; a++)
                o[0][a] = t[a];
            for (var s = 1; s <= e; s++)
                for (a = 0; a <= e - s; a++)
                    o[s] || (o[s] = []),
                    o[s][a] || (o[s][a] = {}),
                    o[s][a].x = (1 - n) * o[s - 1][a].x + n * o[s - 1][a + 1].x,
                    o[s][a].y = (1 - n) * o[s - 1][a].y + n * o[s - 1][a + 1].y;
            if (null != i)
                for (a = 0; a <= e; a++)
                    i[a] = o[a][0];
            if (null != r)
                for (a = 0; a <= e; a++)
                    r[a] = o[e - a][a];
            return o[e][0]
        }
          , d = {}
          , f = function(t, e) {
            for (var n = function(t) {
                var e = d[t];
                if (!e) {
                    var n = function(t) {
                        return function(e) {
                            return t
                        }
                    }
                      , i = function() {
                        return function(t) {
                            return t
                        }
                    }
                      , r = function() {
                        return function(t) {
                            return 1 - t
                        }
                    }
                      , o = function(t) {
                        return function(e) {
                            for (var n = 1, i = 0; i < t.length; i++)
                                n *= t[i](e);
                            return n
                        }
                    };
                    (e = []).push(new function() {
                        return function(e) {
                            return Math.pow(e, t)
                        }
                    }
                    );
                    for (var a = 1; a < t; a++) {
                        for (var s = [new n(t)], l = 0; l < t - a; l++)
                            s.push(new i);
                        for (l = 0; l < a; l++)
                            s.push(new r);
                        e.push(new o(s))
                    }
                    e.push(new function() {
                        return function(e) {
                            return Math.pow(1 - e, t)
                        }
                    }
                    ),
                    d[t] = e
                }
                return e
            }(t.length - 1), i = 0, r = 0, o = 0; o < t.length; o++)
                i += t[o].x * n[o](e),
                r += t[o].y * n[o](e);
            return {
                x: i,
                y: r
            }
        }
          , m = function(t, e) {
            return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
        }
          , g = function(t) {
            return t[0].x === t[1].x && t[0].y === t[1].y
        }
          , v = function(t, e, n) {
            if (g(t))
                return {
                    point: t[0],
                    location: e
                };
            for (var i = f(t, e), r = 0, o = e, a = n > 0 ? 1 : -1, s = null; r < Math.abs(n); )
                s = f(t, o += .005 * a),
                r += m(s, i),
                i = s;
            return {
                point: s,
                location: o
            }
        }
          , y = function(t, e) {
            var n = f(t, e)
              , i = f(t.slice(0, t.length - 1), e)
              , r = i.y - n.y
              , o = i.x - n.x;
            return 0 === r ? 1 / 0 : Math.atan(r / o)
        }
          , x = function(t, e, n, i, r) {
            var o = i - e
              , a = t - n
              , s = t * (e - i) + e * (n - t)
              , l = function(t) {
                return [b(t, 'x'), b(t, 'y')]
            }(r)
              , c = [o * l[0][0] + a * l[1][0], o * l[0][1] + a * l[1][1], o * l[0][2] + a * l[1][2], o * l[0][3] + a * l[1][3] + s]
              , h = M.apply(null, c)
              , u = [];
            if (null != h)
                for (var p = 0; p < 3; p++) {
                    var d, f = h[p], m = Math.pow(f, 2), g = Math.pow(f, 3), v = [l[0][0] * g + l[0][1] * m + l[0][2] * f + l[0][3], l[1][0] * g + l[1][1] * m + l[1][2] * f + l[1][3]];
                    d = n - t != 0 ? (v[0] - t) / (n - t) : (v[1] - e) / (i - e),
                    f >= 0 && f <= 1 && d >= 0 && d <= 1 && u.push(v)
                }
            return u
        };
        function b(t, e) {
            return [-t[0][e] + 3 * t[1][e] + -3 * t[2][e] + t[3][e], 3 * t[0][e] - 6 * t[1][e] + 3 * t[2][e], -3 * t[0][e] + 3 * t[1][e], t[0][e]]
        }
        function _(t) {
            return t < 0 ? -1 : t > 0 ? 1 : 0
        }
        function M(t, e, n, i) {
            var r, o, a = e / t, s = n / t, l = i / t, c = (3 * s - Math.pow(a, 2)) / 9, h = (9 * a * s - 27 * l - 2 * Math.pow(a, 3)) / 54, u = Math.pow(c, 3) + Math.pow(h, 2), p = [];
            if (u >= 0)
                r = _(h + Math.sqrt(u)) * Math.pow(Math.abs(h + Math.sqrt(u)), 1 / 3),
                o = _(h - Math.sqrt(u)) * Math.pow(Math.abs(h - Math.sqrt(u)), 1 / 3),
                p[0] = -a / 3 + (r + o),
                p[1] = -a / 3 - (r + o) / 2,
                p[2] = -a / 3 - (r + o) / 2,
                0 !== Math.abs(Math.sqrt(3) * (r - o) / 2) && (p[1] = -1,
                p[2] = -1);
            else {
                var d = Math.acos(h / Math.sqrt(-Math.pow(c, 3)));
                p[0] = 2 * Math.sqrt(-c) * Math.cos(d / 3) - a / 3,
                p[1] = 2 * Math.sqrt(-c) * Math.cos((d + 2 * Math.PI) / 3) - a / 3,
                p[2] = 2 * Math.sqrt(-c) * Math.cos((d + 4 * Math.PI) / 3) - a / 3
            }
            for (var f = 0; f < 3; f++)
                (p[f] < 0 || p[f] > 1) && (p[f] = -1);
            return p
        }
        var w = this.jsBezier = {
            distanceFromCurve: a,
            gradientAtPoint: y,
            gradientAtPointAlongCurveFrom: function(t, e, n) {
                var i = v(t, e, n);
                return i.location > 1 && (i.location = 1),
                i.location < 0 && (i.location = 0),
                y(t, i.location)
            },
            nearestPointOnCurve: function(t, e) {
                var n = a(t, e);
                return {
                    point: p(e, e.length - 1, n.location, null, null),
                    location: n.location
                }
            },
            pointOnCurve: f,
            pointAlongCurveFrom: function(t, e, n) {
                return v(t, e, n).point
            },
            perpendicularToCurveAt: function(t, e, n, i) {
                var r = v(t, e, i = null == i ? 0 : i)
                  , o = y(t, r.location)
                  , a = Math.atan(-1 / o)
                  , s = n / 2 * Math.sin(a)
                  , l = n / 2 * Math.cos(a);
                return [{
                    x: r.point.x + l,
                    y: r.point.y + s
                }, {
                    x: r.point.x - l,
                    y: r.point.y - s
                }]
            },
            locationAlongCurveFrom: function(t, e, n) {
                return v(t, e, n).location
            },
            getLength: function(t) {
                if (g(t))
                    return 0;
                for (var e = f(t, 0), n = 0, i = 0, r = null; i < 1; )
                    r = f(t, i += .005),
                    n += m(r, e),
                    e = r;
                return n
            },
            lineIntersection: x,
            boxIntersection: function(t, e, n, i, r) {
                var o = [];
                return o.push.apply(o, x(t, e, t + n, e, r)),
                o.push.apply(o, x(t + n, e, t + n, e + i, r)),
                o.push.apply(o, x(t + n, e + i, t, e + i, r)),
                o.push.apply(o, x(t, e + i, t, e, r)),
                o
            },
            boundingBoxIntersection: function(t, e) {
                var n = [];
                return n.push.apply(n, x(t.x, t.y, t.x + t.w, t.y, e)),
                n.push.apply(n, x(t.x + t.w, t.y, t.x + t.w, t.y + t.h, e)),
                n.push.apply(n, x(t.x + t.w, t.y + t.h, t.x, t.y + t.h, e)),
                n.push.apply(n, x(t.x, t.y + t.h, t.x, t.y, e)),
                n
            },
            version: '0.9.0'
        };
        e.jsBezier = w
    }
    ).call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.Biltong = {
            version: '0.4.0'
        };
        e.Biltong = t;
        var n = function(t) {
            return '[object Array]' === Object.prototype.toString.call(t)
        }
          , i = function(t, e, i) {
            return i(t = n(t) ? t : [t.x, t.y], e = n(e) ? e : [e.x, e.y])
        }
          , r = t.gradient = function(t, e) {
            return i(t, e, (function(t, e) {
                return e[0] == t[0] ? e[1] > t[1] ? 1 / 0 : -1 / 0 : e[1] == t[1] ? e[0] > t[0] ? 0 : -0 : (e[1] - t[1]) / (e[0] - t[0])
            }
            ))
        }
          , o = (t.normal = function(t, e) {
            return -1 / r(t, e)
        }
        ,
        t.lineLength = function(t, e) {
            return i(t, e, (function(t, e) {
                return Math.sqrt(Math.pow(e[1] - t[1], 2) + Math.pow(e[0] - t[0], 2))
            }
            ))
        }
        ,
        t.quadrant = function(t, e) {
            return i(t, e, (function(t, e) {
                return e[0] > t[0] ? e[1] > t[1] ? 2 : 1 : e[0] == t[0] ? e[1] > t[1] ? 2 : 1 : e[1] > t[1] ? 3 : 4
            }
            ))
        }
        )
          , a = (t.theta = function(t, e) {
            return i(t, e, (function(t, e) {
                var n = r(t, e)
                  , i = Math.atan(n)
                  , a = o(t, e);
                return 4 != a && 3 != a || (i += Math.PI),
                i < 0 && (i += 2 * Math.PI),
                i
            }
            ))
        }
        ,
        t.intersects = function(t, e) {
            var n = t.x
              , i = t.x + t.w
              , r = t.y
              , o = t.y + t.h
              , a = e.x
              , s = e.x + e.w
              , l = e.y
              , c = e.y + e.h;
            return n <= a && a <= i && r <= l && l <= o || n <= s && s <= i && r <= l && l <= o || n <= a && a <= i && r <= c && c <= o || n <= s && a <= i && r <= c && c <= o || a <= n && n <= s && l <= r && r <= c || a <= i && i <= s && l <= r && r <= c || a <= n && n <= s && l <= o && o <= c || a <= i && n <= s && l <= o && o <= c
        }
        ,
        t.encloses = function(t, e, n) {
            var i = t.x
              , r = t.x + t.w
              , o = t.y
              , a = t.y + t.h
              , s = e.x
              , l = e.x + e.w
              , c = e.y
              , h = e.y + e.h
              , u = function(t, e, i, r) {
                return n ? t <= e && i >= r : t < e && i > r
            };
            return u(i, s, r, l) && u(o, c, a, h)
        }
        ,
        [null, [1, -1], [1, 1], [-1, 1], [-1, -1]])
          , s = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
        t.pointOnLine = function(t, e, n) {
            var i = r(t, e)
              , l = o(t, e)
              , c = n > 0 ? a[l] : s[l]
              , h = Math.atan(i)
              , u = Math.abs(n * Math.sin(h)) * c[1]
              , p = Math.abs(n * Math.cos(h)) * c[0];
            return {
                x: t.x + p,
                y: t.y + u
            }
        }
        ,
        t.perpendicularLineTo = function(t, e, n) {
            var i = r(t, e)
              , o = Math.atan(-1 / i)
              , a = n / 2 * Math.sin(o)
              , s = n / 2 * Math.cos(o);
            return [{
                x: e.x + s,
                y: e.y + a
            }, {
                x: e.x - s,
                y: e.y - a
            }]
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        function t(t, e, n, i, r, o, a, s) {
            return new Touch({
                target: e,
                identifier: L(),
                pageX: n,
                pageY: i,
                screenX: r,
                screenY: o,
                clientX: a || r,
                clientY: s || o
            })
        }
        function n(e, n, i, r, o, a, s, l) {
            return function() {
                var t = [];
                return Array.prototype.push.apply(t, arguments),
                t.item = function(t) {
                    return this[t]
                }
                ,
                t
            }(t.apply(null, arguments))
        }
        var i = function(t, e, n) {
            for (var i = (n = n || t.parentNode).querySelectorAll(e), r = 0; r < i.length; r++)
                if (i[r] === t)
                    return !0;
            return !1
        }
          , r = function(t) {
            return 'string' == typeof t || t.constructor === String ? document.getElementById(t) : t
        }
          , o = function(t) {
            return t.srcElement || t.target
        }
          , a = function(t, e, n, i) {
            if (i) {
                if (void 0 !== t.path && t.path.indexOf)
                    return {
                        path: t.path,
                        end: t.path.indexOf(n)
                    };
                var r = {
                    path: [],
                    end: -1
                }
                  , o = function(t) {
                    r.path.push(t),
                    t === n ? r.end = r.path.length - 1 : null != t.parentNode && o(t.parentNode)
                };
                return o(e),
                r
            }
            return {
                path: [e],
                end: 1
            }
        }
          , s = function(t, e) {
            for (var n = 0, i = t.length; n < i && t[n] != e; n++)
                ;
            n < t.length && t.splice(n, 1)
        }
          , l = 1
          , c = function(t, e, n) {
            var i = l++;
            return t.__ta = t.__ta || {},
            t.__ta[e] = t.__ta[e] || {},
            t.__ta[e][i] = n,
            n.__tauid = i,
            i
        }
          , h = function(t, e, n, r) {
            if (null == t)
                return n;
            var s = t.split(',')
              , l = function(r) {
                l.__tauid = n.__tauid;
                var c = o(r)
                  , h = c
                  , u = a(r, c, e, null != t);
                if (-1 != u.end)
                    for (var p = 0; p < u.end; p++) {
                        h = u.path[p];
                        for (var d = 0; d < s.length; d++)
                            i(h, s[d], e) && n.apply(h, arguments)
                    }
            };
            return u(n, r, l),
            l
        }
          , u = function(t, e, n) {
            t.__taExtra = t.__taExtra || [],
            t.__taExtra.push([e, n])
        }
          , p = function(t, e, n, i) {
            if (v && x[e]) {
                var r = h(i, t, n, x[e]);
                A(t, x[e], r, n)
            }
            'focus' === e && null == t.getAttribute('tabindex') && t.setAttribute('tabindex', '1'),
            A(t, e, h(i, t, n, e), n)
        }
          , d = {
            tap: {
                touches: 1,
                taps: 1
            },
            dbltap: {
                touches: 1,
                taps: 2
            },
            contextmenu: {
                touches: 2,
                taps: 1
            }
        }
          , f = function(t, e) {
            return function(n, r, l, c) {
                if ('contextmenu' == r && y)
                    p(n, r, l, c);
                else {
                    if (null == n.__taTapHandler) {
                        var h = n.__taTapHandler = {
                            tap: [],
                            dbltap: [],
                            contextmenu: [],
                            down: !1,
                            taps: 0,
                            downSelectors: []
                        }
                          , u = function() {
                            h.down = !1
                        }
                          , f = function() {
                            h.taps = 0
                        };
                        p(n, 'mousedown', (function(r) {
                            for (var s = o(r), l = a(r, s, n, null != c), p = !1, d = 0; d < l.end; d++) {
                                if (p)
                                    return;
                                s = l.path[d];
                                for (var m = 0; m < h.downSelectors.length; m++)
                                    if (null == h.downSelectors[m] || i(s, h.downSelectors[m], n)) {
                                        h.down = !0,
                                        setTimeout(u, t),
                                        setTimeout(f, e),
                                        p = !0;
                                        break
                                    }
                            }
                        }
                        )),
                        p(n, 'mouseup', (function(t) {
                            if (h.down) {
                                var e, r, s = o(t);
                                h.taps++;
                                var l = C(t);
                                for (var c in d)
                                    if (d.hasOwnProperty(c)) {
                                        var u = d[c];
                                        if (u.touches === l && (1 === u.taps || u.taps === h.taps))
                                            for (var p = 0; p < h[c].length; p++) {
                                                r = a(t, s, n, null != h[c][p][1]);
                                                for (var f = 0; f < r.end; f++)
                                                    if (e = r.path[f],
                                                    null == h[c][p][1] || i(e, h[c][p][1], n)) {
                                                        h[c][p][0].apply(e, [t]);
                                                        break
                                                    }
                                            }
                                    }
                            }
                        }
                        ))
                    }
                    n.__taTapHandler.downSelectors.push(c),
                    n.__taTapHandler[r].push([l, c]),
                    l.__taUnstore = function() {
                        s(n.__taTapHandler[r], l)
                    }
                }
            }
        }
          , m = function(t, e, n, i) {
            for (var r in n.__tamee[t])
                n.__tamee[t].hasOwnProperty(r) && n.__tamee[t][r].apply(i, [e])
        }
          , g = function() {
            var t = [];
            return function(e, n, r, a) {
                if (!e.__tamee) {
                    e.__tamee = {
                        over: !1,
                        mouseenter: [],
                        mouseexit: []
                    };
                    var s = function(n) {
                        var r = o(n);
                        (null == a && r == e && !e.__tamee.over || i(r, a, e) && (null == r.__tamee || !r.__tamee.over)) && (m('mouseenter', n, e, r),
                        r.__tamee = r.__tamee || {},
                        r.__tamee.over = !0,
                        t.push(r))
                    }
                      , l = function(n) {
                        for (var r = o(n), a = 0; a < t.length; a++)
                            r != t[a] || i(n.relatedTarget || n.toElement, '*', r) || (r.__tamee.over = !1,
                            t.splice(a, 1),
                            m('mouseexit', n, e, r))
                    };
                    A(e, 'mouseover', h(a, e, s, 'mouseover'), s),
                    A(e, 'mouseout', h(a, e, l, 'mouseout'), l)
                }
                r.__taUnstore = function() {
                    delete e.__tamee[n][r.__tauid]
                }
                ,
                c(e, n, r),
                e.__tamee[n][r.__tauid] = r
            }
        }
          , v = 'ontouchstart'in document.documentElement
          , y = 'onmousedown'in document.documentElement
          , x = {
            mousedown: 'touchstart',
            mouseup: 'touchend',
            mousemove: 'touchmove'
        }
          , b = function() {
            var t = -1;
            if ('Microsoft Internet Explorer' == navigator.appName) {
                var e = navigator.userAgent;
                null != new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})').exec(e) && (t = parseFloat(RegExp.$1))
            }
            return t
        }()
          , _ = b > -1 && b < 9
          , M = function(t, e) {
            if (null == t)
                return [0, 0];
            var n = P(t)
              , i = S(n, 0);
            return [i[e + 'X'], i[e + 'Y']]
        }
          , w = function(t) {
            return null == t ? [0, 0] : _ ? [t.clientX + document.documentElement.scrollLeft, t.clientY + document.documentElement.scrollTop] : M(t, 'page')
        }
          , S = function(t, e) {
            return t.item ? t.item(e) : t[e]
        }
          , P = function(t) {
            return t.touches && t.touches.length > 0 ? t.touches : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches : t.targetTouches && t.targetTouches.length > 0 ? t.targetTouches : [t]
        }
          , C = function(t) {
            return P(t).length
        }
          , A = function(t, e, n, i) {
            if (c(t, e, n),
            i.__tauid = n.__tauid,
            t.addEventListener)
                t.addEventListener(e, n, !1);
            else if (t.attachEvent) {
                var r = e + n.__tauid;
                t['e' + r] = n,
                t[r] = function() {
                    t['e' + r] && t['e' + r](window.event)
                }
                ,
                t.attachEvent('on' + e, t[r])
            }
        }
          , E = function(t, e, n) {
            null != n && T(t, (function() {
                var i = r(this);
                if (function(t, e, n) {
                    if (t.__ta && t.__ta[e] && delete t.__ta[e][n.__tauid],
                    n.__taExtra) {
                        for (var i = 0; i < n.__taExtra.length; i++)
                            E(t, n.__taExtra[i][0], n.__taExtra[i][1]);
                        n.__taExtra.length = 0
                    }
                    n.__taUnstore && n.__taUnstore()
                }(i, e, n),
                null != n.__tauid)
                    if (i.removeEventListener)
                        i.removeEventListener(e, n, !1),
                        v && x[e] && i.removeEventListener(x[e], n, !1);
                    else if (this.detachEvent) {
                        var o = e + n.__tauid;
                        i[o] && i.detachEvent('on' + e, i[o]),
                        i[o] = null,
                        i['e' + o] = null
                    }
                n.__taTouchProxy && E(t, n.__taTouchProxy[1], n.__taTouchProxy[0])
            }
            ))
        }
          , T = function(t, e) {
            if (null != t) {
                t = 'undefined' != typeof Window && 'unknown' != typeof t.top && t == t.top ? [t] : 'string' != typeof t && null == t.tagName && null != t.length ? t : 'string' == typeof t ? document.querySelectorAll(t) : [t];
                for (var n = 0; n < t.length; n++)
                    e.apply(t[n])
            }
        }
          , L = function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (function(t) {
                var e = 16 * Math.random() | 0;
                return ('x' == t ? e : 3 & e | 8).toString(16)
            }
            ))
        };
        this.Mottle = function(t) {
            var e = (t = t || {}).clickThreshold || 250
              , i = t.dblClickThreshold || 450
              , a = new g
              , l = new f(e,i)
              , c = t.smartClicks
              , h = function(t, e, n, i) {
                null != n && T(t, (function() {
                    var t = r(this);
                    c && 'click' === e ? function(t, e, n, i) {
                        if (null == t.__taSmartClicks) {
                            p(t, 'mousedown', (function(e) {
                                t.__tad = w(e)
                            }
                            ), i),
                            p(t, 'mouseup', (function(e) {
                                t.__tau = w(e)
                            }
                            ), i),
                            p(t, 'click', (function(e) {
                                if (t.__tad && t.__tau && t.__tad[0] === t.__tau[0] && t.__tad[1] === t.__tau[1])
                                    for (var n = 0; n < t.__taSmartClicks.length; n++)
                                        t.__taSmartClicks[n].apply(o(e), [e])
                            }
                            ), i),
                            t.__taSmartClicks = []
                        }
                        t.__taSmartClicks.push(n),
                        n.__taUnstore = function() {
                            s(t.__taSmartClicks, n)
                        }
                    }(t, 0, n, i) : 'tap' === e || 'dbltap' === e || 'contextmenu' === e ? l(t, e, n, i) : 'mouseenter' === e || 'mouseexit' == e ? a(t, e, n, i) : p(t, e, n, i)
                }
                ))
            };
            this.remove = function(t) {
                return T(t, (function() {
                    var t = r(this);
                    if (t.__ta)
                        for (var e in t.__ta)
                            if (t.__ta.hasOwnProperty(e))
                                for (var n in t.__ta[e])
                                    t.__ta[e].hasOwnProperty(n) && E(t, e, t.__ta[e][n]);
                    t.parentNode && t.parentNode.removeChild(t)
                }
                )),
                this
            }
            ,
            this.on = function(t, e, n, i) {
                var r = arguments[0]
                  , o = 4 == arguments.length ? arguments[2] : null
                  , a = arguments[1]
                  , s = arguments[arguments.length - 1];
                return h(r, a, s, o),
                this
            }
            ,
            this.off = function(t, e, n) {
                return E(t, e, n),
                this
            }
            ,
            this.trigger = function(t, e, i, o) {
                var a = y && ('undefined' == typeof MouseEvent || null == i || i.constructor === MouseEvent)
                  , s = v && !y && x[e] ? x[e] : e
                  , l = !(v && !y && x[e])
                  , c = w(i)
                  , h = M(i, 'screen')
                  , u = function(t) {
                    return M(t, 'client')
                }(i);
                return T(t, (function() {
                    var t, p = r(this);
                    i = i || {
                        screenX: h[0],
                        screenY: h[1],
                        clientX: u[0],
                        clientY: u[1]
                    };
                    var d = function(t) {
                        o && (t.payload = o)
                    }
                      , f = {
                        TouchEvent: function(t) {
                            var e = n(window, p, 0, c[0], c[1], h[0], h[1], u[0], u[1]);
                            (t.initTouchEvent || t.initEvent)(s, !0, !0, window, null, h[0], h[1], u[0], u[1], !1, !1, !1, !1, e, e, e, 1, 0)
                        },
                        MouseEvents: function(t) {
                            t.initMouseEvent(s, !0, !0, window, 0, h[0], h[1], u[0], u[1], !1, !1, !1, !1, 1, p)
                        }
                    };
                    if (document.createEvent) {
                        var m = !l && !a && v && x[e] ? 'TouchEvent' : 'MouseEvents';
                        t = document.createEvent(m),
                        f[m](t),
                        d(t),
                        p.dispatchEvent(t)
                    } else
                        document.createEventObject && ((t = document.createEventObject()).eventType = t.eventName = s,
                        t.screenX = h[0],
                        t.screenY = h[1],
                        t.clientX = u[0],
                        t.clientY = u[1],
                        d(t),
                        p.fireEvent('on' + s, t))
                }
                )),
                this
            }
        }
        ,
        this.Mottle.consume = function(t, e) {
            t.stopPropagation ? t.stopPropagation() : t.returnValue = !1,
            !e && t.preventDefault && t.preventDefault()
        }
        ,
        this.Mottle.pageLocation = w,
        this.Mottle.setForceTouchEvents = function(t) {
            v = t
        }
        ,
        this.Mottle.setForceMouseEvents = function(t) {
            y = t
        }
        ,
        this.Mottle.version = '0.8.0',
        e.Mottle = this.Mottle
    }
    .call('undefined' == typeof window ? this : window),
    function() {
        'use strict';
        var t = function(t, e, n) {
            return -1 === t.indexOf(e) && (n ? t.unshift(e) : t.push(e),
            !0)
        }
          , n = function(t, e) {
            var n = t.indexOf(e);
            -1 !== n && t.splice(n, 1)
        }
          , i = function(t, e) {
            for (var n = [], i = 0; i < t.length; i++)
                -1 === e.indexOf(t[i]) && n.push(t[i]);
            return n
        }
          , r = function(t) {
            return null != t && ('string' == typeof t || t.constructor === String)
        }
          , o = function(t) {
            var e = t.getBoundingClientRect()
              , n = document.body
              , i = document.documentElement
              , r = window.pageYOffset || i.scrollTop || n.scrollTop
              , o = window.pageXOffset || i.scrollLeft || n.scrollLeft
              , a = i.clientTop || n.clientTop || 0
              , s = i.clientLeft || n.clientLeft || 0
              , l = e.top + r - a
              , c = e.left + o - s;
            return {
                top: Math.round(l),
                left: Math.round(c)
            }
        }
          , a = function(t, e, n) {
            for (var i = (n = n || t.parentNode).querySelectorAll(e), r = 0; r < i.length; r++)
                if (i[r] === t)
                    return !0;
            return !1
        }
          , s = function(t, e, n) {
            if (a(e, n, t))
                return e;
            for (var i = e.parentNode; null != i && i !== t; ) {
                if (a(i, n, t))
                    return i;
                i = i.parentNode
            }
        }
          , l = function(t, e, n) {
            for (var i = null, r = e.getAttribute('katavorio-draggable'), o = null != r ? '[katavorio-draggable=\'' + r + '\'] ' : '', l = 0; l < t.length; l++)
                if (null != (i = s(e, n, o + t[l].selector))) {
                    if (t[l].filter) {
                        var c = a(n, t[l].filter, i);
                        if (!0 === t[l].filterExclude && !c || c)
                            return null
                    }
                    return [t[l], i]
                }
            return null
        }
          , c = function() {
            var t = -1;
            if ('Microsoft Internet Explorer' === navigator.appName) {
                var e = navigator.userAgent;
                null != new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})').exec(e) && (t = parseFloat(RegExp.$1))
            }
            return t
        }()
          , h = c > -1 && c < 9
          , u = 9 === c
          , p = function(t) {
            if (h)
                return [t.clientX + document.documentElement.scrollLeft, t.clientY + document.documentElement.scrollTop];
            var e = f(t)
              , n = d(e, 0);
            return u ? [n.pageX || n.clientX, n.pageY || n.clientY] : [n.pageX, n.pageY]
        }
          , d = function(t, e) {
            return t.item ? t.item(e) : t[e]
        }
          , f = function(t) {
            return t.touches && t.touches.length > 0 ? t.touches : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches : t.targetTouches && t.targetTouches.length > 0 ? t.targetTouches : [t]
        }
          , m = {
            delegatedDraggable: 'katavorio-delegated-draggable',
            draggable: 'katavorio-draggable',
            droppable: 'katavorio-droppable',
            drag: 'katavorio-drag',
            selected: 'katavorio-drag-selected',
            active: 'katavorio-drag-active',
            hover: 'katavorio-drag-hover',
            noSelect: 'katavorio-drag-no-select',
            ghostProxy: 'katavorio-ghost-proxy',
            clonedDrag: 'katavorio-clone-drag'
        }
          , g = ['stop', 'start', 'drag', 'drop', 'over', 'out', 'beforeStart']
          , v = function() {}
          , y = function() {
            return !0
        }
          , x = function(t, e, n) {
            for (var i = 0; i < t.length; i++)
                t[i] != n && e(t[i])
        }
          , b = function(t, e, n, i) {
            x(t, (function(t) {
                t.setActive(e),
                e && t.updatePosition(),
                n && t.setHover(i, e)
            }
            ))
        }
          , _ = function(t, e) {
            if (null != t) {
                t = r(t) || null != t.tagName || null == t.length ? [t] : t;
                for (var n = 0; n < t.length; n++)
                    e.apply(t[n], [t[n]])
            }
        }
          , M = function(t) {
            t.stopPropagation ? (t.stopPropagation(),
            t.preventDefault()) : t.returnValue = !1
        }
          , w = function(t, e, n) {
            var i = t.srcElement || t.target;
            return !a(i, n.getInputFilterSelector(), e)
        }
          , S = function(t, e, n, i) {
            this.params = e || {},
            this.el = t,
            this.params.addClass(this.el, this._class),
            this.uuid = T();
            var r = !0;
            return this.setEnabled = function(t) {
                r = t
            }
            ,
            this.isEnabled = function() {
                return r
            }
            ,
            this.toggleEnabled = function() {
                r = !r
            }
            ,
            this.setScope = function(t) {
                this.scopes = t ? t.split(/\s+/) : [i]
            }
            ,
            this.addScope = function(t) {
                var e = {};
                for (var n in _(this.scopes, (function(t) {
                    e[t] = !0
                }
                )),
                _(t ? t.split(/\s+/) : [], (function(t) {
                    e[t] = !0
                }
                )),
                this.scopes = [],
                e)
                    this.scopes.push(n)
            }
            ,
            this.removeScope = function(t) {
                var e = {};
                for (var n in _(this.scopes, (function(t) {
                    e[t] = !0
                }
                )),
                _(t ? t.split(/\s+/) : [], (function(t) {
                    delete e[t]
                }
                )),
                this.scopes = [],
                e)
                    this.scopes.push(n)
            }
            ,
            this.toggleScope = function(t) {
                var e = {};
                for (var n in _(this.scopes, (function(t) {
                    e[t] = !0
                }
                )),
                _(t ? t.split(/\s+/) : [], (function(t) {
                    e[t] ? delete e[t] : e[t] = !0
                }
                )),
                this.scopes = [],
                e)
                    this.scopes.push(n)
            }
            ,
            this.setScope(e.scope),
            this.k = e.katavorio,
            e.katavorio
        }
          , P = function() {
            return !0
        }
          , C = function() {
            return !1
        }
          , A = function(t, e, n, i) {
            this._class = n.draggable;
            var s = S.apply(this, arguments);
            this.rightButtonCanDrag = this.params.rightButtonCanDrag;
            var c, h, u, d, f, g, v = [0, 0], x = null, _ = null, A = [0, 0], E = !1, D = [0, 0], I = !1 !== this.params.consumeStartEvent, O = this.el, j = this.params.clone, N = (this.params.scroll,
            !1 !== e.multipleDrop), k = !1, F = null, z = [], R = null, U = e.ghostProxyParent;
            if (c = !0 === e.ghostProxy ? P : e.ghostProxy && 'function' == typeof e.ghostProxy ? e.ghostProxy : function(t, e) {
                return !(!R || !R.useGhostProxy) && R.useGhostProxy(t, e)
            }
            ,
            h = e.makeGhostProxy ? e.makeGhostProxy : function(t) {
                return R && R.makeGhostProxy ? R.makeGhostProxy(t) : t.cloneNode(!0)
            }
            ,
            e.selector) {
                var B = t.getAttribute('katavorio-draggable');
                null == B && (B = '' + (new Date).getTime(),
                t.setAttribute('katavorio-draggable', B)),
                z.push(e)
            }
            var V, G = e.snapThreshold, H = function(t, e, n, i, r) {
                var o = e * Math.floor(t[0] / e)
                  , a = o + e
                  , s = Math.abs(t[0] - o) <= i ? o : Math.abs(a - t[0]) <= i ? a : t[0]
                  , l = n * Math.floor(t[1] / n)
                  , c = l + n;
                return [s, Math.abs(t[1] - l) <= r ? l : Math.abs(c - t[1]) <= r ? c : t[1]]
            };
            this.posses = [],
            this.posseRoles = {},
            this.toGrid = function(t) {
                if (null == this.params.grid)
                    return t;
                var e = this.params.grid ? this.params.grid[0] / 2 : G || 5
                  , n = this.params.grid ? this.params.grid[1] / 2 : G || 5;
                return H(t, this.params.grid[0], this.params.grid[1], e, n)
            }
            ,
            this.snap = function(t, e) {
                if (null != O) {
                    t = t || (this.params.grid ? this.params.grid[0] : 10),
                    e = e || (this.params.grid ? this.params.grid[1] : 10);
                    var n = this.params.getPosition(O)
                      , i = this.params.grid ? this.params.grid[0] / 2 : G
                      , r = this.params.grid ? this.params.grid[1] / 2 : G
                      , o = H(n, t, e, i, r);
                    return this.params.setPosition(O, o),
                    o
                }
            }
            ,
            this.setUseGhostProxy = function(t) {
                c = t ? P : C
            }
            ;
            var W, X = function(t) {
                return !1 === e.allowNegative ? [Math.max(0, t[0]), Math.max(0, t[1])] : t
            }, q = function(t) {
                V = 'function' == typeof t ? t : t ? function(t, e, n, i) {
                    return X([Math.max(0, Math.min(n.w - i[0], t[0])), Math.max(0, Math.min(n.h - i[1], t[1]))])
                }
                .bind(this) : function(t) {
                    return X(t)
                }
            }
            .bind(this);
            q('function' == typeof this.params.constrain ? this.params.constrain : this.params.constrain || this.params.containment),
            this.setConstrain = function(t) {
                q(t)
            }
            ,
            this.setRevert = function(t) {
                W = t
            }
            ,
            this.params.revert && (W = this.params.revert);
            var Y = function(t) {
                return 'function' == typeof t ? (t._katavorioId = T(),
                t._katavorioId) : t
            }
              , J = {}
              , Z = function(t) {
                for (var e in J) {
                    var n = J[e]
                      , i = n[0](t);
                    if (n[1] && (i = !i),
                    !i)
                        return !1
                }
                return !0
            }
              , K = this.setFilter = function(e, n) {
                if (e) {
                    var i = Y(e);
                    J[i] = [function(n) {
                        var i, o = n.srcElement || n.target;
                        return r(e) ? i = a(o, e, t) : 'function' == typeof e && (i = e(n, t)),
                        i
                    }
                    , !1 !== n]
                }
            }
            ;
            this.addFilter = K,
            this.removeFilter = function(t) {
                var e = 'function' == typeof t ? t._katavorioId : t;
                delete J[e]
            }
            ;
            this.clearAllFilters = function() {
                J = {}
            }
            ,
            this.canDrag = this.params.canDrag || y;
            var Q, $ = [], tt = [];
            this.addSelector = function(t) {
                t.selector && z.push(t)
            }
            ,
            this.downListener = function(t) {
                if (!t.defaultPrevented && ((this.rightButtonCanDrag || 3 !== t.which && 2 !== t.button) && this.isEnabled() && this.canDrag()))
                    if (Z(t) && w(t, this.el, this.k)) {
                        if (R = null,
                        F = null,
                        z.length > 0) {
                            var e = l(z, this.el, t.target || t.srcElement);
                            if (null != e && (R = e[0],
                            F = e[1]),
                            null == F)
                                return
                        } else
                            F = this.el;
                        if (j)
                            if (O = F.cloneNode(!0),
                            this.params.addClass(O, m.clonedDrag),
                            O.setAttribute('id', null),
                            O.style.position = 'absolute',
                            null != this.params.parent) {
                                var i = this.params.getPosition(this.el);
                                O.style.left = i[0] + 'px',
                                O.style.top = i[1] + 'px',
                                this.params.parent.appendChild(O)
                            } else {
                                var r = o(F);
                                O.style.left = r.left + 'px',
                                O.style.top = r.top + 'px',
                                document.body.appendChild(O)
                            }
                        else
                            O = F;
                        I && M(t),
                        v = p(t),
                        O && O.parentNode && (D = [O.parentNode.scrollLeft, O.parentNode.scrollTop]),
                        this.params.bind(document, 'mousemove', this.moveListener),
                        this.params.bind(document, 'mouseup', this.upListener),
                        s.markSelection(this),
                        s.markPosses(this),
                        this.params.addClass(document.body, n.noSelect),
                        it('beforeStart', {
                            el: this.el,
                            pos: x,
                            e: t,
                            drag: this
                        })
                    } else
                        this.params.consumeFilteredEvents && M(t)
            }
            .bind(this),
            this.moveListener = function(t) {
                if (v) {
                    if (!E)
                        if (!1 !== it('start', {
                            el: this.el,
                            pos: x,
                            e: t,
                            drag: this
                        })) {
                            if (!v)
                                return;
                            this.mark(!0),
                            E = !0
                        } else
                            this.abort();
                    if (v) {
                        tt.length = 0;
                        var e = p(t)
                          , n = e[0] - v[0]
                          , i = e[1] - v[1]
                          , r = this.params.ignoreZoom ? 1 : s.getZoom();
                        O && O.parentNode && (n += O.parentNode.scrollLeft - D[0],
                        i += O.parentNode.scrollTop - D[1]),
                        n /= r,
                        i /= r,
                        this.moveBy(n, i, t),
                        s.updateSelection(n, i, this),
                        s.updatePosses(n, i, this)
                    }
                }
            }
            .bind(this),
            this.upListener = function(t) {
                v && (v = null,
                this.params.unbind(document, 'mousemove', this.moveListener),
                this.params.unbind(document, 'mouseup', this.upListener),
                this.params.removeClass(document.body, n.noSelect),
                this.unmark(t),
                s.unmarkSelection(this, t),
                s.unmarkPosses(this, t),
                this.stop(t),
                s.notifyPosseDragStop(this, t),
                E = !1,
                tt.length = 0,
                j ? (O && O.parentNode && O.parentNode.removeChild(O),
                O = null) : W && !0 === W(O, this.params.getPosition(O)) && (this.params.setPosition(O, x),
                it('revert', O)))
            }
            .bind(this),
            this.getFilters = function() {
                return J
            }
            ,
            this.abort = function() {
                null != v && this.upListener()
            }
            ,
            this.getDragElement = function(t) {
                return t ? F || this.el : O || this.el
            }
            ;
            var et = {
                start: [],
                drag: [],
                stop: [],
                over: [],
                out: [],
                beforeStart: [],
                revert: []
            };
            e.events.start && et.start.push(e.events.start),
            e.events.beforeStart && et.beforeStart.push(e.events.beforeStart),
            e.events.stop && et.stop.push(e.events.stop),
            e.events.drag && et.drag.push(e.events.drag),
            e.events.revert && et.revert.push(e.events.revert),
            this.on = function(t, e) {
                et[t] && et[t].push(e)
            }
            ,
            this.off = function(t, e) {
                if (et[t]) {
                    for (var n = [], i = 0; i < et[t].length; i++)
                        et[t][i] !== e && n.push(et[t][i]);
                    et[t] = n
                }
            }
            ;
            var nt, it = function(t, e) {
                var n = null;
                if (R && R[t])
                    n = R[t](e);
                else if (et[t])
                    for (var i = 0; i < et[t].length; i++)
                        try {
                            var r = et[t][i](e);
                            null != r && (n = r)
                        } catch (t) {}
                return n
            };
            this.notifyStart = function(t) {
                it('start', {
                    el: this.el,
                    pos: this.params.getPosition(O),
                    e: t,
                    drag: this
                })
            }
            ,
            this.stop = function(t, e) {
                if (e || E) {
                    var n = []
                      , i = s.getSelection()
                      , r = this.params.getPosition(O);
                    if (i.length > 0)
                        for (var o = 0; o < i.length; o++) {
                            var a = this.params.getPosition(i[o].el);
                            n.push([i[o].el, {
                                left: a[0],
                                top: a[1]
                            }, i[o]])
                        }
                    else
                        n.push([O, {
                            left: r[0],
                            top: r[1]
                        }, this]);
                    it('stop', {
                        el: O,
                        pos: nt || r,
                        finalPos: r,
                        e: t,
                        drag: this,
                        selection: n
                    })
                }
            }
            ,
            this.mark = function(t) {
                var e;
                x = this.params.getPosition(O),
                _ = this.params.getPosition(O, !0),
                A = [_[0] - x[0], _[1] - x[1]],
                this.size = this.params.getSize(O),
                $ = s.getMatchingDroppables(this),
                b($, !0, !1, this),
                this.params.addClass(O, this.params.dragClass || n.drag),
                e = this.params.getConstrainingRectangle ? this.params.getConstrainingRectangle(O) : this.params.getSize(O.parentNode),
                Q = {
                    w: e[0],
                    h: e[1]
                },
                f = 0,
                g = 0,
                t && s.notifySelectionDragStart(this)
            }
            ,
            this.unmark = function(t, i) {
                if (b($, !1, !0, this),
                k && c(F, O) ? (nt = [O.offsetLeft - f, O.offsetTop - g],
                O.parentNode.removeChild(O),
                O = F) : nt = null,
                this.params.removeClass(O, this.params.dragClass || n.drag),
                $.length = 0,
                k = !1,
                !i) {
                    tt.length > 0 && nt && e.setPosition(F, nt),
                    tt.sort(L);
                    for (var r = 0; r < tt.length; r++) {
                        if (!0 === tt[r].drop(this, t))
                            break
                    }
                }
            }
            ,
            this.moveBy = function(t, n, i) {
                tt.length = 0;
                var r = this.toGrid([x[0] + t, x[1] + n])
                  , o = V(r, O, Q, this.size);
                if (c(this.el, O))
                    if (r[0] !== o[0] || r[1] !== o[1]) {
                        if (!k) {
                            var a = h(F);
                            e.addClass(a, m.ghostProxy),
                            U ? (U.appendChild(a),
                            u = e.getPosition(F.parentNode, !0),
                            d = e.getPosition(e.ghostProxyParent, !0),
                            f = u[0] - d[0],
                            g = u[1] - d[1]) : F.parentNode.appendChild(a),
                            O = a,
                            k = !0
                        }
                        o = r
                    } else
                        k && (O.parentNode.removeChild(O),
                        O = F,
                        k = !1,
                        u = null,
                        d = null,
                        f = 0,
                        g = 0);
                var s = {
                    x: o[0],
                    y: o[1],
                    w: this.size[0],
                    h: this.size[1]
                }
                  , l = {
                    x: s.x + A[0],
                    y: s.y + A[1],
                    w: s.w,
                    h: s.h
                }
                  , p = null;
                this.params.setPosition(O, [o[0] + f, o[1] + g]);
                for (var v = 0; v < $.length; v++) {
                    var y = {
                        x: $[v].pagePosition[0],
                        y: $[v].pagePosition[1],
                        w: $[v].size[0],
                        h: $[v].size[1]
                    };
                    this.params.intersects(l, y) && (N || null == p || p === $[v].el) && $[v].canDrop(this) ? (p || (p = $[v].el),
                    tt.push($[v]),
                    $[v].setHover(this, !0, i)) : $[v].isHover() && $[v].setHover(this, !1, i)
                }
                it('drag', {
                    el: this.el,
                    pos: o,
                    e: i,
                    drag: this
                })
            }
            ,
            this.destroy = function() {
                this.params.unbind(this.el, 'mousedown', this.downListener),
                this.params.unbind(document, 'mousemove', this.moveListener),
                this.params.unbind(document, 'mouseup', this.upListener),
                this.downListener = null,
                this.upListener = null,
                this.moveListener = null
            }
            ,
            this.params.bind(this.el, 'mousedown', this.downListener),
            this.params.handle ? K(this.params.handle, !1) : K(this.params.filter, this.params.filterExclude)
        }
          , E = function(t, e, n, i) {
            this._class = n.droppable,
            this.params = e || {},
            this.rank = e.rank || 0,
            this._activeClass = this.params.activeClass || n.active,
            this._hoverClass = this.params.hoverClass || n.hover,
            S.apply(this, arguments);
            var r = !1;
            this.allowLoopback = !1 !== this.params.allowLoopback,
            this.setActive = function(t) {
                this.params[t ? 'addClass' : 'removeClass'](this.el, this._activeClass)
            }
            ,
            this.updatePosition = function() {
                this.position = this.params.getPosition(this.el),
                this.pagePosition = this.params.getPosition(this.el, !0),
                this.size = this.params.getSize(this.el)
            }
            ,
            this.canDrop = this.params.canDrop || function(t) {
                return !0
            }
            ,
            this.isHover = function() {
                return r
            }
            ,
            this.setHover = function(t, e, n) {
                (e || null == this.el._katavorioDragHover || this.el._katavorioDragHover === t.el._katavorio) && (this.params[e ? 'addClass' : 'removeClass'](this.el, this._hoverClass),
                this.el._katavorioDragHover = e ? t.el._katavorio : null,
                r !== e && this.params.events[e ? 'over' : 'out']({
                    el: this.el,
                    e: n,
                    drag: t,
                    drop: this
                }),
                r = e)
            }
            ,
            this.drop = function(t, e) {
                return this.params.events.drop({
                    drag: t,
                    e: e,
                    drop: this
                })
            }
            ,
            this.destroy = function() {
                this._class = null,
                this._activeClass = null,
                this._hoverClass = null,
                r = null
            }
        }
          , T = function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (function(t) {
                var e = 16 * Math.random() | 0;
                return ('x' === t ? e : 3 & e | 8).toString(16)
            }
            ))
        }
          , L = function(t, e) {
            return t.rank < e.rank ? 1 : t.rank > e.rank ? -1 : 0
        }
          , D = function(t) {
            return null == t ? null : null == (t = 'string' == typeof t || t.constructor === String ? document.getElementById(t) : t) ? null : (t._katavorio = t._katavorio || T(),
            t)
        };
        this.Katavorio = function(e) {
            var o = []
              , a = {};
            this._dragsByScope = {},
            this._dropsByScope = {};
            var s = 1
              , l = function(t, e) {
                _(t, (function(t) {
                    for (var n = 0; n < t.scopes.length; n++)
                        e[t.scopes[n]] = e[t.scopes[n]] || [],
                        e[t.scopes[n]].push(t)
                }
                ))
            }
              , c = function(t, n) {
                var i = 0;
                return _(t, (function(t) {
                    for (var r = 0; r < t.scopes.length; r++)
                        if (n[t.scopes[r]]) {
                            var o = e.indexOf(n[t.scopes[r]], t);
                            -1 !== o && (n[t.scopes[r]].splice(o, 1),
                            i++)
                        }
                }
                )),
                i > 0
            }
              , h = (this.getMatchingDroppables = function(t) {
                for (var e = [], n = {}, i = 0; i < t.scopes.length; i++) {
                    var r = this._dropsByScope[t.scopes[i]];
                    if (r)
                        for (var o = 0; o < r.length; o++)
                            !r[o].canDrop(t) || n[r[o].uuid] || !r[o].allowLoopback && r[o].el === t.el || (n[r[o].uuid] = !0,
                            e.push(r[o]))
                }
                return e.sort(L),
                e
            }
            ,
            function(t) {
                t = t || {};
                var n, i = {
                    events: {}
                };
                for (n in e)
                    i[n] = e[n];
                for (n in t)
                    i[n] = t[n];
                for (n = 0; n < g.length; n++)
                    i.events[g[n]] = t[g[n]] || v;
                return i.katavorio = this,
                i
            }
            .bind(this))
              , u = function(t, e) {
                for (var n = 0; n < g.length; n++)
                    e[g[n]] && t.on(g[n], e[g[n]])
            }
            .bind(this)
              , p = {}
              , d = e.css || {}
              , f = e.scope || 'katavorio-drag-scope';
            for (var y in m)
                p[y] = m[y];
            for (var y in d)
                p[y] = d[y];
            var b = e.inputFilterSelector || 'input,textarea,select,button,option';
            this.getInputFilterSelector = function() {
                return b
            }
            ,
            this.setInputFilterSelector = function(t) {
                return b = t,
                this
            }
            ,
            this.draggable = function(t, n) {
                var i = [];
                return _(t, function(t) {
                    if (null != (t = D(t)))
                        if (null == t._katavorioDrag) {
                            var r = h(n);
                            t._katavorioDrag = new A(t,r,p,f),
                            l(t._katavorioDrag, this._dragsByScope),
                            i.push(t._katavorioDrag),
                            e.addClass(t, r.selector ? p.delegatedDraggable : p.draggable)
                        } else
                            u(t._katavorioDrag, n)
                }
                .bind(this)),
                i
            }
            ,
            this.droppable = function(t, n) {
                var i = [];
                return _(t, function(t) {
                    if (null != (t = D(t))) {
                        var r = new E(t,h(n),p,f);
                        t._katavorioDrop = t._katavorioDrop || [],
                        t._katavorioDrop.push(r),
                        l(r, this._dropsByScope),
                        i.push(r),
                        e.addClass(t, p.droppable)
                    }
                }
                .bind(this)),
                i
            }
            ,
            this.select = function(t) {
                return _(t, (function() {
                    var t = D(this);
                    t && t._katavorioDrag && (a[t._katavorio] || (o.push(t._katavorioDrag),
                    a[t._katavorio] = [t, o.length - 1],
                    e.addClass(t, p.selected)))
                }
                )),
                this
            }
            ,
            this.deselect = function(t) {
                return _(t, (function() {
                    var t = D(this);
                    if (t && t._katavorio && a[t._katavorio]) {
                        for (var n = [], i = 0; i < o.length; i++)
                            o[i].el !== t && n.push(o[i]);
                        o = n,
                        delete a[t._katavorio],
                        e.removeClass(t, p.selected)
                    }
                }
                )),
                this
            }
            ,
            this.deselectAll = function() {
                for (var t in a) {
                    var n = a[t];
                    e.removeClass(n[0], p.selected)
                }
                o.length = 0,
                a = {}
            }
            ,
            this.markSelection = function(t) {
                x(o, (function(t) {
                    t.mark()
                }
                ), t)
            }
            ,
            this.markPosses = function(t) {
                t.posses && _(t.posses, (function(e) {
                    t.posseRoles[e] && C[e] && x(C[e].members, (function(t) {
                        t.mark()
                    }
                    ), t)
                }
                ))
            }
            ,
            this.unmarkSelection = function(t, e) {
                x(o, (function(t) {
                    t.unmark(e)
                }
                ), t)
            }
            ,
            this.unmarkPosses = function(t, e) {
                t.posses && _(t.posses, (function(n) {
                    t.posseRoles[n] && C[n] && x(C[n].members, (function(t) {
                        t.unmark(e, !0)
                    }
                    ), t)
                }
                ))
            }
            ,
            this.getSelection = function() {
                return o.slice(0)
            }
            ,
            this.updateSelection = function(t, e, n) {
                x(o, (function(n) {
                    n.moveBy(t, e)
                }
                ), n)
            }
            ;
            var M = function(t, e) {
                e.posses && _(e.posses, (function(n) {
                    e.posseRoles[n] && C[n] && x(C[n].members, (function(e) {
                        t(e)
                    }
                    ), e)
                }
                ))
            };
            this.updatePosses = function(t, e, n) {
                M((function(n) {
                    n.moveBy(t, e)
                }
                ), n)
            }
            ,
            this.notifyPosseDragStop = function(t, e) {
                M((function(t) {
                    t.stop(e, !0)
                }
                ), t)
            }
            ,
            this.notifySelectionDragStop = function(t, e) {
                x(o, (function(t) {
                    t.stop(e, !0)
                }
                ), t)
            }
            ,
            this.notifySelectionDragStart = function(t, e) {
                x(o, (function(t) {
                    t.notifyStart(e)
                }
                ), t)
            }
            ,
            this.setZoom = function(t) {
                s = t
            }
            ,
            this.getZoom = function() {
                return s
            }
            ;
            var w = function(t, e, n, i) {
                _(t, (function(t) {
                    c(t, n),
                    t[i](e),
                    l(t, n)
                }
                ))
            };
            _(['set', 'add', 'remove', 'toggle'], function(t) {
                this[t + 'Scope'] = function(e, n) {
                    w(e._katavorioDrag, n, this._dragsByScope, t + 'Scope'),
                    w(e._katavorioDrop, n, this._dropsByScope, t + 'Scope')
                }
                .bind(this),
                this[t + 'DragScope'] = function(e, n) {
                    w(e.constructor === A ? e : e._katavorioDrag, n, this._dragsByScope, t + 'Scope')
                }
                .bind(this),
                this[t + 'DropScope'] = function(e, n) {
                    w(e.constructor === E ? e : e._katavorioDrop, n, this._dropsByScope, t + 'Scope')
                }
                .bind(this)
            }
            .bind(this)),
            this.snapToGrid = function(t, e) {
                for (var n in this._dragsByScope)
                    x(this._dragsByScope[n], (function(n) {
                        n.snap(t, e)
                    }
                    ))
            }
            ,
            this.getDragsForScope = function(t) {
                return this._dragsByScope[t]
            }
            ,
            this.getDropsForScope = function(t) {
                return this._dropsByScope[t]
            }
            ;
            var S = function(t, e, n) {
                if ((t = D(t))[e]) {
                    var i = o.indexOf(t[e]);
                    i >= 0 && o.splice(i, 1),
                    c(t[e], n) && _(t[e], (function(t) {
                        t.destroy()
                    }
                    )),
                    delete t[e]
                }
            }
              , P = function(t, e, n, i) {
                (t = D(t))[e] && t[e].off(n, i)
            };
            this.elementRemoved = function(t) {
                this.destroyDraggable(t),
                this.destroyDroppable(t)
            }
            ,
            this.destroyDraggable = function(t, e, n) {
                1 === arguments.length ? S(t, '_katavorioDrag', this._dragsByScope) : P(t, '_katavorioDrag', e, n)
            }
            ,
            this.destroyDroppable = function(t, e, n) {
                1 === arguments.length ? S(t, '_katavorioDrop', this._dropsByScope) : P(t, '_katavorioDrop', e, n)
            }
            ,
            this.reset = function() {
                this._dragsByScope = {},
                this._dropsByScope = {},
                o = [],
                a = {},
                C = {}
            }
            ;
            var C = {}
              , T = function(e, n, i) {
                var o, a = r(n) ? n : n.id, s = !!r(n) || !1 !== n.active, l = C[a] || (o = {
                    name: a,
                    members: []
                },
                C[a] = o,
                o);
                return _(e, (function(e) {
                    if (e._katavorioDrag) {
                        if (i && null != e._katavorioDrag.posseRoles[l.name])
                            return;
                        t(l.members, e._katavorioDrag),
                        t(e._katavorioDrag.posses, l.name),
                        e._katavorioDrag.posseRoles[l.name] = s
                    }
                }
                )),
                l
            };
            this.addToPosse = function(t, e) {
                for (var n = [], i = 1; i < arguments.length; i++)
                    n.push(T(t, arguments[i]));
                return 1 === n.length ? n[0] : n
            }
            ,
            this.setPosse = function(t, e) {
                for (var n = [], r = 1; r < arguments.length; r++)
                    n.push(T(t, arguments[r], !0).name);
                return _(t, function(t) {
                    if (t._katavorioDrag) {
                        var e = i(t._katavorioDrag.posses, n);
                        Array.prototype.push.apply([], t._katavorioDrag.posses);
                        for (var r = 0; r < e.length; r++)
                            this.removeFromPosse(t, e[r])
                    }
                }
                .bind(this)),
                1 === n.length ? n[0] : n
            }
            ,
            this.removeFromPosse = function(t, e) {
                if (arguments.length < 2)
                    throw new TypeError('No posse id provided for remove operation');
                for (var i = 1; i < arguments.length; i++)
                    e = arguments[i],
                    _(t, (function(t) {
                        if (t._katavorioDrag && t._katavorioDrag.posses) {
                            var i = t._katavorioDrag;
                            _(e, (function(t) {
                                n(C[t].members, i),
                                n(i.posses, t),
                                delete i.posseRoles[t]
                            }
                            ))
                        }
                    }
                    ))
            }
            ,
            this.removeFromAllPosses = function(t) {
                _(t, (function(t) {
                    if (t._katavorioDrag && t._katavorioDrag.posses) {
                        var e = t._katavorioDrag;
                        _(e.posses, (function(t) {
                            n(C[t].members, e)
                        }
                        )),
                        e.posses.length = 0,
                        e.posseRoles = {}
                    }
                }
                ))
            }
            ,
            this.setPosseState = function(t, e, n) {
                var i = C[e];
                i && _(t, (function(t) {
                    t._katavorioDrag && t._katavorioDrag.posses && (t._katavorioDrag.posseRoles[i.name] = n)
                }
                ))
            }
        }
        ,
        this.Katavorio.version = '1.0.0',
        e.Katavorio = this.Katavorio
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        this.jsPlumbUtil = this.jsPlumbUtil || {};
        var t = this.jsPlumbUtil;
        function n(t) {
            return '[object Array]' === Object.prototype.toString.call(t)
        }
        function i(t) {
            return 'string' == typeof t
        }
        function r(t) {
            return 'boolean' == typeof t
        }
        function o(t) {
            return null != t && '[object Object]' === Object.prototype.toString.call(t)
        }
        function a(t) {
            return '[object Date]' === Object.prototype.toString.call(t)
        }
        function s(t) {
            return '[object Function]' === Object.prototype.toString.call(t)
        }
        function l(t) {
            if (i(t))
                return '' + t;
            if (r(t))
                return !!t;
            if (a(t))
                return new Date(t.getTime());
            if (s(t))
                return t;
            if (n(t)) {
                for (var e = [], c = 0; c < t.length; c++)
                    e.push(l(t[c]));
                return e
            }
            if (o(t)) {
                var h = {};
                for (var u in t)
                    h[u] = l(t[u]);
                return h
            }
            return t
        }
        function c(t, e, a, s) {
            var c, h, u = {}, p = {};
            for (a = a || [],
            s = s || [],
            h = 0; h < a.length; h++)
                u[a[h]] = !0;
            for (h = 0; h < s.length; h++)
                p[s[h]] = !0;
            var d = l(t);
            for (h in e)
                if (null == d[h] || p[h])
                    d[h] = e[h];
                else if (i(e[h]) || r(e[h]))
                    u[h] ? ((c = []).push.apply(c, n(d[h]) ? d[h] : [d[h]]),
                    c.push.apply(c, r(e[h]) ? e[h] : [e[h]]),
                    d[h] = c) : d[h] = e[h];
                else if (n(e[h]))
                    c = [],
                    n(d[h]) && c.push.apply(c, d[h]),
                    c.push.apply(c, e[h]),
                    d[h] = c;
                else if (o(e[h]))
                    for (var f in o(d[h]) || (d[h] = {}),
                    e[h])
                        d[h][f] = e[h][f];
            return d
        }
        function h(t, e) {
            if (t)
                for (var n = 0; n < t.length; n++)
                    if (e(t[n]))
                        return n;
            return -1
        }
        function u(t, e) {
            var n = t.indexOf(e);
            return n > -1 && t.splice(n, 1),
            -1 !== n
        }
        function p(t, e, n, i) {
            var r = t[e];
            return null == r && (r = [],
            t[e] = r),
            r[i ? 'unshift' : 'push'](n),
            r
        }
        function d() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (function(t) {
                var e = 16 * Math.random() | 0;
                return ('x' === t ? e : 3 & e | 8).toString(16)
            }
            ))
        }
        function f() {
            for (var e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            if (t.logEnabled && 'undefined' != typeof console)
                try {
                    arguments[arguments.length - 1]
                } catch (t) {}
        }
        e.jsPlumbUtil = t,
        t.isArray = n,
        t.isNumber = function(t) {
            return '[object Number]' === Object.prototype.toString.call(t)
        }
        ,
        t.isString = i,
        t.isBoolean = r,
        t.isNull = function(t) {
            return null == t
        }
        ,
        t.isObject = o,
        t.isDate = a,
        t.isFunction = s,
        t.isNamedFunction = function(t) {
            return s(t) && null != t.name && t.name.length > 0
        }
        ,
        t.isEmpty = function(t) {
            for (var e in t)
                if (t.hasOwnProperty(e))
                    return !1;
            return !0
        }
        ,
        t.clone = l,
        t.merge = c,
        t.replace = function(t, e, n) {
            if (null != t) {
                var i = t;
                return e.replace(/([^\.])+/g, (function(t, e, r, o) {
                    var a = t.match(/([^\[0-9]+){1}(\[)([0-9+])/)
                      , s = function() {
                        return i[a[1]] || (i[a[1]] = [],
                        i[a[1]])
                    };
                    if (r + t.length >= o.length)
                        a ? s()[a[3]] = n : i[t] = n;
                    else if (a) {
                        var l = s();
                        i = l[a[3]] || (l[a[3]] = {},
                        l[a[3]])
                    } else
                        i = i[t] || (i[t] = {},
                        i[t]);
                    return ''
                }
                )),
                t
            }
        }
        ,
        t.functionChain = function(t, e, n) {
            for (var i = 0; i < n.length; i++) {
                var r = n[i][0][n[i][1]].apply(n[i][0], n[i][2]);
                if (r === e)
                    return r
            }
            return t
        }
        ,
        t.populate = function(t, e, r, a) {
            var l = function(t) {
                if (null != t) {
                    if (i(t))
                        return function(t) {
                            var n = t.match(/(\${.*?})/g);
                            if (null != n)
                                for (var i = 0; i < n.length; i++) {
                                    var r = e[n[i].substring(2, n[i].length - 1)] || '';
                                    null != r && (t = t.replace(n[i], r))
                                }
                            return t
                        }(t);
                    if (!s(t) || a || null != r && 0 !== (t.name || '').indexOf(r)) {
                        if (n(t)) {
                            for (var c = [], h = 0; h < t.length; h++)
                                c.push(l(t[h]));
                            return c
                        }
                        if (o(t)) {
                            var u = {};
                            for (var p in t)
                                u[p] = l(t[p]);
                            return u
                        }
                        return t
                    }
                    return t(e)
                }
            };
            return l(t)
        }
        ,
        t.findWithFunction = h,
        t.removeWithFunction = function(t, e) {
            var n = h(t, e);
            return n > -1 && t.splice(n, 1),
            -1 !== n
        }
        ,
        t.remove = u,
        t.addWithFunction = function(t, e, n) {
            -1 === h(t, n) && t.push(e)
        }
        ,
        t.addToList = p,
        t.suggest = function(t, e, n) {
            return -1 === t.indexOf(e) && (n ? t.unshift(e) : t.push(e),
            !0)
        }
        ,
        t.extend = function(t, e, i) {
            var r;
            e = n(e) ? e : [e];
            var o = function(e) {
                for (var n = e.__proto__; null != n; )
                    if (null != n.prototype) {
                        for (var i in n.prototype)
                            n.prototype.hasOwnProperty(i) && !t.prototype.hasOwnProperty(i) && (t.prototype[i] = n.prototype[i]);
                        n = n.prototype.__proto__
                    } else
                        n = null
            };
            for (r = 0; r < e.length; r++) {
                for (var a in e[r].prototype)
                    e[r].prototype.hasOwnProperty(a) && !t.prototype.hasOwnProperty(a) && (t.prototype[a] = e[r].prototype[a]);
                o(e[r])
            }
            var s = function(t, n) {
                return function() {
                    for (r = 0; r < e.length; r++)
                        e[r].prototype[t] && e[r].prototype[t].apply(this, arguments);
                    return n.apply(this, arguments)
                }
            }
              , l = function(e) {
                for (var n in e)
                    t.prototype[n] = s(n, e[n])
            };
            if (arguments.length > 2)
                for (r = 2; r < arguments.length; r++)
                    l(arguments[r]);
            return t
        }
        ,
        t.uuid = d,
        t.fastTrim = function(t) {
            if (null == t)
                return null;
            for (var e = t.replace(/^\s\s*/, ''), n = /\s/, i = e.length; n.test(e.charAt(--i)); )
                ;
            return e.slice(0, i + 1)
        }
        ,
        t.each = function(t, e) {
            t = null == t.length || 'string' == typeof t ? [t] : t;
            for (var n = 0; n < t.length; n++)
                e(t[n])
        }
        ,
        t.map = function(t, e) {
            for (var n = [], i = 0; i < t.length; i++)
                n.push(e(t[i]));
            return n
        }
        ,
        t.mergeWithParents = function(t, e, n) {
            n = n || 'parent';
            var i = function(t) {
                return t ? e[t] : null
            }
              , r = function(t) {
                return t ? i(t[n]) : null
            }
              , o = function(t, e) {
                if (null == t)
                    return e;
                var n = ['anchor', 'anchors', 'cssClass', 'connector', 'paintStyle', 'hoverPaintStyle', 'endpoint', 'endpoints'];
                'override' === e.mergeStrategy && Array.prototype.push.apply(n, ['events', 'overlays']);
                var i = c(t, e, [], n);
                return o(r(t), i)
            }
              , a = function(t) {
                if (null == t)
                    return {};
                if ('string' == typeof t)
                    return i(t);
                if (t.length) {
                    for (var e = !1, n = 0, r = void 0; !e && n < t.length; )
                        (r = a(t[n])) ? e = !0 : n++;
                    return r
                }
            }
              , s = a(t);
            return s ? o(r(s), s) : {}
        }
        ,
        t.logEnabled = !0,
        t.log = f,
        t.wrap = function(t, e, n) {
            return function() {
                var i = null;
                try {
                    null != e && (i = e.apply(this, arguments))
                } catch (t) {
                    f('jsPlumb function failed : ' + t)
                }
                if (null != t && (null == n || i !== n))
                    try {
                        i = t.apply(this, arguments)
                    } catch (t) {
                        f('wrapped function failed : ' + t)
                    }
                return i
            }
        }
        ;
        var m = function() {
            var t = this;
            this._listeners = {},
            this.eventsSuspended = !1,
            this.tick = !1,
            this.eventsToDieOn = {
                ready: !0
            },
            this.queue = [],
            this.bind = function(e, n, i) {
                var r = function(e) {
                    p(t._listeners, e, n, i),
                    n.__jsPlumb = n.__jsPlumb || {},
                    n.__jsPlumb[d()] = e
                };
                if ('string' == typeof e)
                    r(e);
                else if (null != e.length)
                    for (var o = 0; o < e.length; o++)
                        r(e[o]);
                return t
            }
            ,
            this.fire = function(t, e, n) {
                if (this.tick)
                    this.queue.unshift(arguments);
                else {
                    if (this.tick = !0,
                    !this.eventsSuspended && this._listeners[t]) {
                        var i = this._listeners[t].length
                          , r = 0
                          , o = !1
                          , a = null;
                        if (!this.shouldFireEvent || this.shouldFireEvent(t, e, n))
                            for (; !o && r < i && !1 !== a; ) {
                                if (this.eventsToDieOn[t])
                                    this._listeners[t][r].apply(this, [e, n]);
                                else
                                    try {
                                        a = this._listeners[t][r].apply(this, [e, n])
                                    } catch (e) {
                                        f('jsPlumb: fire failed for event ' + t + ' : ' + e)
                                    }
                                r++,
                                null != this._listeners && null != this._listeners[t] || (o = !0)
                            }
                    }
                    this.tick = !1,
                    this._drain()
                }
                return this
            }
            ,
            this._drain = function() {
                var e = t.queue.pop();
                e && t.fire.apply(t, e)
            }
            ,
            this.unbind = function(t, e) {
                if (0 === arguments.length)
                    this._listeners = {};
                else if (1 === arguments.length) {
                    if ('string' == typeof t)
                        delete this._listeners[t];
                    else if (t.__jsPlumb) {
                        var n = void 0;
                        for (var i in t.__jsPlumb)
                            n = t.__jsPlumb[i],
                            u(this._listeners[n] || [], t)
                    }
                } else
                    2 === arguments.length && u(this._listeners[t] || [], e);
                return this
            }
            ,
            this.getListener = function(e) {
                return t._listeners[e]
            }
            ,
            this.setSuspendEvents = function(e) {
                t.eventsSuspended = e
            }
            ,
            this.isSuspendEvents = function() {
                return t.eventsSuspended
            }
            ,
            this.silently = function(e) {
                t.setSuspendEvents(!0);
                try {
                    e()
                } catch (t) {
                    f('Cannot execute silent function ' + t)
                }
                t.setSuspendEvents(!1)
            }
            ,
            this.cleanupListeners = function() {
                for (var e in t._listeners)
                    t._listeners[e] = null
            }
        };
        t.EventGenerator = m
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        this.jsPlumbUtil.matchesSelector = function(t, e, n) {
            for (var i = (n = n || t.parentNode).querySelectorAll(e), r = 0; r < i.length; r++)
                if (i[r] === t)
                    return !0;
            return !1
        }
        ,
        this.jsPlumbUtil.consume = function(t, e) {
            t.stopPropagation ? t.stopPropagation() : t.returnValue = !1,
            !e && t.preventDefault && t.preventDefault()
        }
        ,
        this.jsPlumbUtil.sizeElement = function(t, e, n, i, r) {
            t && (t.style.height = r + 'px',
            t.height = r,
            t.style.width = i + 'px',
            t.width = i,
            t.style.left = e + 'px',
            t.style.top = n + 'px')
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        var t = {
            deriveAnchor: function(t, e, n, i) {
                return {
                    top: ['TopRight', 'TopLeft'],
                    bottom: ['BottomRight', 'BottomLeft']
                }[t][e]
            }
        }
          , e = function(t) {
            this.count = 0,
            this.instance = t,
            this.lists = {},
            this.instance.addList = function(t, e) {
                return this.listManager.addList(t, e)
            }
            ,
            this.instance.removeList = function(t) {
                this.listManager.removeList(t)
            }
            ,
            this.instance.bind('manageElement', function(t) {
                for (var e = this.instance.getSelector(t.el, '[jtk-scrollable-list]'), n = 0; n < e.length; n++)
                    this.addList(e[n])
            }
            .bind(this)),
            this.instance.bind('unmanageElement', (function(t) {
                this.removeList(t.el)
            }
            )),
            this.instance.bind('connection', function(t, e) {
                null == e && (this._maybeUpdateParentList(t.source),
                this._maybeUpdateParentList(t.target))
            }
            .bind(this))
        };
        this.jsPlumbListManager = e,
        e.prototype = {
            addList: function(e, i) {
                var r = this.instance.extend({}, t);
                i = this.instance.extend(r, i || {});
                var o = [this.instance.getInstanceIndex(), this.count++].join('_');
                this.lists[o] = new n(this.instance,e,i,o)
            },
            removeList: function(t) {
                var e = this.lists[t._jsPlumbList];
                e && (e.destroy(),
                delete this.lists[t._jsPlumbList])
            },
            _maybeUpdateParentList: function(t) {
                for (var e = t.parentNode, n = this.instance.getContainer(); null != e && e !== n; ) {
                    if (null != e._jsPlumbList && null != this.lists[e._jsPlumbList])
                        return void e._jsPlumbScrollHandler();
                    e = e.parentNode
                }
            }
        };
        var n = function(t, e, n, i) {
            function r(t, e, i, r) {
                return n.anchor ? n.anchor : n.deriveAnchor(t, e, i, r)
            }
            function o(t, e, i, r) {
                return n.deriveEndpoint ? n.deriveEndpoint(t, e, i, r) : n.endpoint ? n.endpoint : i.type
            }
            e._jsPlumbList = i;
            var a = function(n) {
                for (var i = t.getSelector(e, '.jtk-managed'), a = t.getId(e), s = 0; s < i.length; s++) {
                    if (i[s].offsetTop < e.scrollTop)
                        i[s]._jsPlumbProxies || (i[s]._jsPlumbProxies = i[s]._jsPlumbProxies || [],
                        t.select({
                            source: i[s]
                        }).each((function(n) {
                            t.proxyConnection(n, 0, e, a, (function() {
                                return o('top', 0, n.endpoints[0], n)
                            }
                            ), (function() {
                                return r('top', 0, n.endpoints[0], n)
                            }
                            )),
                            i[s]._jsPlumbProxies.push([n, 0])
                        }
                        )),
                        t.select({
                            target: i[s]
                        }).each((function(n) {
                            t.proxyConnection(n, 1, e, a, (function() {
                                return o('top', 1, n.endpoints[1], n)
                            }
                            ), (function() {
                                return r('top', 1, n.endpoints[1], n)
                            }
                            )),
                            i[s]._jsPlumbProxies.push([n, 1])
                        }
                        )));
                    else if (i[s].offsetTop > e.scrollTop + e.offsetHeight)
                        i[s]._jsPlumbProxies || (i[s]._jsPlumbProxies = i[s]._jsPlumbProxies || [],
                        t.select({
                            source: i[s]
                        }).each((function(n) {
                            t.proxyConnection(n, 0, e, a, (function() {
                                return o('bottom', 0, n.endpoints[0], n)
                            }
                            ), (function() {
                                return r('bottom', 0, n.endpoints[0], n)
                            }
                            )),
                            i[s]._jsPlumbProxies.push([n, 0])
                        }
                        )),
                        t.select({
                            target: i[s]
                        }).each((function(n) {
                            t.proxyConnection(n, 1, e, a, (function() {
                                return o('bottom', 1, n.endpoints[1], n)
                            }
                            ), (function() {
                                return r('bottom', 1, n.endpoints[1], n)
                            }
                            )),
                            i[s]._jsPlumbProxies.push([n, 1])
                        }
                        )));
                    else if (i[s]._jsPlumbProxies) {
                        for (var l = 0; l < i[s]._jsPlumbProxies.length; l++)
                            t.unproxyConnection(i[s]._jsPlumbProxies[l][0], i[s]._jsPlumbProxies[l][1], a);
                        delete i[s]._jsPlumbProxies
                    }
                    t.revalidate(i[s])
                }
                !function(e) {
                    for (var n = e.parentNode, i = t.getContainer(); null != n && n !== i; ) {
                        if (t.hasClass(n, 'jtk-managed'))
                            return void t.recalculateOffsets(n);
                        n = n.parentNode
                    }
                }(e)
            };
            t.setAttribute(e, 'jtk-scrollable-list', 'true'),
            e._jsPlumbScrollHandler = a,
            t.on(e, 'scroll', a),
            a(),
            this.destroy = function() {
                t.off(e, 'scroll', a),
                delete e._jsPlumbScrollHandler;
                for (var n = t.getSelector(e, '.jtk-managed'), i = t.getId(e), r = 0; r < n.length; r++)
                    if (n[r]._jsPlumbProxies) {
                        for (var o = 0; o < n[r]._jsPlumbProxies.length; o++)
                            t.unproxyConnection(n[r]._jsPlumbProxies[o][0], n[r]._jsPlumbProxies[o][1], i);
                        delete n[r]._jsPlumbProxies
                    }
            }
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , n = t.jsPlumbUtil
          , i = function() {
            return '' + (new Date).getTime()
        }
          , r = function(t) {
            if (t._jsPlumb.paintStyle && t._jsPlumb.hoverPaintStyle) {
                var e = {};
                d.extend(e, t._jsPlumb.paintStyle),
                d.extend(e, t._jsPlumb.hoverPaintStyle),
                delete t._jsPlumb.hoverPaintStyle,
                e.gradient && t._jsPlumb.paintStyle.fill && delete e.gradient,
                t._jsPlumb.hoverPaintStyle = e
            }
        }
          , o = ['tap', 'dbltap', 'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'contextmenu']
          , a = function(t) {
            return null == t ? null : t.split(' ')
        }
          , s = function(t, e, n) {
            for (var i in e)
                t[i] = n
        }
          , l = function(t, e, i) {
            if (t.getDefaultType) {
                var r = t.getTypeDescriptor()
                  , o = {}
                  , a = t.getDefaultType()
                  , l = n.merge({}, a);
                s(o, a, '__default');
                for (var c = 0, h = t._jsPlumb.types.length; c < h; c++) {
                    var u = t._jsPlumb.types[c];
                    if ('__default' !== u) {
                        var p = t._jsPlumb.instance.getType(u, r);
                        if (null != p) {
                            var d = ['anchor', 'anchors', 'connector', 'paintStyle', 'hoverPaintStyle', 'endpoint', 'endpoints', 'connectorOverlays', 'connectorStyle', 'connectorHoverStyle', 'endpointStyle', 'endpointHoverStyle']
                              , f = [];
                            'override' === p.mergeStrategy ? Array.prototype.push.apply(d, ['events', 'overlays', 'cssClass']) : f.push('cssClass'),
                            l = n.merge(l, p, f, d),
                            s(o, p, u)
                        }
                    }
                }
                e && (l = n.populate(l, e, '_')),
                t.applyType(l, i, o),
                i || t.repaint()
            }
        }
          , c = t.jsPlumbUIComponent = function(t) {
            n.EventGenerator.apply(this, arguments);
            var e = this
              , i = arguments
              , r = e.idPrefix
              , o = r + (new Date).getTime();
            this._jsPlumb = {
                instance: t._jsPlumb,
                parameters: t.parameters || {},
                paintStyle: null,
                hoverPaintStyle: null,
                paintStyleInUse: null,
                hover: !1,
                beforeDetach: t.beforeDetach,
                beforeDrop: t.beforeDrop,
                overlayPlacements: [],
                hoverClass: t.hoverClass || t._jsPlumb.Defaults.HoverClass,
                types: [],
                typeCache: {}
            },
            this.cacheTypeItem = function(t, e, n) {
                this._jsPlumb.typeCache[n] = this._jsPlumb.typeCache[n] || {},
                this._jsPlumb.typeCache[n][t] = e
            }
            ,
            this.getCachedTypeItem = function(t, e) {
                return this._jsPlumb.typeCache[e] ? this._jsPlumb.typeCache[e][t] : null
            }
            ,
            this.getId = function() {
                return o
            }
            ;
            var a = t.overlays || []
              , s = {};
            if (this.defaultOverlayKeys) {
                for (var l = 0; l < this.defaultOverlayKeys.length; l++)
                    Array.prototype.push.apply(a, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[l]] || []);
                for (l = 0; l < a.length; l++) {
                    var c = d.convertToFullOverlaySpec(a[l]);
                    s[c[1].id] = c
                }
            }
            var h = {
                overlays: s,
                parameters: t.parameters || {},
                scope: t.scope || this._jsPlumb.instance.getDefaultScope()
            };
            if (this.getDefaultType = function() {
                return h
            }
            ,
            this.appendToDefaultType = function(t) {
                for (var e in t)
                    h[e] = t[e]
            }
            ,
            t.events)
                for (var u in t.events)
                    e.bind(u, t.events[u]);
            this.clone = function() {
                var t = Object.create(this.constructor.prototype);
                return this.constructor.apply(t, i),
                t
            }
            .bind(this),
            this.isDetachAllowed = function(t) {
                var e = !0;
                if (this._jsPlumb.beforeDetach)
                    try {
                        e = this._jsPlumb.beforeDetach(t)
                    } catch (t) {
                        n.log('jsPlumb: beforeDetach callback failed', t)
                    }
                return e
            }
            ,
            this.isDropAllowed = function(t, e, i, r, o, a, s) {
                var l = this._jsPlumb.instance.checkCondition('beforeDrop', {
                    sourceId: t,
                    targetId: e,
                    scope: i,
                    connection: r,
                    dropEndpoint: o,
                    source: a,
                    target: s
                });
                if (this._jsPlumb.beforeDrop)
                    try {
                        l = this._jsPlumb.beforeDrop({
                            sourceId: t,
                            targetId: e,
                            scope: i,
                            connection: r,
                            dropEndpoint: o,
                            source: a,
                            target: s
                        })
                    } catch (t) {
                        n.log('jsPlumb: beforeDrop callback failed', t)
                    }
                return l
            }
            ;
            var p = [];
            this.setListenerComponent = function(t) {
                for (var e = 0; e < p.length; e++)
                    p[e][3] = t
            }
        }
          , h = function(t, e) {
            var n = t._jsPlumb.types[e]
              , i = t._jsPlumb.instance.getType(n, t.getTypeDescriptor());
            null != i && i.cssClass && t.canvas && t._jsPlumb.instance.removeClass(t.canvas, i.cssClass)
        };
        n.extend(t.jsPlumbUIComponent, n.EventGenerator, {
            getParameter: function(t) {
                return this._jsPlumb.parameters[t]
            },
            setParameter: function(t, e) {
                this._jsPlumb.parameters[t] = e
            },
            getParameters: function() {
                return this._jsPlumb.parameters
            },
            setParameters: function(t) {
                this._jsPlumb.parameters = t
            },
            getClass: function() {
                return d.getClass(this.canvas)
            },
            hasClass: function(t) {
                return d.hasClass(this.canvas, t)
            },
            addClass: function(t) {
                d.addClass(this.canvas, t)
            },
            removeClass: function(t) {
                d.removeClass(this.canvas, t)
            },
            updateClasses: function(t, e) {
                d.updateClasses(this.canvas, t, e)
            },
            setType: function(t, e, n) {
                this.clearTypes(),
                this._jsPlumb.types = a(t) || [],
                l(this, e, n)
            },
            getType: function() {
                return this._jsPlumb.types
            },
            reapplyTypes: function(t, e) {
                l(this, t, e)
            },
            hasType: function(t) {
                return -1 !== this._jsPlumb.types.indexOf(t)
            },
            addType: function(t, e, n) {
                var i = a(t)
                  , r = !1;
                if (null != i) {
                    for (var o = 0, s = i.length; o < s; o++)
                        this.hasType(i[o]) || (this._jsPlumb.types.push(i[o]),
                        r = !0);
                    r && l(this, e, n)
                }
            },
            removeType: function(t, e, n) {
                var i = a(t)
                  , r = !1
                  , o = function(t) {
                    var e = this._jsPlumb.types.indexOf(t);
                    return -1 !== e && (h(this, e),
                    this._jsPlumb.types.splice(e, 1),
                    !0)
                }
                .bind(this);
                if (null != i) {
                    for (var s = 0, c = i.length; s < c; s++)
                        r = o(i[s]) || r;
                    r && l(this, e, n)
                }
            },
            clearTypes: function(t, e) {
                for (var n = this._jsPlumb.types.length, i = 0; i < n; i++)
                    h(this, 0),
                    this._jsPlumb.types.splice(0, 1);
                l(this, t, e)
            },
            toggleType: function(t, e, n) {
                var i = a(t);
                if (null != i) {
                    for (var r = 0, o = i.length; r < o; r++) {
                        var s = this._jsPlumb.types.indexOf(i[r]);
                        -1 !== s ? (h(this, s),
                        this._jsPlumb.types.splice(s, 1)) : this._jsPlumb.types.push(i[r])
                    }
                    l(this, e, n)
                }
            },
            applyType: function(t, e) {
                if (this.setPaintStyle(t.paintStyle, e),
                this.setHoverPaintStyle(t.hoverPaintStyle, e),
                t.parameters)
                    for (var n in t.parameters)
                        this.setParameter(n, t.parameters[n]);
                this._jsPlumb.paintStyleInUse = this.getPaintStyle()
            },
            setPaintStyle: function(t, e) {
                this._jsPlumb.paintStyle = t,
                this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle,
                r(this),
                e || this.repaint()
            },
            getPaintStyle: function() {
                return this._jsPlumb.paintStyle
            },
            setHoverPaintStyle: function(t, e) {
                this._jsPlumb.hoverPaintStyle = t,
                r(this),
                e || this.repaint()
            },
            getHoverPaintStyle: function() {
                return this._jsPlumb.hoverPaintStyle
            },
            destroy: function(t) {
                (t || null == this.typeId) && (this.cleanupListeners(),
                this.clone = null,
                this._jsPlumb = null)
            },
            isHover: function() {
                return this._jsPlumb.hover
            },
            setHover: function(t, e, n) {
                if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {
                    this._jsPlumb.hover = t;
                    var r = t ? 'addClass' : 'removeClass';
                    null != this.canvas && (null != this._jsPlumb.instance.hoverClass && this._jsPlumb.instance[r](this.canvas, this._jsPlumb.instance.hoverClass),
                    null != this._jsPlumb.hoverClass && this._jsPlumb.instance[r](this.canvas, this._jsPlumb.hoverClass)),
                    null != this._jsPlumb.hoverPaintStyle && (this._jsPlumb.paintStyleInUse = t ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle,
                    this._jsPlumb.instance.isSuspendDrawing() || (n = n || i(),
                    this.repaint({
                        timestamp: n,
                        recalc: !1
                    }))),
                    this.getAttachedElements && !e && function(t, e, n, i) {
                        var r = t.getAttachedElements();
                        if (r)
                            for (var o = 0, a = r.length; o < a; o++)
                                i && i === r[o] || r[o].setHover(e, !0, n)
                    }(this, t, i(), this)
                }
            }
        });
        var u = 0
          , p = t.jsPlumbInstance = function(e) {
            this.version = '2.12.8',
            this.Defaults = {
                Anchor: 'Bottom',
                Anchors: [null, null],
                ConnectionsDetachable: !0,
                ConnectionOverlays: [],
                Connector: 'Bezier',
                Container: null,
                DoNotThrowErrors: !1,
                DragOptions: {},
                DropOptions: {},
                Endpoint: 'Dot',
                EndpointOverlays: [],
                Endpoints: [null, null],
                EndpointStyle: {
                    fill: '#456'
                },
                EndpointStyles: [null, null],
                EndpointHoverStyle: null,
                EndpointHoverStyles: [null, null],
                HoverPaintStyle: null,
                LabelStyle: {
                    color: 'pink'
                },
                LogEnabled: !1,
                Overlays: [],
                MaxConnections: 1,
                PaintStyle: {
                    'stroke-width': 4,
                    stroke: '#456'
                },
                ReattachConnections: !1,
                RenderMode: 'svg',
                Scope: 'jsPlumb_DefaultScope'
            },
            e && d.extend(this.Defaults, e),
            this.logEnabled = this.Defaults.LogEnabled,
            this._connectionTypes = {},
            this._endpointTypes = {},
            n.EventGenerator.apply(this);
            var r = this
              , a = function() {
                var t = u + 1;
                return u++,
                t
            }()
              , s = r.bind
              , l = {}
              , h = 1
              , p = function(t) {
                if (null == t)
                    return null;
                if (3 === t.nodeType || 8 === t.nodeType)
                    return {
                        el: t,
                        text: !0
                    };
                var e = r.getElement(t);
                return {
                    el: e,
                    id: n.isString(t) && null == e ? t : B(e)
                }
            };
            for (var f in this.getInstanceIndex = function() {
                return a
            }
            ,
            this.setZoom = function(t, e) {
                return h = t,
                r.fire('zoom', h),
                e && r.repaintEverything(),
                !0
            }
            ,
            this.getZoom = function() {
                return h
            }
            ,
            this.Defaults)
                l[f] = this.Defaults[f];
            var m, g = [];
            this.unbindContainer = function() {
                if (null != m && g.length > 0)
                    for (var t = 0; t < g.length; t++)
                        r.off(m, g[t][0], g[t][1])
            }
            ,
            this.setContainer = function(t) {
                this.unbindContainer(),
                t = this.getElement(t),
                this.select().each((function(e) {
                    e.moveParent(t)
                }
                )),
                this.selectEndpoints().each((function(e) {
                    e.moveParent(t)
                }
                ));
                var e = m;
                m = t,
                g.length = 0;
                for (var n = {
                    endpointclick: 'endpointClick',
                    endpointdblclick: 'endpointDblClick'
                }, i = function(t, e, i) {
                    var o = e.srcElement || e.target
                      , a = (o && o.parentNode ? o.parentNode._jsPlumb : null) || (o ? o._jsPlumb : null) || (o && o.parentNode && o.parentNode.parentNode ? o.parentNode.parentNode._jsPlumb : null);
                    if (a) {
                        a.fire(t, a, e);
                        var s = i && n[i + t] || t;
                        r.fire(s, a.component || a, e)
                    }
                }, a = function(t, e, n) {
                    g.push([t, n]),
                    r.on(m, t, e, n)
                }, s = function(t) {
                    a(t, '.jtk-connector', (function(e) {
                        i(t, e)
                    }
                    )),
                    a(t, '.jtk-endpoint', (function(e) {
                        i(t, e, 'endpoint')
                    }
                    )),
                    a(t, '.jtk-overlay', (function(e) {
                        i(t, e)
                    }
                    ))
                }, l = 0; l < o.length; l++)
                    s(o[l]);
                for (var c in M) {
                    var h = M[c].el;
                    h.parentNode === e && (e.removeChild(h),
                    m.appendChild(h))
                }
            }
            ,
            this.getContainer = function() {
                return m
            }
            ,
            this.bind = function(t, e) {
                'ready' === t && y ? e() : s.apply(r, [t, e])
            }
            ,
            r.importDefaults = function(t) {
                for (var e in t)
                    r.Defaults[e] = t[e];
                return t.Container && r.setContainer(t.Container),
                r
            }
            ,
            r.restoreDefaults = function() {
                return r.Defaults = d.extend({}, l),
                r
            }
            ;
            var v = null
              , y = !1
              , x = []
              , b = {}
              , _ = {}
              , M = {}
              , w = {}
              , S = {}
              , P = !1
              , C = []
              , A = !1
              , E = null
              , T = this.Defaults.Scope
              , L = 1
              , D = function() {
                return '' + L++
            }
              , I = function(t, e) {
                m ? m.appendChild(t) : e ? this.getElement(e).appendChild(t) : this.appendToRoot(t)
            }
            .bind(this)
              , O = function(t, e, n, o) {
                if (!A) {
                    var a, s = B(t), l = r.getDragManager();
                    l && (a = l.getElementsForDraggable(s)),
                    null == n && (n = i());
                    var c = at({
                        elId: s,
                        offset: e,
                        recalc: !1,
                        timestamp: n
                    });
                    if (a && c && c.o)
                        for (var h in a)
                            at({
                                elId: a[h].id,
                                offset: {
                                    left: c.o.left + a[h].offset.left,
                                    top: c.o.top + a[h].offset.top
                                },
                                recalc: !1,
                                timestamp: n
                            });
                    if (r.anchorManager.redraw(s, e, n, null, o),
                    a)
                        for (var u in a)
                            r.anchorManager.redraw(a[u].id, e, n, a[u].offset, o, !0)
                }
            }
              , j = function(t) {
                return _[t]
            }
              , N = function(t, e) {
                var i = d.extend({}, t);
                if (e && d.extend(i, e),
                i.source && (i.source.endpoint ? i.sourceEndpoint = i.source : i.source = r.getElement(i.source)),
                i.target && (i.target.endpoint ? i.targetEndpoint = i.target : i.target = r.getElement(i.target)),
                t.uuids && (i.sourceEndpoint = j(t.uuids[0]),
                i.targetEndpoint = j(t.uuids[1])),
                i.sourceEndpoint && i.sourceEndpoint.isFull())
                    n.log(r, 'could not add connection; source endpoint is full');
                else if (i.targetEndpoint && i.targetEndpoint.isFull())
                    n.log(r, 'could not add connection; target endpoint is full');
                else {
                    if (!i.type && i.sourceEndpoint && (i.type = i.sourceEndpoint.connectionType),
                    i.sourceEndpoint && i.sourceEndpoint.connectorOverlays) {
                        i.overlays = i.overlays || [];
                        for (var o = 0, a = i.sourceEndpoint.connectorOverlays.length; o < a; o++)
                            i.overlays.push(i.sourceEndpoint.connectorOverlays[o])
                    }
                    i.sourceEndpoint && i.sourceEndpoint.scope && (i.scope = i.sourceEndpoint.scope),
                    !i['pointer-events'] && i.sourceEndpoint && i.sourceEndpoint.connectorPointerEvents && (i['pointer-events'] = i.sourceEndpoint.connectorPointerEvents);
                    var s = function(t, e, n) {
                        var o = function(t, e) {
                            var n = d.extend({}, t);
                            for (var i in e)
                                e[i] && (n[i] = e[i]);
                            return n
                        }(e, {
                            anchor: i.anchors ? i.anchors[n] : i.anchor,
                            endpoint: i.endpoints ? i.endpoints[n] : i.endpoint,
                            paintStyle: i.endpointStyles ? i.endpointStyles[n] : i.endpointStyle,
                            hoverPaintStyle: i.endpointHoverStyles ? i.endpointHoverStyles[n] : i.endpointHoverStyle
                        });
                        return r.addEndpoint(t, o)
                    }
                      , l = function(t, e, n, r) {
                        if (i[t] && !i[t].endpoint && !i[t + 'Endpoint'] && !i.newConnection) {
                            var o = n[B(i[t])];
                            if (o = o ? o[r] : null) {
                                if (!o.enabled)
                                    return !1;
                                var a = d.extend({}, o.def);
                                delete a.label;
                                var l = null != o.endpoint && o.endpoint._jsPlumb ? o.endpoint : s(i[t], a, e);
                                if (l.isFull())
                                    return !1;
                                i[t + 'Endpoint'] = l,
                                !i.scope && a.scope && (i.scope = a.scope),
                                o.uniqueEndpoint ? o.endpoint ? l.finalEndpoint = o.endpoint : (o.endpoint = l,
                                l.setDeleteOnEmpty(!1)) : l.setDeleteOnEmpty(!0),
                                0 === e && o.def.connectorOverlays && (i.overlays = i.overlays || [],
                                Array.prototype.push.apply(i.overlays, o.def.connectorOverlays))
                            }
                        }
                    };
                    if (!1 !== l('source', 0, this.sourceEndpointDefinitions, i.type || 'default') && !1 !== l('target', 1, this.targetEndpointDefinitions, i.type || 'default'))
                        return i.sourceEndpoint && i.targetEndpoint && (function(t, e) {
                            for (var n = t.scope.split(/\s/), i = e.scope.split(/\s/), r = 0; r < n.length; r++)
                                for (var o = 0; o < i.length; o++)
                                    if (i[o] === n[r])
                                        return !0;
                            return !1
                        }(i.sourceEndpoint, i.targetEndpoint) || (i = null)),
                        i
                }
            }
            .bind(r)
              , k = function(t) {
                var e = r.Defaults.ConnectionType || r.getDefaultConnectionType();
                t._jsPlumb = r,
                t.newConnection = k,
                t.newEndpoint = z,
                t.endpointsByUUID = _,
                t.endpointsByElement = b,
                t.finaliseConnection = F,
                t.id = 'con_' + D();
                var n = new e(t);
                return n.isDetachable() && (n.endpoints[0].initDraggable('_jsPlumbSource'),
                n.endpoints[1].initDraggable('_jsPlumbTarget')),
                n
            }
              , F = r.finaliseConnection = function(t, e, n, i) {
                if (e = e || {},
                t.suspendedEndpoint || x.push(t),
                t.pending = null,
                t.endpoints[0].isTemporarySource = !1,
                !1 !== i && r.anchorManager.newConnection(t),
                O(t.source),
                !e.doNotFireConnectionEvent && !1 !== e.fireEvent) {
                    var o = {
                        connection: t,
                        source: t.source,
                        target: t.target,
                        sourceId: t.sourceId,
                        targetId: t.targetId,
                        sourceEndpoint: t.endpoints[0],
                        targetEndpoint: t.endpoints[1]
                    };
                    r.fire('connection', o, n)
                }
            }
              , z = function(t, e) {
                var n = r.Defaults.EndpointType || d.Endpoint
                  , i = d.extend({}, t);
                i._jsPlumb = r,
                i.newConnection = k,
                i.newEndpoint = z,
                i.endpointsByUUID = _,
                i.endpointsByElement = b,
                i.fireDetachEvent = H,
                i.elementId = e || B(i.source);
                var o = new n(i);
                return o.id = 'ep_' + D(),
                ot(i.elementId, i.source),
                d.headless || r.getDragManager().endpointAdded(i.source, e),
                o
            }
              , R = function(t, e, n) {
                var i = b[t];
                if (i && i.length)
                    for (var r = 0, o = i.length; r < o; r++) {
                        for (var a = 0, s = i[r].connections.length; a < s; a++) {
                            if (e(i[r].connections[a]))
                                return
                        }
                        n && n(i[r])
                    }
            }
              , U = function(t, e, n) {
                e = 'block' === e;
                var i = null;
                n && (i = function(t) {
                    t.setVisible(e, !0, !0)
                }
                );
                var r = p(t);
                R(r.id, (function(t) {
                    if (e && n) {
                        var i = t.sourceId === r.id ? 1 : 0;
                        t.endpoints[i].isVisible() && t.setVisible(!0)
                    } else
                        t.setVisible(e)
                }
                ), i)
            }
              , B = function(t, e, i) {
                if (n.isString(t))
                    return t;
                if (null == t)
                    return null;
                var o = r.getAttribute(t, 'id');
                return o && 'undefined' !== o || (2 === arguments.length && void 0 !== arguments[1] ? o = e : (1 === arguments.length || 3 === arguments.length && !arguments[2]) && (o = 'jsPlumb_' + a + '_' + D()),
                i || r.setAttribute(t, 'id', o)),
                o
            };
            this.setConnectionBeingDragged = function(t) {
                P = t
            }
            ,
            this.isConnectionBeingDragged = function() {
                return P
            }
            ,
            this.getManagedElements = function() {
                return M
            }
            ,
            this.connectorClass = 'jtk-connector',
            this.connectorOutlineClass = 'jtk-connector-outline',
            this.connectedClass = 'jtk-connected',
            this.hoverClass = 'jtk-hover',
            this.endpointClass = 'jtk-endpoint',
            this.endpointConnectedClass = 'jtk-endpoint-connected',
            this.endpointFullClass = 'jtk-endpoint-full',
            this.endpointDropAllowedClass = 'jtk-endpoint-drop-allowed',
            this.endpointDropForbiddenClass = 'jtk-endpoint-drop-forbidden',
            this.overlayClass = 'jtk-overlay',
            this.draggingClass = 'jtk-dragging',
            this.elementDraggingClass = 'jtk-element-dragging',
            this.sourceElementDraggingClass = 'jtk-source-element-dragging',
            this.targetElementDraggingClass = 'jtk-target-element-dragging',
            this.endpointAnchorClassPrefix = 'jtk-endpoint-anchor',
            this.hoverSourceClass = 'jtk-source-hover',
            this.hoverTargetClass = 'jtk-target-hover',
            this.dragSelectClass = 'jtk-drag-select',
            this.Anchors = {},
            this.Connectors = {
                svg: {}
            },
            this.Endpoints = {
                svg: {}
            },
            this.Overlays = {
                svg: {}
            },
            this.ConnectorRenderers = {},
            this.SVG = 'svg',
            this.addEndpoint = function(t, e, i) {
                i = i || {};
                var o = d.extend({}, i);
                d.extend(o, e),
                o.endpoint = o.endpoint || r.Defaults.Endpoint,
                o.paintStyle = o.paintStyle || r.Defaults.EndpointStyle;
                for (var a = [], s = n.isArray(t) || null != t.length && !n.isString(t) ? t : [t], l = 0, c = s.length; l < c; l++) {
                    o.source = r.getElement(s[l]),
                    rt(o.source);
                    var h = B(o.source)
                      , u = z(o, h)
                      , p = ot(h, o.source).info.o;
                    n.addToList(b, h, u),
                    A || u.paint({
                        anchorLoc: u.anchor.compute({
                            xy: [p.left, p.top],
                            wh: C[h],
                            element: u,
                            timestamp: E
                        }),
                        timestamp: E
                    }),
                    a.push(u)
                }
                return 1 === a.length ? a[0] : a
            }
            ,
            this.addEndpoints = function(t, e, i) {
                for (var o = [], a = 0, s = e.length; a < s; a++) {
                    var l = r.addEndpoint(t, e[a], i);
                    n.isArray(l) ? Array.prototype.push.apply(o, l) : o.push(l)
                }
                return o
            }
            ,
            this.animate = function(t, e, i) {
                if (!this.animationSupported)
                    return !1;
                i = i || {};
                var o = r.getElement(t)
                  , a = B(o)
                  , s = d.animEvents.step
                  , l = d.animEvents.complete;
                i[s] = n.wrap(i[s], (function() {
                    r.revalidate(a)
                }
                )),
                i[l] = n.wrap(i[l], (function() {
                    r.revalidate(a)
                }
                )),
                r.doAnimate(o, e, i)
            }
            ,
            this.checkCondition = function(t, e) {
                var i = r.getListener(t)
                  , o = !0;
                if (i && i.length > 0) {
                    var a = Array.prototype.slice.call(arguments, 1);
                    try {
                        for (var s = 0, l = i.length; s < l; s++)
                            o = o && i[s].apply(i[s], a)
                    } catch (e) {
                        n.log(r, 'cannot check condition [' + t + ']' + e)
                    }
                }
                return o
            }
            ,
            this.connect = function(t, e) {
                var i, r = N(t, e);
                if (r) {
                    if (null == r.source && null == r.sourceEndpoint)
                        return void n.log('Cannot establish connection - source does not exist');
                    if (null == r.target && null == r.targetEndpoint)
                        return void n.log('Cannot establish connection - target does not exist');
                    rt(r.source),
                    i = k(r),
                    F(i, r)
                }
                return i
            }
            ;
            var V = [{
                el: 'source',
                elId: 'sourceId',
                epDefs: 'sourceEndpointDefinitions'
            }, {
                el: 'target',
                elId: 'targetId',
                epDefs: 'targetEndpointDefinitions'
            }]
              , G = function(t, e, n, i) {
                var r, o, a, s = V[n], l = t[s.elId], c = (t[s.el],
                t.endpoints[n]), h = {
                    index: n,
                    originalSourceId: 0 === n ? l : t.sourceId,
                    newSourceId: t.sourceId,
                    originalTargetId: 1 === n ? l : t.targetId,
                    newTargetId: t.targetId,
                    connection: t
                };
                if (e.constructor === d.Endpoint)
                    (r = e).addConnection(t),
                    e = r.element;
                else if (o = B(e),
                a = this[s.epDefs][o],
                o === t[s.elId])
                    r = null;
                else if (a)
                    for (var u in a) {
                        if (!a[u].enabled)
                            return;
                        r = null != a[u].endpoint && a[u].endpoint._jsPlumb ? a[u].endpoint : this.addEndpoint(e, a[u].def),
                        a[u].uniqueEndpoint && (a[u].endpoint = r),
                        r.addConnection(t)
                    }
                else
                    r = t.makeEndpoint(0 === n, e, o);
                return null != r && (c.detachFromConnection(t),
                t.endpoints[n] = r,
                t[s.el] = r.element,
                t[s.elId] = r.elementId,
                h[0 === n ? 'newSourceId' : 'newTargetId'] = r.elementId,
                W(h),
                i || t.repaint()),
                h.element = e,
                h
            }
            .bind(this);
            this.setSource = function(t, e, n) {
                var i = G(t, e, 0, n);
                this.anchorManager.sourceChanged(i.originalSourceId, i.newSourceId, t, i.el)
            }
            ,
            this.setTarget = function(t, e, n) {
                var i = G(t, e, 1, n);
                this.anchorManager.updateOtherEndpoint(i.originalSourceId, i.originalTargetId, i.newTargetId, t)
            }
            ,
            this.deleteEndpoint = function(t, e, n) {
                var i = 'string' == typeof t ? _[t] : t;
                return i && r.deleteObject({
                    endpoint: i,
                    dontUpdateHover: e,
                    deleteAttachedObjects: n
                }),
                r
            }
            ,
            this.deleteEveryEndpoint = function() {
                var t = r.setSuspendDrawing(!0);
                for (var e in b) {
                    var n = b[e];
                    if (n && n.length)
                        for (var i = 0, o = n.length; i < o; i++)
                            r.deleteEndpoint(n[i], !0)
                }
                b = {},
                M = {},
                _ = {},
                w = {},
                S = {},
                r.anchorManager.reset();
                var a = r.getDragManager();
                return a && a.reset(),
                t || r.setSuspendDrawing(!1),
                r
            }
            ;
            var H = function(t, e, n) {
                var i = r.Defaults.ConnectionType || r.getDefaultConnectionType()
                  , o = t.constructor === i ? {
                    connection: t,
                    source: t.source,
                    target: t.target,
                    sourceId: t.sourceId,
                    targetId: t.targetId,
                    sourceEndpoint: t.endpoints[0],
                    targetEndpoint: t.endpoints[1]
                } : t;
                e && r.fire('connectionDetached', o, n),
                r.fire('internal.connectionDetached', o, n),
                r.anchorManager.connectionDetached(o)
            }
              , W = r.fireMoveEvent = function(t, e) {
                r.fire('connectionMoved', t, e)
            }
            ;
            this.unregisterEndpoint = function(t) {
                for (var e in t._jsPlumb.uuid && (_[t._jsPlumb.uuid] = null),
                r.anchorManager.deleteEndpoint(t),
                b) {
                    var n = b[e];
                    if (n) {
                        for (var i = [], o = 0, a = n.length; o < a; o++)
                            n[o] !== t && i.push(n[o]);
                        b[e] = i
                    }
                    b[e].length < 1 && delete b[e]
                }
            }
            ;
            this.deleteConnection = function(t, e) {
                return !(null == t || !(e = e || {}).force && !n.functionChain(!0, !1, [[t.endpoints[0], 'isDetachAllowed', [t]], [t.endpoints[1], 'isDetachAllowed', [t]], [t, 'isDetachAllowed', [t]], [r, 'checkCondition', ['beforeDetach', t]]])) && (t.setHover(!1),
                H(t, !t.pending && !1 !== e.fireEvent, e.originalEvent),
                t.endpoints[0].detachFromConnection(t),
                t.endpoints[1].detachFromConnection(t),
                n.removeWithFunction(x, (function(e) {
                    return t.id === e.id
                }
                )),
                t.cleanup(),
                t.destroy(),
                !0)
            }
            ,
            this.deleteEveryConnection = function(t) {
                t = t || {};
                var e = x.length
                  , n = 0;
                return r.batch((function() {
                    for (var i = 0; i < e; i++)
                        n += r.deleteConnection(x[0], t) ? 1 : 0
                }
                )),
                n
            }
            ,
            this.deleteConnectionsForElement = function(t, e) {
                e = e || {},
                t = r.getElement(t);
                var n = B(t)
                  , i = b[n];
                if (i && i.length)
                    for (var o = 0, a = i.length; o < a; o++)
                        i[o].deleteEveryConnection(e);
                return r
            }
            ,
            this.deleteObject = function(t) {
                var e = {
                    endpoints: {},
                    connections: {},
                    endpointCount: 0,
                    connectionCount: 0
                }
                  , i = !1 !== t.deleteAttachedObjects
                  , o = function(n) {
                    null != n && null == e.connections[n.id] && (t.dontUpdateHover || null == n._jsPlumb || n.setHover(!1),
                    e.connections[n.id] = n,
                    e.connectionCount++)
                };
                for (var a in t.connection ? o(t.connection) : function(n) {
                    if (null != n && null == e.endpoints[n.id] && (t.dontUpdateHover || null == n._jsPlumb || n.setHover(!1),
                    e.endpoints[n.id] = n,
                    e.endpointCount++,
                    i))
                        for (var r = 0; r < n.connections.length; r++) {
                            var a = n.connections[r];
                            o(a)
                        }
                }(t.endpoint),
                e.connections) {
                    var s = e.connections[a];
                    if (s._jsPlumb) {
                        n.removeWithFunction(x, (function(t) {
                            return s.id === t.id
                        }
                        )),
                        H(s, !1 !== t.fireEvent && !s.pending, t.originalEvent);
                        var l = null == t.deleteAttachedObjects ? null : !t.deleteAttachedObjects;
                        s.endpoints[0].detachFromConnection(s, null, l),
                        s.endpoints[1].detachFromConnection(s, null, l),
                        s.cleanup(!0),
                        s.destroy(!0)
                    }
                }
                for (var c in e.endpoints) {
                    var h = e.endpoints[c];
                    h._jsPlumb && (r.unregisterEndpoint(h),
                    h.cleanup(!0),
                    h.destroy(!0))
                }
                return e
            }
            ;
            var X = function(t, e, n, i) {
                for (var r = 0, o = t.length; r < o; r++)
                    t[r][e].apply(t[r], n);
                return i(t)
            }
              , q = function(t, e, n) {
                for (var i = [], r = 0, o = t.length; r < o; r++)
                    i.push([t[r][e].apply(t[r], n), t[r]]);
                return i
            }
              , Y = function(t, e, n) {
                return function() {
                    return X(t, e, arguments, n)
                }
            }
              , J = function(t, e) {
                return function() {
                    return q(t, e, arguments)
                }
            }
              , Z = function(t, e) {
                var n = [];
                if (t)
                    if ('string' == typeof t) {
                        if ('*' === t)
                            return t;
                        n.push(t)
                    } else if (e)
                        n = t;
                    else if (t.length)
                        for (var i = 0, r = t.length; i < r; i++)
                            n.push(p(t[i]).id);
                    else
                        n.push(p(t).id);
                return n
            }
              , K = function(t, e, n) {
                return '*' === t || (t.length > 0 ? -1 !== t.indexOf(e) : !n)
            };
            this.getConnections = function(t, e) {
                t ? t.constructor === String && (t = {
                    scope: t
                }) : t = {};
                for (var n = t.scope || r.getDefaultScope(), i = Z(n, !0), o = Z(t.source), a = Z(t.target), s = !e && i.length > 1 ? {} : [], l = function(t, n) {
                    if (!e && i.length > 1) {
                        var r = s[t];
                        null == r && (r = s[t] = []),
                        r.push(n)
                    } else
                        s.push(n)
                }, c = 0, h = x.length; c < h; c++) {
                    var u = x[c]
                      , p = u.proxies && u.proxies[0] ? u.proxies[0].originalEp.elementId : u.sourceId
                      , d = u.proxies && u.proxies[1] ? u.proxies[1].originalEp.elementId : u.targetId;
                    K(i, u.scope) && K(o, p) && K(a, d) && l(u.scope, u)
                }
                return s
            }
            ;
            var Q = function(t, e) {
                return function(n) {
                    for (var i = 0, r = t.length; i < r; i++)
                        n(t[i]);
                    return e(t)
                }
            }
              , $ = function(t) {
                return function(e) {
                    return t[e]
                }
            }
              , tt = function(t, e) {
                var n, i, r = {
                    length: t.length,
                    each: Q(t, e),
                    get: $(t)
                }, o = ['setHover', 'removeAllOverlays', 'setLabel', 'addClass', 'addOverlay', 'removeOverlay', 'removeOverlays', 'showOverlay', 'hideOverlay', 'showOverlays', 'hideOverlays', 'setPaintStyle', 'setHoverPaintStyle', 'setSuspendEvents', 'setParameter', 'setParameters', 'setVisible', 'repaint', 'addType', 'toggleType', 'removeType', 'removeClass', 'setType', 'bind', 'unbind'], a = ['getLabel', 'getOverlay', 'isHover', 'getParameter', 'getParameters', 'getPaintStyle', 'getHoverPaintStyle', 'isVisible', 'hasType', 'getType', 'isSuspendEvents'];
                for (n = 0,
                i = o.length; n < i; n++)
                    r[o[n]] = Y(t, o[n], e);
                for (n = 0,
                i = a.length; n < i; n++)
                    r[a[n]] = J(t, a[n]);
                return r
            }
              , et = function(t) {
                var e = tt(t, et);
                return d.extend(e, {
                    setDetachable: Y(t, 'setDetachable', et),
                    setReattach: Y(t, 'setReattach', et),
                    setConnector: Y(t, 'setConnector', et),
                    delete: function() {
                        for (var e = 0, n = t.length; e < n; e++)
                            r.deleteConnection(t[e])
                    },
                    isDetachable: J(t, 'isDetachable'),
                    isReattach: J(t, 'isReattach')
                })
            }
              , nt = function(t) {
                var e = tt(t, nt);
                return d.extend(e, {
                    setEnabled: Y(t, 'setEnabled', nt),
                    setAnchor: Y(t, 'setAnchor', nt),
                    isEnabled: J(t, 'isEnabled'),
                    deleteEveryConnection: function() {
                        for (var e = 0, n = t.length; e < n; e++)
                            t[e].deleteEveryConnection()
                    },
                    delete: function() {
                        for (var e = 0, n = t.length; e < n; e++)
                            r.deleteEndpoint(t[e])
                    }
                })
            };
            this.select = function(t) {
                return (t = t || {}).scope = t.scope || '*',
                et(t.connections || r.getConnections(t, !0))
            }
            ,
            this.selectEndpoints = function(t) {
                (t = t || {}).scope = t.scope || '*';
                var e = !t.element && !t.source && !t.target
                  , n = e ? '*' : Z(t.element)
                  , i = e ? '*' : Z(t.source)
                  , r = e ? '*' : Z(t.target)
                  , o = Z(t.scope, !0)
                  , a = [];
                for (var s in b) {
                    var l = K(n, s, !0)
                      , c = K(i, s, !0)
                      , h = '*' !== i
                      , u = K(r, s, !0)
                      , p = '*' !== r;
                    if (l || c || u)
                        t: for (var d = 0, f = b[s].length; d < f; d++) {
                            var m = b[s][d];
                            if (K(o, m.scope, !0)) {
                                var g = h && i.length > 0 && !m.isSource
                                  , v = p && r.length > 0 && !m.isTarget;
                                if (g || v)
                                    continue t;
                                a.push(m)
                            }
                        }
                }
                return nt(a)
            }
            ,
            this.getAllConnections = function() {
                return x
            }
            ,
            this.getDefaultScope = function() {
                return T
            }
            ,
            this.getEndpoint = j,
            this.getEndpoints = function(t) {
                return b[p(t).id] || []
            }
            ,
            this.getDefaultEndpointType = function() {
                return d.Endpoint
            }
            ,
            this.getDefaultConnectionType = function() {
                return d.Connection
            }
            ,
            this.getId = B,
            this.draw = O,
            this.info = p,
            this.appendElement = I;
            var it = !1;
            this.isHoverSuspended = function() {
                return it
            }
            ,
            this.setHoverSuspended = function(t) {
                it = t
            }
            ,
            this.hide = function(t, e) {
                return U(t, 'none', e),
                r
            }
            ,
            this.idstamp = D;
            var rt = function(t) {
                if (!m && t) {
                    var e = r.getElement(t);
                    e.offsetParent && r.setContainer(e.offsetParent)
                }
            }
              , ot = r.manage = function(t, e, n) {
                return M[t] || (M[t] = {
                    el: e,
                    endpoints: [],
                    connections: []
                },
                M[t].info = at({
                    elId: t,
                    timestamp: E
                }),
                r.addClass(e, 'jtk-managed'),
                n || r.fire('manageElement', {
                    id: t,
                    info: M[t].info,
                    el: e
                })),
                M[t]
            }
              , at = (r.unmanage = function(t) {
                if (M[t]) {
                    var e = M[t].el;
                    r.removeClass(e, 'jtk-managed'),
                    delete M[t],
                    r.fire('unmanageElement', {
                        id: t,
                        el: e
                    })
                }
            }
            ,
            function(t) {
                var e, n = t.timestamp, i = t.recalc, o = t.offset, a = t.elId;
                return A && !n && (n = E),
                !i && n && n === S[a] ? {
                    o: t.offset || w[a],
                    s: C[a]
                } : (i || !o && null == w[a] ? null != (e = M[a] ? M[a].el : null) && (C[a] = r.getSize(e),
                w[a] = r.getOffset(e),
                S[a] = n) : (w[a] = o || w[a],
                null == C[a] && null != (e = M[a].el) && (C[a] = r.getSize(e)),
                S[a] = n),
                w[a] && !w[a].right && (w[a].right = w[a].left + C[a][0],
                w[a].bottom = w[a].top + C[a][1],
                w[a].width = C[a][0],
                w[a].height = C[a][1],
                w[a].centerx = w[a].left + w[a].width / 2,
                w[a].centery = w[a].top + w[a].height / 2),
                {
                    o: w[a],
                    s: C[a]
                })
            }
            );
            this.updateOffset = at,
            this.init = function() {
                y || (r.Defaults.Container && r.setContainer(r.Defaults.Container),
                r.anchorManager = new t.jsPlumb.AnchorManager({
                    jsPlumbInstance: r
                }),
                y = !0,
                r.fire('ready', r))
            }
            .bind(this),
            this.log = v,
            this.jsPlumbUIComponent = c,
            this.makeAnchor = function() {
                var e, i = function(e, n) {
                    if (t.jsPlumb.Anchors[e])
                        return new t.jsPlumb.Anchors[e](n);
                    if (!r.Defaults.DoNotThrowErrors)
                        throw {
                            msg: 'jsPlumb: unknown anchor type \'' + e + '\''
                        }
                };
                if (0 === arguments.length)
                    return null;
                var o = arguments[0]
                  , a = arguments[1]
                  , s = (arguments[2],
                null);
                if (o.compute && o.getOrientation)
                    return o;
                if ('string' == typeof o)
                    s = i(arguments[0], {
                        elementId: a,
                        jsPlumbInstance: r
                    });
                else if (n.isArray(o))
                    if (n.isArray(o[0]) || n.isString(o[0]))
                        2 === o.length && n.isObject(o[1]) ? n.isString(o[0]) ? (e = t.jsPlumb.extend({
                            elementId: a,
                            jsPlumbInstance: r
                        }, o[1]),
                        s = i(o[0], e)) : (e = t.jsPlumb.extend({
                            elementId: a,
                            jsPlumbInstance: r,
                            anchors: o[0]
                        }, o[1]),
                        s = new t.jsPlumb.DynamicAnchor(e)) : s = new d.DynamicAnchor({
                            anchors: o,
                            selector: null,
                            elementId: a,
                            jsPlumbInstance: r
                        });
                    else {
                        var l = {
                            x: o[0],
                            y: o[1],
                            orientation: o.length >= 4 ? [o[2], o[3]] : [0, 0],
                            offsets: o.length >= 6 ? [o[4], o[5]] : [0, 0],
                            elementId: a,
                            jsPlumbInstance: r,
                            cssClass: 7 === o.length ? o[6] : null
                        };
                        (s = new t.jsPlumb.Anchor(l)).clone = function() {
                            return new t.jsPlumb.Anchor(l)
                        }
                    }
                return s.id || (s.id = 'anchor_' + D()),
                s
            }
            ,
            this.makeAnchors = function(e, i, o) {
                for (var a = [], s = 0, l = e.length; s < l; s++)
                    'string' == typeof e[s] ? a.push(t.jsPlumb.Anchors[e[s]]({
                        elementId: i,
                        jsPlumbInstance: o
                    })) : n.isArray(e[s]) && a.push(r.makeAnchor(e[s], i, o));
                return a
            }
            ,
            this.makeDynamicAnchor = function(e, n) {
                return new t.jsPlumb.DynamicAnchor({
                    anchors: e,
                    selector: n,
                    elementId: null,
                    jsPlumbInstance: r
                })
            }
            ,
            this.targetEndpointDefinitions = {},
            this.sourceEndpointDefinitions = {};
            var st = function(e, i, o, a, s) {
                var l = new c(i)
                  , h = i._jsPlumb.EndpointDropHandler({
                    jsPlumb: r,
                    enabled: function() {
                        return e.def.enabled
                    },
                    isFull: function() {
                        var t = r.select({
                            target: e.id
                        }).length;
                        return e.def.maxConnections > 0 && t >= e.def.maxConnections
                    },
                    element: e.el,
                    elementId: e.id,
                    isSource: a,
                    isTarget: s,
                    addClass: function(t) {
                        r.addClass(e.el, t)
                    },
                    removeClass: function(t) {
                        r.removeClass(e.el, t)
                    },
                    onDrop: function(t) {
                        t.endpoints[0].anchor.unlock()
                    },
                    isDropAllowed: function() {
                        return l.isDropAllowed.apply(l, arguments)
                    },
                    isRedrop: function(t) {
                        return null != t.suspendedElement && null != t.suspendedEndpoint && t.suspendedEndpoint.element === e.el
                    },
                    getEndpoint: function(n) {
                        var o = e.def.endpoint;
                        if (null == o || null == o._jsPlumb) {
                            var a = r.deriveEndpointAndAnchorSpec(n.getType().join(' '), !0)
                              , s = a.endpoints ? t.jsPlumb.extend(i, {
                                endpoint: e.def.def.endpoint || a.endpoints[1]
                            }) : i;
                            a.anchors && (s = t.jsPlumb.extend(s, {
                                anchor: e.def.def.anchor || a.anchors[1]
                            })),
                            (o = r.addEndpoint(e.el, s))._mtNew = !0
                        }
                        if (i.uniqueEndpoint && (e.def.endpoint = o),
                        o.setDeleteOnEmpty(!0),
                        n.isDetachable() && o.initDraggable(),
                        null != o.anchor.positionFinder) {
                            var l = r.getUIPosition(arguments, r.getZoom())
                              , c = r.getOffset(e.el)
                              , h = r.getSize(e.el)
                              , u = null == l ? [0, 0] : o.anchor.positionFinder(l, c, h, o.anchor.constructorParams);
                            o.anchor.x = u[0],
                            o.anchor.y = u[1]
                        }
                        return o
                    },
                    maybeCleanup: function(t) {
                        t._mtNew && 0 === t.connections.length ? r.deleteObject({
                            endpoint: t
                        }) : delete t._mtNew
                    }
                })
                  , u = t.jsPlumb.dragEvents.drop;
                return o.scope = o.scope || i.scope || r.Defaults.Scope,
                o[u] = n.wrap(o[u], h, !0),
                o.rank = i.rank || 0,
                s && (o[t.jsPlumb.dragEvents.over] = function() {
                    return !0
                }
                ),
                !1 === i.allowLoopback && (o.canDrop = function(t) {
                    return t.getDragElement()._jsPlumbRelatedElement !== e.el
                }
                ),
                r.initDroppable(e.el, o, 'internal'),
                h
            };
            this.makeTarget = function(e, n, i) {
                var o = t.jsPlumb.extend({
                    _jsPlumb: this
                }, i);
                t.jsPlumb.extend(o, n);
                for (var a = o.maxConnections || -1, s = function(e) {
                    var n = p(e)
                      , i = n.id
                      , s = t.jsPlumb.extend({}, o.dropOptions || {})
                      , l = o.connectionType || 'default';
                    this.targetEndpointDefinitions[i] = this.targetEndpointDefinitions[i] || {},
                    rt(i),
                    n.el._isJsPlumbGroup && null == s.rank && (s.rank = -1);
                    var c = {
                        def: t.jsPlumb.extend({}, o),
                        uniqueEndpoint: o.uniqueEndpoint,
                        maxConnections: a,
                        enabled: !0
                    };
                    o.createEndpoint && (c.uniqueEndpoint = !0,
                    c.endpoint = r.addEndpoint(e, c.def),
                    c.endpoint.setDeleteOnEmpty(!1)),
                    n.def = c,
                    this.targetEndpointDefinitions[i][l] = c,
                    st(n, o, s, !0 === o.isSource, !0),
                    n.el._katavorioDrop[n.el._katavorioDrop.length - 1].targetDef = c
                }
                .bind(this), l = e.length && e.constructor !== String ? e : [e], c = 0, h = l.length; c < h; c++)
                    s(l[c]);
                return this
            }
            ,
            this.unmakeTarget = function(t, e) {
                var n = p(t);
                return r.destroyDroppable(n.el, 'internal'),
                e || delete this.targetEndpointDefinitions[n.id],
                this
            }
            ,
            this.makeSource = function(e, i, o) {
                var a = t.jsPlumb.extend({
                    _jsPlumb: this
                }, o);
                t.jsPlumb.extend(a, i);
                var s = a.connectionType || 'default'
                  , l = r.deriveEndpointAndAnchorSpec(s);
                a.endpoint = a.endpoint || l.endpoints[0],
                a.anchor = a.anchor || l.anchors[0];
                for (var c = a.maxConnections || -1, u = a.onMaxConnections, d = function(i) {
                    var o = i.id
                      , l = this.getElement(i.el);
                    this.sourceEndpointDefinitions[o] = this.sourceEndpointDefinitions[o] || {},
                    rt(o);
                    var p = {
                        def: t.jsPlumb.extend({}, a),
                        uniqueEndpoint: a.uniqueEndpoint,
                        maxConnections: c,
                        enabled: !0
                    };
                    a.createEndpoint && (p.uniqueEndpoint = !0,
                    p.endpoint = r.addEndpoint(e, p.def),
                    p.endpoint.setDeleteOnEmpty(!1)),
                    this.sourceEndpointDefinitions[o][s] = p,
                    i.def = p;
                    var d = t.jsPlumb.dragEvents.stop
                      , f = t.jsPlumb.dragEvents.drag
                      , m = t.jsPlumb.extend({}, a.dragOptions || {})
                      , g = m.drag
                      , v = m.stop
                      , y = null
                      , x = !1;
                    m.scope = m.scope || a.scope,
                    m[f] = n.wrap(m[f], (function() {
                        g && g.apply(this, arguments),
                        x = !1
                    }
                    )),
                    m[d] = n.wrap(m[d], function() {
                        if (v && v.apply(this, arguments),
                        this.currentlyDragging = !1,
                        null != y._jsPlumb) {
                            var t = a.anchor || this.Defaults.Anchor
                              , e = y.anchor
                              , n = y.connections[0]
                              , i = this.makeAnchor(t, o, this)
                              , s = y.element;
                            if (null != i.positionFinder) {
                                var l = r.getOffset(s)
                                  , c = this.getSize(s)
                                  , h = {
                                    left: l.left + e.x * c[0],
                                    top: l.top + e.y * c[1]
                                }
                                  , u = i.positionFinder(h, l, c, i.constructorParams);
                                i.x = u[0],
                                i.y = u[1]
                            }
                            y.setAnchor(i, !0),
                            y.repaint(),
                            this.repaint(y.elementId),
                            null != n && this.repaint(n.targetId)
                        }
                    }
                    .bind(this));
                    var b = function(e) {
                        if (3 !== e.which && 2 !== e.button) {
                            var p = this.sourceEndpointDefinitions[o][s];
                            if (p.enabled) {
                                if (o = this.getId(this.getElement(i.el)),
                                a.filter)
                                    if (!1 === (n.isString(a.filter) ? function(t, e, n, i, r) {
                                        for (var o = t.target || t.srcElement, a = !1, s = i.getSelector(e, n), l = 0; l < s.length; l++)
                                            if (s[l] === o) {
                                                a = !0;
                                                break
                                            }
                                        return r ? !a : a
                                    }(e, i.el, a.filter, this, a.filterExclude) : a.filter(e, i.el)))
                                        return;
                                var d = this.select({
                                    source: o
                                }).length;
                                if (p.maxConnections >= 0 && d >= p.maxConnections)
                                    return u && u({
                                        element: i.el,
                                        maxConnections: c
                                    }, e),
                                    !1;
                                var f = t.jsPlumb.getPositionOnElement(e, l, h)
                                  , g = {};
                                t.jsPlumb.extend(g, p.def),
                                g.isTemporarySource = !0,
                                g.anchor = [f[0], f[1], 0, 0],
                                g.dragOptions = m,
                                p.def.scope && (g.scope = p.def.scope),
                                y = this.addEndpoint(o, g),
                                x = !0,
                                y.setDeleteOnEmpty(!0),
                                p.uniqueEndpoint && (p.endpoint ? y.finalEndpoint = p.endpoint : (p.endpoint = y,
                                y.setDeleteOnEmpty(!1)));
                                var v = function() {
                                    r.off(y.canvas, 'mouseup', v),
                                    r.off(i.el, 'mouseup', v),
                                    x && (x = !1,
                                    r.deleteEndpoint(y))
                                };
                                r.on(y.canvas, 'mouseup', v),
                                r.on(i.el, 'mouseup', v);
                                var b = {};
                                if (p.def.extract)
                                    for (var _ in p.def.extract) {
                                        var M = (e.srcElement || e.target).getAttribute(_);
                                        M && (b[p.def.extract[_]] = M)
                                    }
                                r.trigger(y.canvas, 'mousedown', e, b),
                                n.consume(e)
                            }
                        }
                    }
                    .bind(this);
                    this.on(i.el, 'mousedown', b),
                    p.trigger = b,
                    a.filter && (n.isString(a.filter) || n.isFunction(a.filter)) && r.setDragFilter(i.el, a.filter);
                    var _ = t.jsPlumb.extend({}, a.dropOptions || {});
                    st(i, a, _, !0, !0 === a.isTarget)
                }
                .bind(this), f = e.length && e.constructor !== String ? e : [e], m = 0, g = f.length; m < g; m++)
                    d(p(f[m]));
                return this
            }
            ,
            this.unmakeSource = function(t, e, n) {
                var i = p(t);
                r.destroyDroppable(i.el, 'internal');
                var o = this.sourceEndpointDefinitions[i.id];
                if (o)
                    for (var a in o)
                        if (null == e || e === a) {
                            var s = o[a].trigger;
                            s && r.off(i.el, 'mousedown', s),
                            n || delete this.sourceEndpointDefinitions[i.id][a]
                        }
                return this
            }
            ,
            this.unmakeEverySource = function() {
                for (var t in this.sourceEndpointDefinitions)
                    r.unmakeSource(t, null, !0);
                return this.sourceEndpointDefinitions = {},
                this
            }
            ;
            var lt = function(t, e, i) {
                e = n.isArray(e) ? e : [e];
                var r = B(t);
                i = i || 'default';
                for (var o = 0; o < e.length; o++) {
                    var a = this[e[o]][r];
                    if (a && a[i])
                        return a[i].def.scope || this.Defaults.Scope
                }
            }
            .bind(this)
              , ct = function(t, e, i, r) {
                i = n.isArray(i) ? i : [i];
                var o = B(t);
                r = r || 'default';
                for (var a = 0; a < i.length; a++) {
                    var s = this[i[a]][o];
                    s && s[r] && (s[r].def.scope = e)
                }
            }
            .bind(this);
            this.getScope = function(t, e) {
                return lt(t, ['sourceEndpointDefinitions', 'targetEndpointDefinitions'])
            }
            ,
            this.getSourceScope = function(t) {
                return lt(t, 'sourceEndpointDefinitions')
            }
            ,
            this.getTargetScope = function(t) {
                return lt(t, 'targetEndpointDefinitions')
            }
            ,
            this.setScope = function(t, e, n) {
                this.setSourceScope(t, e, n),
                this.setTargetScope(t, e, n)
            }
            ,
            this.setSourceScope = function(t, e, n) {
                ct(t, e, 'sourceEndpointDefinitions', n),
                this.setDragScope(t, e)
            }
            ,
            this.setTargetScope = function(t, e, n) {
                ct(t, e, 'targetEndpointDefinitions', n),
                this.setDropScope(t, e)
            }
            ,
            this.unmakeEveryTarget = function() {
                for (var t in this.targetEndpointDefinitions)
                    r.unmakeTarget(t, !0);
                return this.targetEndpointDefinitions = {},
                this
            }
            ;
            var ht = function(t, e, i, o, a) {
                var s, l, c, h = 'source' === t ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;
                if (a = a || 'default',
                e.length && !n.isString(e)) {
                    s = [];
                    for (var u = 0, d = e.length; u < d; u++)
                        h[(l = p(e[u])).id] && h[l.id][a] && (s[u] = h[l.id][a].enabled,
                        c = o ? !s[u] : i,
                        h[l.id][a].enabled = c,
                        r[c ? 'removeClass' : 'addClass'](l.el, 'jtk-' + t + '-disabled'))
                } else {
                    var f = (l = p(e)).id;
                    h[f] && h[f][a] && (s = h[f][a].enabled,
                    c = o ? !s : i,
                    h[f][a].enabled = c,
                    r[c ? 'removeClass' : 'addClass'](l.el, 'jtk-' + t + '-disabled'))
                }
                return s
            }
            .bind(this)
              , ut = function(t, e) {
                return n.isString(t) || !t.length ? e.apply(this, [t]) : t.length ? e.apply(this, [t[0]]) : void 0
            }
            .bind(this);
            this.toggleSourceEnabled = function(t, e) {
                return ht('source', t, null, !0, e),
                this.isSourceEnabled(t, e)
            }
            ,
            this.setSourceEnabled = function(t, e, n) {
                return ht('source', t, e, null, n)
            }
            ,
            this.isSource = function(t, e) {
                return e = e || 'default',
                ut(t, function(t) {
                    var n = this.sourceEndpointDefinitions[p(t).id];
                    return null != n && null != n[e]
                }
                .bind(this))
            }
            ,
            this.isSourceEnabled = function(t, e) {
                return e = e || 'default',
                ut(t, function(t) {
                    var n = this.sourceEndpointDefinitions[p(t).id];
                    return n && n[e] && !0 === n[e].enabled
                }
                .bind(this))
            }
            ,
            this.toggleTargetEnabled = function(t, e) {
                return ht('target', t, null, !0, e),
                this.isTargetEnabled(t, e)
            }
            ,
            this.isTarget = function(t, e) {
                return e = e || 'default',
                ut(t, function(t) {
                    var n = this.targetEndpointDefinitions[p(t).id];
                    return null != n && null != n[e]
                }
                .bind(this))
            }
            ,
            this.isTargetEnabled = function(t, e) {
                return e = e || 'default',
                ut(t, function(t) {
                    var n = this.targetEndpointDefinitions[p(t).id];
                    return n && n[e] && !0 === n[e].enabled
                }
                .bind(this))
            }
            ,
            this.setTargetEnabled = function(t, e, n) {
                return ht('target', t, e, null, n)
            }
            ,
            this.ready = function(t) {
                r.bind('ready', t)
            }
            ;
            var pt = function(t, e) {
                if ('object' == typeof t && t.length)
                    for (var n = 0, i = t.length; n < i; n++)
                        e(t[n]);
                else
                    e(t);
                return r
            };
            this.repaint = function(t, e, n) {
                return pt(t, (function(t) {
                    O(t, e, n)
                }
                ))
            }
            ,
            this.revalidate = function(t, e, n) {
                return pt(t, (function(t) {
                    var i = n ? t : r.getId(t);
                    r.updateOffset({
                        elId: i,
                        recalc: !0,
                        timestamp: e
                    });
                    var o = r.getDragManager();
                    o && o.updateOffsets(i),
                    r.repaint(t)
                }
                ))
            }
            ,
            this.repaintEverything = function() {
                var t, e = i();
                for (t in b)
                    r.updateOffset({
                        elId: t,
                        recalc: !0,
                        timestamp: e
                    });
                for (t in b)
                    O(t, null, e);
                return this
            }
            ,
            this.removeAllEndpoints = function(t, e, n) {
                n = n || [];
                var i = function(t) {
                    var o, a, s = p(t), l = b[s.id];
                    if (l)
                        for (n.push(s),
                        o = 0,
                        a = l.length; o < a; o++)
                            r.deleteEndpoint(l[o], !1);
                    if (delete b[s.id],
                    e && s.el && 3 !== s.el.nodeType && 8 !== s.el.nodeType)
                        for (o = 0,
                        a = s.el.childNodes.length; o < a; o++)
                            i(s.el.childNodes[o])
                };
                return i(t),
                this
            }
            ;
            var dt = function(t, e) {
                r.removeAllEndpoints(t.id, !0, e);
                for (var n = r.getDragManager(), i = function(t) {
                    n && n.elementRemoved(t.id),
                    r.anchorManager.clearFor(t.id),
                    r.anchorManager.removeFloatingConnection(t.id),
                    r.isSource(t.el) && r.unmakeSource(t.el),
                    r.isTarget(t.el) && r.unmakeTarget(t.el),
                    r.destroyDraggable(t.el),
                    r.destroyDroppable(t.el),
                    delete r.floatingConnections[t.id],
                    delete M[t.id],
                    delete w[t.id],
                    t.el && (r.removeElement(t.el),
                    t.el._jsPlumb = null)
                }, o = 1; o < e.length; o++)
                    i(e[o]);
                i(t)
            };
            this.remove = function(t, e) {
                var n = p(t)
                  , i = [];
                return n.text && n.el.parentNode ? n.el.parentNode.removeChild(n.el) : n.id && r.batch((function() {
                    dt(n, i)
                }
                ), !0 === e),
                r
            }
            ,
            this.empty = function(t, e) {
                var n = []
                  , i = function(t, e) {
                    var r = p(t);
                    if (r.text)
                        r.el.parentNode.removeChild(r.el);
                    else if (r.el) {
                        for (; r.el.childNodes.length > 0; )
                            i(r.el.childNodes[0]);
                        e || dt(r, n)
                    }
                };
                return r.batch((function() {
                    i(t, !0)
                }
                ), !1 === e),
                r
            }
            ,
            this.reset = function(t) {
                r.silently(function() {
                    it = !1,
                    r.removeAllGroups(),
                    r.removeGroupManager(),
                    r.deleteEveryEndpoint(),
                    t || r.unbind(),
                    this.targetEndpointDefinitions = {},
                    this.sourceEndpointDefinitions = {},
                    x.length = 0,
                    this.doReset && this.doReset()
                }
                .bind(this))
            }
            ;
            var ft = function(t) {
                t.canvas && t.canvas.parentNode && t.canvas.parentNode.removeChild(t.canvas),
                t.cleanup(),
                t.destroy()
            };
            this.clear = function() {
                r.select().each(ft),
                r.selectEndpoints().each(ft),
                b = {},
                _ = {}
            }
            ,
            this.setDefaultScope = function(t) {
                return T = t,
                r
            }
            ,
            this.deriveEndpointAndAnchorSpec = function(t, e) {
                for (var n = ((e ? '' : 'default ') + t).split(/[\s]/), i = null, o = null, a = null, s = null, l = 0; l < n.length; l++) {
                    var c = r.getType(n[l], 'connection');
                    c && (c.endpoints && (i = c.endpoints),
                    c.endpoint && (o = c.endpoint),
                    c.anchors && (s = c.anchors),
                    c.anchor && (a = c.anchor))
                }
                return {
                    endpoints: i || [o, o],
                    anchors: s || [a, a]
                }
            }
            ,
            this.setId = function(t, e, i) {
                var r;
                n.isString(t) ? r = t : (t = this.getElement(t),
                r = this.getId(t));
                var o = this.getConnections({
                    source: r,
                    scope: '*'
                }, !0)
                  , a = this.getConnections({
                    target: r,
                    scope: '*'
                }, !0);
                e = '' + e,
                i ? t = this.getElement(e) : (t = this.getElement(r),
                this.setAttribute(t, 'id', e)),
                b[e] = b[r] || [];
                for (var s = 0, l = b[e].length; s < l; s++)
                    b[e][s].setElementId(e),
                    b[e][s].setReferenceElement(t);
                delete b[r],
                this.sourceEndpointDefinitions[e] = this.sourceEndpointDefinitions[r],
                delete this.sourceEndpointDefinitions[r],
                this.targetEndpointDefinitions[e] = this.targetEndpointDefinitions[r],
                delete this.targetEndpointDefinitions[r],
                this.anchorManager.changeId(r, e);
                var c = this.getDragManager();
                c && c.changeId(r, e),
                M[e] = M[r],
                delete M[r];
                var h = function(n, i, r) {
                    for (var o = 0, a = n.length; o < a; o++)
                        n[o].endpoints[i].setElementId(e),
                        n[o].endpoints[i].setReferenceElement(t),
                        n[o][r + 'Id'] = e,
                        n[o][r] = t
                };
                h(o, 0, 'source'),
                h(a, 1, 'target'),
                this.repaint(e)
            }
            ,
            this.setDebugLog = function(t) {
                v = t
            }
            ,
            this.setSuspendDrawing = function(t, e) {
                var n = A;
                return A = t,
                E = t ? (new Date).getTime() : null,
                e && this.repaintEverything(),
                n
            }
            ,
            this.isSuspendDrawing = function() {
                return A
            }
            ,
            this.getSuspendedAt = function() {
                return E
            }
            ,
            this.batch = function(t, e) {
                var i = this.isSuspendDrawing();
                i || this.setSuspendDrawing(!0);
                try {
                    t()
                } catch (t) {
                    n.log('Function run while suspended failed', t)
                }
                i || this.setSuspendDrawing(!1, !e)
            }
            ,
            this.doWhileSuspended = this.batch,
            this.getCachedData = function(t) {
                var e = w[t];
                return e ? {
                    o: e,
                    s: C[t]
                } : at({
                    elId: t
                })
            }
            ,
            this.timestamp = i,
            this.show = function(t, e) {
                return U(t, 'block', e),
                r
            }
            ,
            this.toggleVisible = function(t, e) {
                var n = null;
                e && (n = function(t) {
                    var e = t.isVisible();
                    t.setVisible(!e)
                }
                ),
                R(t, (function(t) {
                    var e = t.isVisible();
                    t.setVisible(!e)
                }
                ), n)
            }
            ,
            this.addListener = this.bind;
            var mt = [];
            this.registerFloatingConnection = function(t, e, i) {
                mt[t.id] = e,
                n.addToList(b, t.id, i)
            }
            ,
            this.getFloatingConnectionFor = function(t) {
                return mt[t]
            }
            ,
            this.listManager = new t.jsPlumbListManager(this)
        }
        ;
        n.extend(t.jsPlumbInstance, n.EventGenerator, {
            setAttribute: function(t, e, n) {
                this.setAttribute(t, e, n)
            },
            getAttribute: function(e, n) {
                return this.getAttribute(t.jsPlumb.getElement(e), n)
            },
            convertToFullOverlaySpec: function(t) {
                return n.isString(t) && (t = [t, {}]),
                t[1].id = t[1].id || n.uuid(),
                t
            },
            registerConnectionType: function(e, n) {
                if (this._connectionTypes[e] = t.jsPlumb.extend({}, n),
                n.overlays) {
                    for (var i = {}, r = 0; r < n.overlays.length; r++) {
                        var o = this.convertToFullOverlaySpec(n.overlays[r]);
                        i[o[1].id] = o
                    }
                    this._connectionTypes[e].overlays = i
                }
            },
            registerConnectionTypes: function(t) {
                for (var e in t)
                    this.registerConnectionType(e, t[e])
            },
            registerEndpointType: function(e, n) {
                if (this._endpointTypes[e] = t.jsPlumb.extend({}, n),
                n.overlays) {
                    for (var i = {}, r = 0; r < n.overlays.length; r++) {
                        var o = this.convertToFullOverlaySpec(n.overlays[r]);
                        i[o[1].id] = o
                    }
                    this._endpointTypes[e].overlays = i
                }
            },
            registerEndpointTypes: function(t) {
                for (var e in t)
                    this.registerEndpointType(e, t[e])
            },
            getType: function(t, e) {
                return 'connection' === e ? this._connectionTypes[t] : this._endpointTypes[t]
            },
            setIdChanged: function(t, e) {
                this.setId(t, e, !0)
            },
            setParent: function(t, e) {
                var n = this.getElement(t)
                  , i = this.getId(n)
                  , r = this.getElement(e)
                  , o = this.getId(r)
                  , a = this.getDragManager();
                n.parentNode.removeChild(n),
                r.appendChild(n),
                a && a.setParent(n, i, r, o)
            },
            extend: function(t, e, n) {
                var i;
                if (n)
                    for (i = 0; i < n.length; i++)
                        t[n[i]] = e[n[i]];
                else
                    for (i in e)
                        t[i] = e[i];
                return t
            },
            floatingConnections: {},
            getFloatingAnchorIndex: function(t) {
                return t.endpoints[0].isFloating() ? 0 : t.endpoints[1].isFloating() ? 1 : -1
            },
            proxyConnection: function(t, e, n, i, r, o) {
                var a, s = t.endpoints[e].elementId, l = t.endpoints[e];
                t.proxies = t.proxies || [],
                (a = t.proxies[e] ? t.proxies[e].ep : this.addEndpoint(n, {
                    endpoint: r(t, e),
                    anchor: o(t, e),
                    parameters: {
                        isProxyEndpoint: !0
                    }
                })).setDeleteOnEmpty(!0),
                t.proxies[e] = {
                    ep: a,
                    originalEp: l
                },
                0 === e ? this.anchorManager.sourceChanged(s, i, t, n) : (this.anchorManager.updateOtherEndpoint(t.endpoints[0].elementId, s, i, t),
                t.target = n,
                t.targetId = i),
                l.detachFromConnection(t, null, !0),
                a.connections = [t],
                t.endpoints[e] = a,
                l.setVisible(!1),
                t.setVisible(!0),
                this.revalidate(n)
            },
            unproxyConnection: function(t, e, n) {
                if (null != t._jsPlumb && null != t.proxies && null != t.proxies[e]) {
                    var i = t.proxies[e].originalEp.element
                      , r = t.proxies[e].originalEp.elementId;
                    t.endpoints[e] = t.proxies[e].originalEp,
                    0 === e ? this.anchorManager.sourceChanged(n, r, t, i) : (this.anchorManager.updateOtherEndpoint(t.endpoints[0].elementId, n, r, t),
                    t.target = i,
                    t.targetId = r),
                    t.proxies[e].ep.detachFromConnection(t, null),
                    t.proxies[e].originalEp.addConnection(t),
                    t.isVisible() && t.proxies[e].originalEp.setVisible(!0),
                    delete t.proxies[e]
                }
            }
        });
        var d = new p;
        t.jsPlumb = d,
        d.getInstance = function(t, e) {
            var n = new p(t);
            if (e)
                for (var i in e)
                    n[i] = e[i];
            return n.init(),
            n
        }
        ,
        d.each = function(t, e) {
            if (null != t)
                if ('string' == typeof t)
                    e(d.getElement(t));
                else if (null != t.length)
                    for (var n = 0; n < t.length; n++)
                        e(d.getElement(t[n]));
                else
                    e(t)
        }
        ,
        e.jsPlumb = d
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , e = t.jsPlumb
          , n = t.jsPlumbUtil;
        e.OverlayCapableJsPlumbUIComponent = function(e) {
            t.jsPlumbUIComponent.apply(this, arguments),
            this._jsPlumb.overlays = {},
            this._jsPlumb.overlayPositions = {},
            e.label && (this.getDefaultType().overlays.__label = ['Label', {
                label: e.label,
                location: e.labelLocation || this.defaultLabelLocation || .5,
                labelStyle: e.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
                id: '__label'
            }]),
            this.setListenerComponent = function(t) {
                if (this._jsPlumb)
                    for (var e in this._jsPlumb.overlays)
                        this._jsPlumb.overlays[e].setListenerComponent(t)
            }
        }
        ,
        e.OverlayCapableJsPlumbUIComponent.applyType = function(t, e) {
            if (e.overlays) {
                var n, i = {};
                for (n in e.overlays) {
                    var r = t._jsPlumb.overlays[e.overlays[n][1].id];
                    if (r)
                        r.updateFrom(e.overlays[n][1]),
                        i[e.overlays[n][1].id] = !0;
                    else {
                        var o = t.getCachedTypeItem('overlay', e.overlays[n][1].id);
                        null != o ? (o.reattach(t._jsPlumb.instance, t),
                        o.setVisible(!0),
                        o.updateFrom(e.overlays[n][1]),
                        t._jsPlumb.overlays[o.id] = o) : o = t.addOverlay(e.overlays[n], !0),
                        i[o.id] = !0
                    }
                }
                for (n in t._jsPlumb.overlays)
                    null == i[t._jsPlumb.overlays[n].id] && t.removeOverlay(t._jsPlumb.overlays[n].id, !0)
            }
        }
        ,
        n.extend(e.OverlayCapableJsPlumbUIComponent, t.jsPlumbUIComponent, {
            setHover: function(t, e) {
                if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
                    for (var n in this._jsPlumb.overlays)
                        this._jsPlumb.overlays[n][t ? 'addClass' : 'removeClass'](this._jsPlumb.instance.hoverClass)
            },
            addOverlay: function(t, i) {
                var r = function(t, i) {
                    var r = null;
                    if (n.isArray(i)) {
                        var o = i[0]
                          , a = e.extend({
                            component: t,
                            _jsPlumb: t._jsPlumb.instance
                        }, i[1]);
                        3 === i.length && e.extend(a, i[2]),
                        r = new (e.Overlays[t._jsPlumb.instance.getRenderMode()][o])(a)
                    } else
                        r = i.constructor === String ? new (e.Overlays[t._jsPlumb.instance.getRenderMode()][i])({
                            component: t,
                            _jsPlumb: t._jsPlumb.instance
                        }) : i;
                    return r.id = r.id || n.uuid(),
                    t.cacheTypeItem('overlay', r, r.id),
                    t._jsPlumb.overlays[r.id] = r,
                    r
                }(this, t);
                if (this.getData && 'Label' === r.type && n.isArray(t)) {
                    var o = this.getData()
                      , a = t[1];
                    if (o) {
                        var s = a.labelLocationAttribute || 'labelLocation'
                          , l = o ? o[s] : null;
                        l && (r.loc = l)
                    }
                }
                return i || this.repaint(),
                r
            },
            getOverlay: function(t) {
                return this._jsPlumb.overlays[t]
            },
            getOverlays: function() {
                return this._jsPlumb.overlays
            },
            hideOverlay: function(t) {
                var e = this.getOverlay(t);
                e && e.hide()
            },
            hideOverlays: function() {
                for (var t in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[t].hide()
            },
            showOverlay: function(t) {
                var e = this.getOverlay(t);
                e && e.show()
            },
            showOverlays: function() {
                for (var t in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[t].show()
            },
            removeAllOverlays: function(t) {
                for (var e in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[e].cleanup && this._jsPlumb.overlays[e].cleanup();
                this._jsPlumb.overlays = {},
                this._jsPlumb.overlayPositions = null,
                this._jsPlumb.overlayPlacements = {},
                t || this.repaint()
            },
            removeOverlay: function(t, e) {
                var n = this._jsPlumb.overlays[t];
                n && (n.setVisible(!1),
                !e && n.cleanup && n.cleanup(),
                delete this._jsPlumb.overlays[t],
                this._jsPlumb.overlayPositions && delete this._jsPlumb.overlayPositions[t],
                this._jsPlumb.overlayPlacements && delete this._jsPlumb.overlayPlacements[t])
            },
            removeOverlays: function() {
                for (var t = 0, e = arguments.length; t < e; t++)
                    this.removeOverlay(arguments[t])
            },
            moveParent: function(t) {
                if (this.bgCanvas && (this.bgCanvas.parentNode.removeChild(this.bgCanvas),
                t.appendChild(this.bgCanvas)),
                this.canvas && this.canvas.parentNode)
                    for (var e in this.canvas.parentNode.removeChild(this.canvas),
                    t.appendChild(this.canvas),
                    this._jsPlumb.overlays)
                        if (this._jsPlumb.overlays[e].isAppendedAtTopLevel) {
                            var n = this._jsPlumb.overlays[e].getElement();
                            n.parentNode.removeChild(n),
                            t.appendChild(n)
                        }
            },
            getLabel: function() {
                var t = this.getOverlay('__label');
                return null != t ? t.getLabel() : null
            },
            getLabelOverlay: function() {
                return this.getOverlay('__label')
            },
            setLabel: function(t) {
                var n = this.getOverlay('__label');
                n ? t.constructor === String || t.constructor === Function ? n.setLabel(t) : (t.label && n.setLabel(t.label),
                t.location && n.setLocation(t.location)) : (n = function(t, n) {
                    var i = {
                        cssClass: n.cssClass,
                        labelStyle: t.labelStyle,
                        id: '__label',
                        component: t,
                        _jsPlumb: t._jsPlumb.instance
                    }
                      , r = e.extend(i, n);
                    return new (e.Overlays[t._jsPlumb.instance.getRenderMode()].Label)(r)
                }(this, t.constructor === String || t.constructor === Function ? {
                    label: t
                } : t),
                this._jsPlumb.overlays.__label = n);
                this._jsPlumb.instance.isSuspendDrawing() || this.repaint()
            },
            cleanup: function(t) {
                for (var e in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[e].cleanup(t),
                    this._jsPlumb.overlays[e].destroy(t);
                t && (this._jsPlumb.overlays = {},
                this._jsPlumb.overlayPositions = null)
            },
            setVisible: function(t) {
                this[t ? 'showOverlays' : 'hideOverlays']()
            },
            setAbsoluteOverlayPosition: function(t, e) {
                this._jsPlumb.overlayPositions[t.id] = e
            },
            getAbsoluteOverlayPosition: function(t) {
                return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[t.id] : null
            },
            _clazzManip: function(t, e, n) {
                if (!n)
                    for (var i in this._jsPlumb.overlays)
                        this._jsPlumb.overlays[i][t + 'Class'](e)
            },
            addClass: function(t, e) {
                this._clazzManip('add', t, e)
            },
            removeClass: function(t, e) {
                this._clazzManip('remove', t, e)
            }
        })
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil
          , n = function(t, e, n) {
            var i = !1;
            return {
                drag: function() {
                    if (i)
                        return i = !1,
                        !0;
                    if (e.element) {
                        var r = n.getUIPosition(arguments, n.getZoom());
                        null != r && n.setPosition(e.element, r),
                        n.repaint(e.element, r),
                        t.paint({
                            anchorPoint: t.anchor.getCurrentLocation({
                                element: t
                            })
                        })
                    }
                },
                stopDrag: function() {
                    i = !0
                }
            }
        }
          , i = function(t, e, n, i) {
            var r = e.createElement('div', {
                position: 'absolute'
            });
            e.appendElement(r);
            var o = e.getId(r);
            e.setPosition(r, n),
            r.style.width = i[0] + 'px',
            r.style.height = i[1] + 'px',
            e.manage(o, r, !0),
            t.id = o,
            t.element = r
        }
          , r = function(e, n, i, r, o, a, s, l) {
            return s({
                paintStyle: e,
                endpoint: i,
                anchor: new t.FloatingAnchor({
                    reference: n,
                    referenceCanvas: r,
                    jsPlumbInstance: a
                }),
                source: o,
                scope: l
            })
        }
          , o = ['connectorStyle', 'connectorHoverStyle', 'connectorOverlays', 'connector', 'connectionType', 'connectorClass', 'connectorHoverClass']
          , a = function(t, e) {
            var n = 0;
            if (null != e)
                for (var i = 0; i < t.connections.length; i++)
                    if (t.connections[i].sourceId === e || t.connections[i].targetId === e) {
                        n = i;
                        break
                    }
            return t.connections[n]
        };
        t.Endpoint = function(s) {
            var l = s._jsPlumb
              , c = s.newConnection
              , h = s.newEndpoint;
            this.idPrefix = '_jsplumb_e_',
            this.defaultLabelLocation = [.5, .5],
            this.defaultOverlayKeys = ['Overlays', 'EndpointOverlays'],
            t.OverlayCapableJsPlumbUIComponent.apply(this, arguments),
            this.appendToDefaultType({
                connectionType: s.connectionType,
                maxConnections: null == s.maxConnections ? this._jsPlumb.instance.Defaults.MaxConnections : s.maxConnections,
                paintStyle: s.endpointStyle || s.paintStyle || s.style || this._jsPlumb.instance.Defaults.EndpointStyle || t.Defaults.EndpointStyle,
                hoverPaintStyle: s.endpointHoverStyle || s.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || t.Defaults.EndpointHoverStyle,
                connectorStyle: s.connectorStyle,
                connectorHoverStyle: s.connectorHoverStyle,
                connectorClass: s.connectorClass,
                connectorHoverClass: s.connectorHoverClass,
                connectorOverlays: s.connectorOverlays,
                connector: s.connector,
                connectorTooltip: s.connectorTooltip
            }),
            this._jsPlumb.enabled = !(!1 === s.enabled),
            this._jsPlumb.visible = !0,
            this.element = t.getElement(s.source),
            this._jsPlumb.uuid = s.uuid,
            this._jsPlumb.floatingEndpoint = null;
            var u = null;
            this._jsPlumb.uuid && (s.endpointsByUUID[this._jsPlumb.uuid] = this),
            this.elementId = s.elementId,
            this.dragProxy = s.dragProxy,
            this._jsPlumb.connectionCost = s.connectionCost,
            this._jsPlumb.connectionsDirected = s.connectionsDirected,
            this._jsPlumb.currentAnchorClass = '',
            this._jsPlumb.events = {};
            var p = !0 === s.deleteOnEmpty;
            this.setDeleteOnEmpty = function(t) {
                p = t
            }
            ;
            var d = function() {
                var e = l.endpointAnchorClassPrefix + '-' + this._jsPlumb.currentAnchorClass;
                this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
                var n = l.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? '-' + this._jsPlumb.currentAnchorClass : '');
                this.removeClass(e),
                this.addClass(n),
                t.updateClasses(this.element, n, e)
            }
            .bind(this);
            this.prepareAnchor = function(t) {
                var e = this._jsPlumb.instance.makeAnchor(t, this.elementId, l);
                return e.bind('anchorChanged', function(t) {
                    this.fire('anchorChanged', {
                        endpoint: this,
                        anchor: t
                    }),
                    d()
                }
                .bind(this)),
                e
            }
            ,
            this.setPreparedAnchor = function(t, e) {
                return this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId),
                this.anchor = t,
                d(),
                e || this._jsPlumb.instance.repaint(this.elementId),
                this
            }
            ,
            this.setAnchor = function(t, e) {
                var n = this.prepareAnchor(t);
                return this.setPreparedAnchor(n, e),
                this
            }
            ;
            var f = function(t) {
                if (this.connections.length > 0)
                    for (var e = 0; e < this.connections.length; e++)
                        this.connections[e].setHover(t, !1);
                else
                    this.setHover(t)
            }
            .bind(this);
            this.bind('mouseover', (function() {
                f(!0)
            }
            )),
            this.bind('mouseout', (function() {
                f(!1)
            }
            )),
            s._transient || this._jsPlumb.instance.anchorManager.add(this, this.elementId),
            this.prepareEndpoint = function(n, i) {
                var r, o = function(e, n) {
                    var i = l.getRenderMode();
                    if (t.Endpoints[i][e])
                        return new t.Endpoints[i][e](n);
                    if (!l.Defaults.DoNotThrowErrors)
                        throw {
                            msg: 'jsPlumb: unknown endpoint type \'' + e + '\''
                        }
                }, a = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: s.cssClass,
                    container: s.container,
                    tooltip: s.tooltip,
                    connectorTooltip: s.connectorTooltip,
                    endpoint: this
                };
                return e.isString(n) ? r = o(n, a) : e.isArray(n) ? (a = e.merge(n[1], a),
                r = o(n[0], a)) : r = n.clone(),
                r.clone = function() {
                    return e.isString(n) ? o(n, a) : e.isArray(n) ? (a = e.merge(n[1], a),
                    o(n[0], a)) : void 0
                }
                .bind(this),
                r.typeId = i,
                r
            }
            ,
            this.setEndpoint = function(t, e) {
                var n = this.prepareEndpoint(t);
                this.setPreparedEndpoint(n, !0)
            }
            ,
            this.setPreparedEndpoint = function(t, e) {
                null != this.endpoint && (this.endpoint.cleanup(),
                this.endpoint.destroy()),
                this.endpoint = t,
                this.type = this.endpoint.type,
                this.canvas = this.endpoint.canvas
            }
            ,
            t.extend(this, s, o),
            this.isSource = s.isSource || !1,
            this.isTemporarySource = s.isTemporarySource || !1,
            this.isTarget = s.isTarget || !1,
            this.connections = s.connections || [],
            this.connectorPointerEvents = s['connector-pointer-events'],
            this.scope = s.scope || l.getDefaultScope(),
            this.timestamp = null,
            this.reattachConnections = s.reattach || l.Defaults.ReattachConnections,
            this.connectionsDetachable = l.Defaults.ConnectionsDetachable,
            !1 !== s.connectionsDetachable && !1 !== s.detachable || (this.connectionsDetachable = !1),
            this.dragAllowedWhenFull = !1 !== s.dragAllowedWhenFull,
            s.onMaxConnections && this.bind('maxConnections', s.onMaxConnections),
            this.addConnection = function(t) {
                this.connections.push(t),
                this[(this.connections.length > 0 ? 'add' : 'remove') + 'Class'](l.endpointConnectedClass),
                this[(this.isFull() ? 'add' : 'remove') + 'Class'](l.endpointFullClass)
            }
            ,
            this.detachFromConnection = function(t, e, n) {
                (e = null == e ? this.connections.indexOf(t) : e) >= 0 && (this.connections.splice(e, 1),
                this[(this.connections.length > 0 ? 'add' : 'remove') + 'Class'](l.endpointConnectedClass),
                this[(this.isFull() ? 'add' : 'remove') + 'Class'](l.endpointFullClass)),
                !n && p && 0 === this.connections.length && l.deleteObject({
                    endpoint: this,
                    fireEvent: !1,
                    deleteAttachedObjects: !0 !== n
                })
            }
            ,
            this.deleteEveryConnection = function(t) {
                for (var e = this.connections.length, n = 0; n < e; n++)
                    l.deleteConnection(this.connections[0], t)
            }
            ,
            this.detachFrom = function(t, e, n) {
                for (var i = [], r = 0; r < this.connections.length; r++)
                    this.connections[r].endpoints[1] !== t && this.connections[r].endpoints[0] !== t || i.push(this.connections[r]);
                for (var o = 0, a = i.length; o < a; o++)
                    l.deleteConnection(i[0]);
                return this
            }
            ,
            this.getElement = function() {
                return this.element
            }
            ,
            this.setElement = function(n) {
                var i = this._jsPlumb.instance.getId(n)
                  , r = this.elementId;
                return e.removeWithFunction(s.endpointsByElement[this.elementId], function(t) {
                    return t.id === this.id
                }
                .bind(this)),
                this.element = t.getElement(n),
                this.elementId = l.getId(this.element),
                l.anchorManager.rehomeEndpoint(this, r, this.element),
                l.dragManager.endpointAdded(this.element),
                e.addToList(s.endpointsByElement, i, this),
                this
            }
            ,
            this.makeInPlaceCopy = function() {
                var t = this.anchor.getCurrentLocation({
                    element: this
                })
                  , e = this.anchor.getOrientation(this)
                  , n = this.anchor.getCssClass()
                  , i = {
                    bind: function() {},
                    compute: function() {
                        return [t[0], t[1]]
                    },
                    getCurrentLocation: function() {
                        return [t[0], t[1]]
                    },
                    getOrientation: function() {
                        return e
                    },
                    getCssClass: function() {
                        return n
                    }
                };
                return h({
                    dropOptions: s.dropOptions,
                    anchor: i,
                    source: this.element,
                    paintStyle: this.getPaintStyle(),
                    endpoint: s.hideOnDrag ? 'Blank' : this.endpoint,
                    _transient: !0,
                    scope: this.scope,
                    reference: this
                })
            }
            ,
            this.connectorSelector = function() {
                return this.connections[0]
            }
            ,
            this.setStyle = this.setPaintStyle,
            this.paint = function(t) {
                var e = (t = t || {}).timestamp
                  , n = !(!1 === t.recalc);
                if (!e || this.timestamp !== e) {
                    var i = l.updateOffset({
                        elId: this.elementId,
                        timestamp: e
                    })
                      , r = t.offset ? t.offset.o : i.o;
                    if (null != r) {
                        var o = t.anchorPoint
                          , s = t.connectorPaintStyle;
                        if (null == o) {
                            var c = t.dimensions || i.s
                              , h = {
                                xy: [r.left, r.top],
                                wh: c,
                                element: this,
                                timestamp: e
                            };
                            if (n && this.anchor.isDynamic && this.connections.length > 0) {
                                var u = a(this, t.elementWithPrecedence)
                                  , p = u.endpoints[0] === this ? 1 : 0
                                  , d = 0 === p ? u.sourceId : u.targetId
                                  , f = l.getCachedData(d)
                                  , m = f.o
                                  , g = f.s;
                                h.index = 0 === p ? 1 : 0,
                                h.connection = u,
                                h.txy = [m.left, m.top],
                                h.twh = g,
                                h.tElement = u.endpoints[p]
                            } else
                                this.connections.length > 0 && (h.connection = this.connections[0]);
                            o = this.anchor.compute(h)
                        }
                        for (var v in this.endpoint.compute(o, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, s || this.paintStyleInUse),
                        this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor),
                        this.timestamp = e,
                        this._jsPlumb.overlays)
                            if (this._jsPlumb.overlays.hasOwnProperty(v)) {
                                var y = this._jsPlumb.overlays[v];
                                y.isVisible() && (this._jsPlumb.overlayPlacements[v] = y.draw(this.endpoint, this._jsPlumb.paintStyleInUse),
                                y.paint(this._jsPlumb.overlayPlacements[v]))
                            }
                    }
                }
            }
            ,
            this.getTypeDescriptor = function() {
                return 'endpoint'
            }
            ,
            this.isVisible = function() {
                return this._jsPlumb.visible
            }
            ,
            this.repaint = this.paint;
            var m = !1;
            this.initDraggable = function() {
                if (!m && t.isDragSupported(this.element)) {
                    var o, a = {
                        id: null,
                        element: null
                    }, p = null, d = !1, f = null, g = n(this, a, l), v = s.dragOptions || {}, y = t.dragEvents.start, x = t.dragEvents.stop, b = t.dragEvents.drag, _ = t.dragEvents.beforeStart, M = function(e) {
                        p = this.connectorSelector();
                        var n = !0;
                        this.isEnabled() || (n = !1),
                        null != p || this.isSource || this.isTemporarySource || (n = !1),
                        !this.isSource || !this.isFull() || null != p && this.dragAllowedWhenFull || (n = !1),
                        null == p || p.isDetachable(this) || (this.isFull() ? n = !1 : p = null);
                        var u = l.checkCondition(null == p ? 'beforeDrag' : 'beforeStartDetach', {
                            endpoint: this,
                            source: this.element,
                            sourceId: this.elementId,
                            connection: p
                        });
                        if (!1 === u ? n = !1 : 'object' == typeof u ? t.extend(u, o || {}) : u = o || {},
                        !1 === n)
                            return l.stopDrag && l.stopDrag(this.canvas),
                            g.stopDrag(),
                            !1;
                        for (var m = 0; m < this.connections.length; m++)
                            this.connections[m].setHover(!1);
                        this.addClass('endpointDrag'),
                        l.setConnectionBeingDragged(!0),
                        p && !this.isFull() && this.isSource && (p = null),
                        l.updateOffset({
                            elId: this.elementId
                        });
                        var v = this._jsPlumb.instance.getOffset(this.canvas)
                          , y = this.canvas
                          , x = this._jsPlumb.instance.getSize(this.canvas);
                        i(a, l, v, x),
                        l.setAttributes(this.canvas, {
                            dragId: a.id,
                            elId: this.elementId
                        });
                        var b = this.dragProxy || this.endpoint;
                        if (null == this.dragProxy && null != this.connectionType) {
                            var _ = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                            _.endpoints[1] && (b = _.endpoints[1])
                        }
                        var M = this._jsPlumb.instance.makeAnchor('Center');
                        M.isFloating = !0,
                        this._jsPlumb.floatingEndpoint = r(this.getPaintStyle(), M, b, this.canvas, a.element, l, h, this.scope);
                        var w = this._jsPlumb.floatingEndpoint.anchor;
                        if (null == p)
                            this.setHover(!1, !1),
                            (p = c({
                                sourceEndpoint: this,
                                targetEndpoint: this._jsPlumb.floatingEndpoint,
                                source: this.element,
                                target: a.element,
                                anchors: [this.anchor, this._jsPlumb.floatingEndpoint.anchor],
                                paintStyle: s.connectorStyle,
                                hoverPaintStyle: s.connectorHoverStyle,
                                connector: s.connector,
                                overlays: s.connectorOverlays,
                                type: this.connectionType,
                                cssClass: this.connectorClass,
                                hoverClass: this.connectorHoverClass,
                                scope: s.scope,
                                data: u
                            })).pending = !0,
                            p.addClass(l.draggingClass),
                            this._jsPlumb.floatingEndpoint.addClass(l.draggingClass),
                            this._jsPlumb.floatingEndpoint.anchor = w,
                            l.fire('connectionDrag', p),
                            l.anchorManager.newConnection(p);
                        else {
                            d = !0,
                            p.setHover(!1);
                            var S = p.endpoints[0].id === this.id ? 0 : 1;
                            this.detachFromConnection(p, null, !0);
                            var P = l.getDragScope(y);
                            l.setAttribute(this.canvas, 'originalScope', P),
                            l.fire('connectionDrag', p),
                            0 === S ? (f = [p.source, p.sourceId, y, P],
                            l.anchorManager.sourceChanged(p.endpoints[S].elementId, a.id, p, a.element)) : (f = [p.target, p.targetId, y, P],
                            p.target = a.element,
                            p.targetId = a.id,
                            l.anchorManager.updateOtherEndpoint(p.sourceId, p.endpoints[S].elementId, p.targetId, p)),
                            p.suspendedEndpoint = p.endpoints[S],
                            p.suspendedElement = p.endpoints[S].getElement(),
                            p.suspendedElementId = p.endpoints[S].elementId,
                            p.suspendedElementType = 0 === S ? 'source' : 'target',
                            p.suspendedEndpoint.setHover(!1),
                            this._jsPlumb.floatingEndpoint.referenceEndpoint = p.suspendedEndpoint,
                            p.endpoints[S] = this._jsPlumb.floatingEndpoint,
                            p.addClass(l.draggingClass),
                            this._jsPlumb.floatingEndpoint.addClass(l.draggingClass)
                        }
                        l.registerFloatingConnection(a, p, this._jsPlumb.floatingEndpoint),
                        l.currentlyDragging = !0
                    }
                    .bind(this), w = function() {
                        if (l.setConnectionBeingDragged(!1),
                        p && null != p.endpoints) {
                            var t = l.getDropEvent(arguments)
                              , e = l.getFloatingAnchorIndex(p);
                            if (p.endpoints[0 === e ? 1 : 0].anchor.unlock(),
                            p.removeClass(l.draggingClass),
                            this._jsPlumb && (p.deleteConnectionNow || p.endpoints[e] === this._jsPlumb.floatingEndpoint) && d && p.suspendedEndpoint) {
                                0 === e ? (p.floatingElement = p.source,
                                p.floatingId = p.sourceId,
                                p.floatingEndpoint = p.endpoints[0],
                                p.floatingIndex = 0,
                                p.source = f[0],
                                p.sourceId = f[1]) : (p.floatingElement = p.target,
                                p.floatingId = p.targetId,
                                p.floatingEndpoint = p.endpoints[1],
                                p.floatingIndex = 1,
                                p.target = f[0],
                                p.targetId = f[1]);
                                var n = this._jsPlumb.floatingEndpoint;
                                l.setDragScope(f[2], f[3]),
                                p.endpoints[e] = p.suspendedEndpoint,
                                p.isReattach() || p._forceReattach || p._forceDetach || !l.deleteConnection(p, {
                                    originalEvent: t
                                }) ? (p.setHover(!1),
                                p._forceDetach = null,
                                p._forceReattach = null,
                                this._jsPlumb.floatingEndpoint.detachFromConnection(p),
                                p.suspendedEndpoint.addConnection(p),
                                1 === e ? l.anchorManager.updateOtherEndpoint(p.sourceId, p.floatingId, p.targetId, p) : l.anchorManager.sourceChanged(p.floatingId, p.sourceId, p, p.source),
                                l.repaint(f[1])) : l.deleteObject({
                                    endpoint: n
                                })
                            }
                            this.deleteAfterDragStop ? l.deleteObject({
                                endpoint: this
                            }) : this._jsPlumb && this.paint({
                                recalc: !1
                            }),
                            l.fire('connectionDragStop', p, t),
                            p.pending && l.fire('connectionAborted', p, t),
                            l.currentlyDragging = !1,
                            p.suspendedElement = null,
                            p.suspendedEndpoint = null,
                            p = null
                        }
                        a && a.element && l.remove(a.element, !1, !1),
                        u && l.deleteObject({
                            endpoint: u
                        }),
                        this._jsPlumb && (this.canvas.style.visibility = 'visible',
                        this.anchor.unlock(),
                        this._jsPlumb.floatingEndpoint = null)
                    }
                    .bind(this);
                    (v = t.extend({}, v)).scope = this.scope || v.scope,
                    v[_] = e.wrap(v[_], (function(t) {
                        o = t.e.payload || {}
                    }
                    ), !1),
                    v[y] = e.wrap(v[y], M, !1),
                    v[b] = e.wrap(v[b], g.drag),
                    v[x] = e.wrap(v[x], w),
                    v.multipleDrop = !1,
                    v.canDrag = function() {
                        return this.isSource || this.isTemporarySource || this.connections.length > 0 && !1 !== this.connectionsDetachable
                    }
                    .bind(this),
                    l.initDraggable(this.canvas, v, 'internal'),
                    this.canvas._jsPlumbRelatedElement = this.element,
                    m = !0
                }
            }
            ;
            var g = s.endpoint || this._jsPlumb.instance.Defaults.Endpoint || t.Defaults.Endpoint;
            this.setEndpoint(g, !0);
            var v = s.anchor ? s.anchor : s.anchors ? s.anchors : l.Defaults.Anchor || 'Top';
            this.setAnchor(v, !0);
            var y = ['default', s.type || ''].join(' ');
            this.addType(y, s.data, !0),
            this.canvas = this.endpoint.canvas,
            this.canvas._jsPlumb = this,
            this.initDraggable();
            var x = function(n, i, r, o) {
                if (t.isDropSupported(this.element)) {
                    var a = s.dropOptions || l.Defaults.DropOptions || t.Defaults.DropOptions;
                    (a = t.extend({}, a)).scope = a.scope || this.scope;
                    var c = t.dragEvents.drop
                      , h = t.dragEvents.over
                      , u = t.dragEvents.out
                      , p = this
                      , d = l.EndpointDropHandler({
                        getEndpoint: function() {
                            return p
                        },
                        jsPlumb: l,
                        enabled: function() {
                            return null == r || r.isEnabled()
                        },
                        isFull: function() {
                            return r.isFull()
                        },
                        element: this.element,
                        elementId: this.elementId,
                        isSource: this.isSource,
                        isTarget: this.isTarget,
                        addClass: function(t) {
                            p.addClass(t)
                        },
                        removeClass: function(t) {
                            p.removeClass(t)
                        },
                        isDropAllowed: function() {
                            return p.isDropAllowed.apply(p, arguments)
                        },
                        reference: o,
                        isRedrop: function(t, e) {
                            return t.suspendedEndpoint && e.reference && t.suspendedEndpoint.id === e.reference.id
                        }
                    });
                    a[c] = e.wrap(a[c], d, !0),
                    a[h] = e.wrap(a[h], function() {
                        var e = t.getDragObject(arguments)
                          , n = l.getAttribute(t.getElement(e), 'dragId')
                          , i = l.getFloatingConnectionFor(n);
                        if (null != i) {
                            var r = l.getFloatingAnchorIndex(i)
                              , o = this.isTarget && 0 !== r || i.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === i.suspendedEndpoint.id;
                            if (o) {
                                var a = l.checkCondition('checkDropAllowed', {
                                    sourceEndpoint: i.endpoints[r],
                                    targetEndpoint: this,
                                    connection: i
                                });
                                this[(a ? 'add' : 'remove') + 'Class'](l.endpointDropAllowedClass),
                                this[(a ? 'remove' : 'add') + 'Class'](l.endpointDropForbiddenClass),
                                i.endpoints[r].anchor.over(this.anchor, this)
                            }
                        }
                    }
                    .bind(this)),
                    a[u] = e.wrap(a[u], function() {
                        var e = t.getDragObject(arguments)
                          , n = null == e ? null : l.getAttribute(t.getElement(e), 'dragId')
                          , i = n ? l.getFloatingConnectionFor(n) : null;
                        if (null != i) {
                            var r = l.getFloatingAnchorIndex(i)
                              , o = this.isTarget && 0 !== r || i.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === i.suspendedEndpoint.id;
                            o && (this.removeClass(l.endpointDropAllowedClass),
                            this.removeClass(l.endpointDropForbiddenClass),
                            i.endpoints[r].anchor.out())
                        }
                    }
                    .bind(this)),
                    l.initDroppable(n, a, 'internal', i)
                }
            }
            .bind(this);
            return this.anchor.isFloating || x(this.canvas, !(s._transient || this.anchor.isFloating), this, s.reference),
            this
        }
        ,
        e.extend(t.Endpoint, t.OverlayCapableJsPlumbUIComponent, {
            setVisible: function(t, e, n) {
                if (this._jsPlumb.visible = t,
                this.canvas && (this.canvas.style.display = t ? 'block' : 'none'),
                this[t ? 'showOverlays' : 'hideOverlays'](),
                !e)
                    for (var i = 0; i < this.connections.length; i++)
                        if (this.connections[i].setVisible(t),
                        !n) {
                            var r = this === this.connections[i].endpoints[0] ? 1 : 0;
                            1 === this.connections[i].endpoints[r].connections.length && this.connections[i].endpoints[r].setVisible(t, !0, !0)
                        }
            },
            getAttachedElements: function() {
                return this.connections
            },
            applyType: function(e, n) {
                this.setPaintStyle(e.endpointStyle || e.paintStyle, n),
                this.setHoverPaintStyle(e.endpointHoverStyle || e.hoverPaintStyle, n),
                null != e.maxConnections && (this._jsPlumb.maxConnections = e.maxConnections),
                e.scope && (this.scope = e.scope),
                t.extend(this, e, o),
                null != e.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, e.cssClass),
                t.OverlayCapableJsPlumbUIComponent.applyType(this, e)
            },
            isEnabled: function() {
                return this._jsPlumb.enabled
            },
            setEnabled: function(t) {
                this._jsPlumb.enabled = t
            },
            cleanup: function() {
                var e = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? '-' + this._jsPlumb.currentAnchorClass : '');
                t.removeClass(this.element, e),
                this.anchor = null,
                this.endpoint.cleanup(!0),
                this.endpoint.destroy(),
                this.endpoint = null,
                this._jsPlumb.instance.destroyDraggable(this.canvas, 'internal'),
                this._jsPlumb.instance.destroyDroppable(this.canvas, 'internal')
            },
            setHover: function(t) {
                this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && this.endpoint.setHover(t)
            },
            isFull: function() {
                return 0 === this._jsPlumb.maxConnections || !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections)
            },
            isFloating: function() {
                return null != this.anchor && this.anchor.isFloating
            },
            isConnectedTo: function(t) {
                var e = !1;
                if (t)
                    for (var n = 0; n < this.connections.length; n++)
                        if (this.connections[n].endpoints[1] === t || this.connections[n].endpoints[0] === t) {
                            e = !0;
                            break
                        }
                return e
            },
            getConnectionCost: function() {
                return this._jsPlumb.connectionCost
            },
            setConnectionCost: function(t) {
                this._jsPlumb.connectionCost = t
            },
            areConnectionsDirected: function() {
                return this._jsPlumb.connectionsDirected
            },
            setConnectionsDirected: function(t) {
                this._jsPlumb.connectionsDirected = t
            },
            setElementId: function(t) {
                this.elementId = t,
                this.anchor.elementId = t
            },
            setReferenceElement: function(e) {
                this.element = t.getElement(e)
            },
            setDragAllowedWhenFull: function(t) {
                this.dragAllowedWhenFull = t
            },
            equals: function(t) {
                return this.anchor.equals(t.anchor)
            },
            getUuid: function() {
                return this._jsPlumb.uuid
            },
            computeAnchor: function(t) {
                return this.anchor.compute(t)
            }
        }),
        this.jsPlumbInstance.prototype.EndpointDropHandler = function(t) {
            return function(n) {
                var i = t.jsPlumb;
                t.removeClass(i.endpointDropAllowedClass),
                t.removeClass(i.endpointDropForbiddenClass);
                var r = i.getDropEvent(arguments)
                  , o = i.getDragObject(arguments)
                  , a = i.getAttribute(o, 'dragId')
                  , s = (i.getAttribute(o, 'elId'),
                i.getAttribute(o, 'originalScope'))
                  , l = i.getFloatingConnectionFor(a);
                if (null != l) {
                    var c = null != l.suspendedEndpoint;
                    if (!c || null != l.suspendedEndpoint._jsPlumb) {
                        var h = t.getEndpoint(l);
                        if (null != h) {
                            if (t.isRedrop(l, t))
                                return l._forceReattach = !0,
                                l.setHover(!1),
                                void (t.maybeCleanup && t.maybeCleanup(h));
                            var u = i.getFloatingAnchorIndex(l);
                            if (0 === u && !t.isSource || 1 === u && !t.isTarget)
                                t.maybeCleanup && t.maybeCleanup(h);
                            else {
                                t.onDrop && t.onDrop(l),
                                s && i.setDragScope(o, s);
                                var p = t.isFull(n);
                                if (p && h.fire('maxConnections', {
                                    endpoint: this,
                                    connection: l,
                                    maxConnections: h._jsPlumb.maxConnections
                                }, r),
                                !p && t.enabled()) {
                                    var d = !0;
                                    0 === u ? (l.floatingElement = l.source,
                                    l.floatingId = l.sourceId,
                                    l.floatingEndpoint = l.endpoints[0],
                                    l.floatingIndex = 0,
                                    l.source = t.element,
                                    l.sourceId = t.elementId) : (l.floatingElement = l.target,
                                    l.floatingId = l.targetId,
                                    l.floatingEndpoint = l.endpoints[1],
                                    l.floatingIndex = 1,
                                    l.target = t.element,
                                    l.targetId = t.elementId),
                                    c && l.suspendedEndpoint.id !== h.id && (l.isDetachAllowed(l) && l.endpoints[u].isDetachAllowed(l) && l.suspendedEndpoint.isDetachAllowed(l) && i.checkCondition('beforeDetach', l) || (d = !1));
                                    var f = function(n) {
                                        l.endpoints[u].detachFromConnection(l),
                                        l.suspendedEndpoint && l.suspendedEndpoint.detachFromConnection(l),
                                        l.endpoints[u] = h,
                                        h.addConnection(l);
                                        var o = h.getParameters();
                                        for (var a in o)
                                            l.setParameter(a, o[a]);
                                        if (c) {
                                            var s = l.suspendedEndpoint.elementId;
                                            i.fireMoveEvent({
                                                index: u,
                                                originalSourceId: 0 === u ? s : l.sourceId,
                                                newSourceId: 0 === u ? h.elementId : l.sourceId,
                                                originalTargetId: 1 === u ? s : l.targetId,
                                                newTargetId: 1 === u ? h.elementId : l.targetId,
                                                originalSourceEndpoint: 0 === u ? l.suspendedEndpoint : l.endpoints[0],
                                                newSourceEndpoint: 0 === u ? h : l.endpoints[0],
                                                originalTargetEndpoint: 1 === u ? l.suspendedEndpoint : l.endpoints[1],
                                                newTargetEndpoint: 1 === u ? h : l.endpoints[1],
                                                connection: l
                                            }, r)
                                        } else
                                            o.draggable && i.initDraggable(this.element, t.dragOptions, 'internal', i);
                                        (1 === u ? i.anchorManager.updateOtherEndpoint(l.sourceId, l.floatingId, l.targetId, l) : i.anchorManager.sourceChanged(l.floatingId, l.sourceId, l, l.source),
                                        l.endpoints[0].finalEndpoint) && (l.endpoints[0].detachFromConnection(l),
                                        l.endpoints[0] = l.endpoints[0].finalEndpoint,
                                        l.endpoints[0].addConnection(l));
                                        e.isObject(n) && l.mergeData(n),
                                        i.finaliseConnection(l, null, r, !1),
                                        l.setHover(!1),
                                        i.revalidate(l.endpoints[0].element)
                                    }
                                    .bind(this)
                                      , m = function() {
                                        l.suspendedEndpoint && (l.endpoints[u] = l.suspendedEndpoint,
                                        l.setHover(!1),
                                        l._forceDetach = !0,
                                        0 === u ? (l.source = l.suspendedEndpoint.element,
                                        l.sourceId = l.suspendedEndpoint.elementId) : (l.target = l.suspendedEndpoint.element,
                                        l.targetId = l.suspendedEndpoint.elementId),
                                        l.suspendedEndpoint.addConnection(l),
                                        1 === u ? i.anchorManager.updateOtherEndpoint(l.sourceId, l.floatingId, l.targetId, l) : i.anchorManager.sourceChanged(l.floatingId, l.sourceId, l, l.source),
                                        i.repaint(l.sourceId),
                                        l._forceDetach = !1)
                                    };
                                    if (d = d && t.isDropAllowed(l.sourceId, l.targetId, l.scope, l, h))
                                        return f(d),
                                        !0;
                                    m()
                                }
                                t.maybeCleanup && t.maybeCleanup(h),
                                i.currentlyDragging = !1
                            }
                        }
                    }
                }
            }
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , e = t.jsPlumb
          , n = t.jsPlumbUtil
          , i = function(t, i, r, o, a) {
            if (e.Connectors[i] = e.Connectors[i] || {},
            null == e.Connectors[i][r]) {
                if (null == e.Connectors[r]) {
                    if (t.Defaults.DoNotThrowErrors)
                        return null;
                    throw new TypeError('jsPlumb: unknown connector type \'' + r + '\'')
                }
                e.Connectors[i][r] = function() {
                    e.Connectors[r].apply(this, arguments),
                    e.ConnectorRenderers[i].apply(this, arguments)
                }
                ,
                n.extend(e.Connectors[i][r], [e.Connectors[r], e.ConnectorRenderers[i]])
            }
            return new e.Connectors[i][r](o,a)
        }
          , r = function(t, e, n) {
            return t ? n.makeAnchor(t, e, n) : null
        }
          , o = function(t, e, i, r) {
            null != e && (e._jsPlumbConnections = e._jsPlumbConnections || {},
            r ? delete e._jsPlumbConnections[t.id] : e._jsPlumbConnections[t.id] = !0,
            n.isEmpty(e._jsPlumbConnections) ? i.removeClass(e, i.connectedClass) : i.addClass(e, i.connectedClass))
        };
        e.Connection = function(t) {
            var i = t.newEndpoint;
            this.id = t.id,
            this.connector = null,
            this.idPrefix = '_jsplumb_c_',
            this.defaultLabelLocation = .5,
            this.defaultOverlayKeys = ['Overlays', 'ConnectionOverlays'],
            this.previousConnection = t.previousConnection,
            this.source = e.getElement(t.source),
            this.target = e.getElement(t.target),
            e.OverlayCapableJsPlumbUIComponent.apply(this, arguments),
            t.sourceEndpoint ? (this.source = t.sourceEndpoint.getElement(),
            this.sourceId = t.sourceEndpoint.elementId) : this.sourceId = this._jsPlumb.instance.getId(this.source),
            t.targetEndpoint ? (this.target = t.targetEndpoint.getElement(),
            this.targetId = t.targetEndpoint.elementId) : this.targetId = this._jsPlumb.instance.getId(this.target),
            this.scope = t.scope,
            this.endpoints = [],
            this.endpointStyles = [];
            var r = this._jsPlumb.instance;
            r.manage(this.sourceId, this.source),
            r.manage(this.targetId, this.target),
            this._jsPlumb.visible = !0,
            this._jsPlumb.params = {
                cssClass: t.cssClass,
                container: t.container,
                'pointer-events': t['pointer-events'],
                editorParams: t.editorParams,
                overlays: t.overlays
            },
            this._jsPlumb.lastPaintedAt = null,
            this.bind('mouseover', function() {
                this.setHover(!0)
            }
            .bind(this)),
            this.bind('mouseout', function() {
                this.setHover(!1)
            }
            .bind(this)),
            this.makeEndpoint = function(e, n, o, a, s) {
                return o = o || this._jsPlumb.instance.getId(n),
                this.prepareEndpoint(r, i, this, a, e ? 0 : 1, t, n, o, s)
            }
            ,
            t.type && (t.endpoints = t.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(t.type).endpoints);
            var o = this.makeEndpoint(!0, this.source, this.sourceId, t.sourceEndpoint)
              , a = this.makeEndpoint(!1, this.target, this.targetId, t.targetEndpoint);
            o && n.addToList(t.endpointsByElement, this.sourceId, o),
            a && n.addToList(t.endpointsByElement, this.targetId, a),
            this.scope || (this.scope = this.endpoints[0].scope),
            null != t.deleteEndpointsOnEmpty && (this.endpoints[0].setDeleteOnEmpty(t.deleteEndpointsOnEmpty),
            this.endpoints[1].setDeleteOnEmpty(t.deleteEndpointsOnEmpty));
            var s = r.Defaults.ConnectionsDetachable;
            !1 === t.detachable && (s = !1),
            !1 === this.endpoints[0].connectionsDetachable && (s = !1),
            !1 === this.endpoints[1].connectionsDetachable && (s = !1);
            var l = t.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || r.Defaults.ReattachConnections;
            this.appendToDefaultType({
                detachable: s,
                reattach: l,
                paintStyle: this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || t.paintStyle || r.Defaults.PaintStyle || e.Defaults.PaintStyle,
                hoverPaintStyle: this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || t.hoverPaintStyle || r.Defaults.HoverPaintStyle || e.Defaults.HoverPaintStyle
            });
            var c = r.getSuspendedAt();
            if (!r.isSuspendDrawing()) {
                var h = r.getCachedData(this.sourceId)
                  , u = h.o
                  , p = h.s
                  , d = r.getCachedData(this.targetId)
                  , f = d.o
                  , m = d.s
                  , g = c || r.timestamp()
                  , v = this.endpoints[0].anchor.compute({
                    xy: [u.left, u.top],
                    wh: p,
                    element: this.endpoints[0],
                    elementId: this.endpoints[0].elementId,
                    txy: [f.left, f.top],
                    twh: m,
                    tElement: this.endpoints[1],
                    timestamp: g
                });
                this.endpoints[0].paint({
                    anchorLoc: v,
                    timestamp: g
                }),
                v = this.endpoints[1].anchor.compute({
                    xy: [f.left, f.top],
                    wh: m,
                    element: this.endpoints[1],
                    elementId: this.endpoints[1].elementId,
                    txy: [u.left, u.top],
                    twh: p,
                    tElement: this.endpoints[0],
                    timestamp: g
                }),
                this.endpoints[1].paint({
                    anchorLoc: v,
                    timestamp: g
                })
            }
            this.getTypeDescriptor = function() {
                return 'connection'
            }
            ,
            this.getAttachedElements = function() {
                return this.endpoints
            }
            ,
            this.isDetachable = function(t) {
                return !1 !== this._jsPlumb.detachable && (null != t ? !0 === t.connectionsDetachable : !0 === this._jsPlumb.detachable)
            }
            ,
            this.setDetachable = function(t) {
                this._jsPlumb.detachable = !0 === t
            }
            ,
            this.isReattach = function() {
                return !0 === this._jsPlumb.reattach || !0 === this.endpoints[0].reattachConnections || !0 === this.endpoints[1].reattachConnections
            }
            ,
            this.setReattach = function(t) {
                this._jsPlumb.reattach = !0 === t
            }
            ,
            this._jsPlumb.cost = t.cost || this.endpoints[0].getConnectionCost(),
            this._jsPlumb.directed = t.directed,
            null == t.directed && (this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected());
            var y = e.extend({}, this.endpoints[1].getParameters());
            e.extend(y, this.endpoints[0].getParameters()),
            e.extend(y, this.getParameters()),
            this.setParameters(y),
            this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || t.connector || r.Defaults.Connector || e.Defaults.Connector, !0);
            var x = null != t.data && n.isObject(t.data) ? t.data : {};
            this.getData = function() {
                return x
            }
            ,
            this.setData = function(t) {
                x = t || {}
            }
            ,
            this.mergeData = function(t) {
                x = e.extend(x, t)
            }
            ;
            var b = ['default', this.endpoints[0].connectionType, this.endpoints[1].connectionType, t.type].join(' ');
            /[^\s]/.test(b) && this.addType(b, t.data, !0),
            this.updateConnectedClass()
        }
        ,
        n.extend(e.Connection, e.OverlayCapableJsPlumbUIComponent, {
            applyType: function(t, n, i) {
                var r = null;
                null != t.connector && (null == (r = this.getCachedTypeItem('connector', i.connector)) && (r = this.prepareConnector(t.connector, i.connector),
                this.cacheTypeItem('connector', r, i.connector)),
                this.setPreparedConnector(r)),
                null != t.detachable && this.setDetachable(t.detachable),
                null != t.reattach && this.setReattach(t.reattach),
                t.scope && (this.scope = t.scope),
                null != t.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
                var o = null;
                t.anchor ? null == (o = this.getCachedTypeItem('anchors', i.anchor)) && (o = [this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor)],
                this.cacheTypeItem('anchors', o, i.anchor)) : t.anchors && null == (o = this.getCachedTypeItem('anchors', i.anchors)) && (o = [this._jsPlumb.instance.makeAnchor(t.anchors[0]), this._jsPlumb.instance.makeAnchor(t.anchors[1])],
                this.cacheTypeItem('anchors', o, i.anchors)),
                null != o && (this.endpoints[0].anchor = o[0],
                this.endpoints[1].anchor = o[1],
                this.endpoints[1].anchor.isDynamic && this._jsPlumb.instance.repaint(this.endpoints[1].elementId)),
                e.OverlayCapableJsPlumbUIComponent.applyType(this, t)
            },
            addClass: function(t, e) {
                e && (this.endpoints[0].addClass(t),
                this.endpoints[1].addClass(t),
                this.suspendedEndpoint && this.suspendedEndpoint.addClass(t)),
                this.connector && this.connector.addClass(t)
            },
            removeClass: function(t, e) {
                e && (this.endpoints[0].removeClass(t),
                this.endpoints[1].removeClass(t),
                this.suspendedEndpoint && this.suspendedEndpoint.removeClass(t)),
                this.connector && this.connector.removeClass(t)
            },
            isVisible: function() {
                return this._jsPlumb.visible
            },
            setVisible: function(t) {
                this._jsPlumb.visible = t,
                this.connector && this.connector.setVisible(t),
                this.repaint()
            },
            cleanup: function() {
                this.updateConnectedClass(!0),
                this.endpoints = null,
                this.source = null,
                this.target = null,
                null != this.connector && (this.connector.cleanup(!0),
                this.connector.destroy(!0)),
                this.connector = null
            },
            updateConnectedClass: function(t) {
                this._jsPlumb && (o(this, this.source, this._jsPlumb.instance, t),
                o(this, this.target, this._jsPlumb.instance, t))
            },
            setHover: function(e) {
                this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && (this.connector.setHover(e),
                t.jsPlumb[e ? 'addClass' : 'removeClass'](this.source, this._jsPlumb.instance.hoverSourceClass),
                t.jsPlumb[e ? 'addClass' : 'removeClass'](this.target, this._jsPlumb.instance.hoverTargetClass))
            },
            getUuids: function() {
                return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()]
            },
            getCost: function() {
                return this._jsPlumb ? this._jsPlumb.cost : -1 / 0
            },
            setCost: function(t) {
                this._jsPlumb.cost = t
            },
            isDirected: function() {
                return this._jsPlumb.directed
            },
            getConnector: function() {
                return this.connector
            },
            prepareConnector: function(t, e) {
                var r, o = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: this._jsPlumb.params.cssClass,
                    container: this._jsPlumb.params.container,
                    'pointer-events': this._jsPlumb.params['pointer-events']
                }, a = this._jsPlumb.instance.getRenderMode();
                return n.isString(t) ? r = i(this._jsPlumb.instance, a, t, o, this) : n.isArray(t) && (r = 1 === t.length ? i(this._jsPlumb.instance, a, t[0], o, this) : i(this._jsPlumb.instance, a, t[0], n.merge(t[1], o), this)),
                null != e && (r.typeId = e),
                r
            },
            setPreparedConnector: function(t, e, n, i) {
                if (this.connector !== t) {
                    var r, o = '';
                    if (null != this.connector && (o = (r = this.connector).getClass(),
                    this.connector.cleanup(),
                    this.connector.destroy()),
                    this.connector = t,
                    i && this.cacheTypeItem('connector', t, i),
                    this.canvas = this.connector.canvas,
                    this.bgCanvas = this.connector.bgCanvas,
                    this.connector.reattach(this._jsPlumb.instance),
                    this.addClass(o),
                    this.canvas && (this.canvas._jsPlumb = this),
                    this.bgCanvas && (this.bgCanvas._jsPlumb = this),
                    null != r)
                        for (var a = this.getOverlays(), s = 0; s < a.length; s++)
                            a[s].transfer && a[s].transfer(this.connector);
                    n || this.setListenerComponent(this.connector),
                    e || this.repaint()
                }
            },
            setConnector: function(t, e, n, i) {
                var r = this.prepareConnector(t, i);
                this.setPreparedConnector(r, e, n, i)
            },
            paint: function(t) {
                if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                    var e = (t = t || {}).timestamp
                      , n = this.targetId
                      , i = this.sourceId;
                    if (null == e || e !== this._jsPlumb.lastPaintedAt) {
                        var r = this._jsPlumb.instance.updateOffset({
                            elId: i
                        }).o
                          , o = this._jsPlumb.instance.updateOffset({
                            elId: n
                        }).o
                          , a = this.endpoints[0]
                          , s = this.endpoints[1]
                          , l = a.anchor.getCurrentLocation({
                            xy: [r.left, r.top],
                            wh: [r.width, r.height],
                            element: a,
                            timestamp: e
                        })
                          , c = s.anchor.getCurrentLocation({
                            xy: [o.left, o.top],
                            wh: [o.width, o.height],
                            element: s,
                            timestamp: e
                        });
                        this.connector.resetBounds(),
                        this.connector.compute({
                            sourcePos: l,
                            targetPos: c,
                            sourceOrientation: a.anchor.getOrientation(a),
                            targetOrientation: s.anchor.getOrientation(s),
                            sourceEndpoint: this.endpoints[0],
                            targetEndpoint: this.endpoints[1],
                            'stroke-width': this._jsPlumb.paintStyleInUse.strokeWidth,
                            sourceInfo: r,
                            targetInfo: o
                        });
                        var h = {
                            minX: 1 / 0,
                            minY: 1 / 0,
                            maxX: -1 / 0,
                            maxY: -1 / 0
                        };
                        for (var u in this._jsPlumb.overlays)
                            if (this._jsPlumb.overlays.hasOwnProperty(u)) {
                                var p = this._jsPlumb.overlays[u];
                                p.isVisible() && (this._jsPlumb.overlayPlacements[u] = p.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(p)),
                                h.minX = Math.min(h.minX, this._jsPlumb.overlayPlacements[u].minX),
                                h.maxX = Math.max(h.maxX, this._jsPlumb.overlayPlacements[u].maxX),
                                h.minY = Math.min(h.minY, this._jsPlumb.overlayPlacements[u].minY),
                                h.maxY = Math.max(h.maxY, this._jsPlumb.overlayPlacements[u].maxY))
                            }
                        var d = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2
                          , f = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0)
                          , m = {
                            xmin: Math.min(this.connector.bounds.minX - (d + f), h.minX),
                            ymin: Math.min(this.connector.bounds.minY - (d + f), h.minY),
                            xmax: Math.max(this.connector.bounds.maxX + (d + f), h.maxX),
                            ymax: Math.max(this.connector.bounds.maxY + (d + f), h.maxY)
                        };
                        for (var g in this.connector.paintExtents = m,
                        this.connector.paint(this._jsPlumb.paintStyleInUse, null, m),
                        this._jsPlumb.overlays)
                            if (this._jsPlumb.overlays.hasOwnProperty(g)) {
                                var v = this._jsPlumb.overlays[g];
                                v.isVisible() && v.paint(this._jsPlumb.overlayPlacements[g], m)
                            }
                    }
                    this._jsPlumb.lastPaintedAt = e
                }
            },
            repaint: function(t) {
                var e = jsPlumb.extend(t || {}, {});
                e.elId = this.sourceId,
                this.paint(e)
            },
            prepareEndpoint: function(t, n, i, o, a, s, l, c, h) {
                var u;
                if (o)
                    i.endpoints[a] = o,
                    o.addConnection(i);
                else {
                    s.endpoints || (s.endpoints = [null, null]);
                    var p = h || s.endpoints[a] || s.endpoint || t.Defaults.Endpoints[a] || e.Defaults.Endpoints[a] || t.Defaults.Endpoint || e.Defaults.Endpoint;
                    s.endpointStyles || (s.endpointStyles = [null, null]),
                    s.endpointHoverStyles || (s.endpointHoverStyles = [null, null]);
                    var d = s.endpointStyles[a] || s.endpointStyle || t.Defaults.EndpointStyles[a] || e.Defaults.EndpointStyles[a] || t.Defaults.EndpointStyle || e.Defaults.EndpointStyle;
                    null == d.fill && null != s.paintStyle && (d.fill = s.paintStyle.stroke),
                    null == d.outlineStroke && null != s.paintStyle && (d.outlineStroke = s.paintStyle.outlineStroke),
                    null == d.outlineWidth && null != s.paintStyle && (d.outlineWidth = s.paintStyle.outlineWidth);
                    var f = s.endpointHoverStyles[a] || s.endpointHoverStyle || t.Defaults.EndpointHoverStyles[a] || e.Defaults.EndpointHoverStyles[a] || t.Defaults.EndpointHoverStyle || e.Defaults.EndpointHoverStyle;
                    null != s.hoverPaintStyle && (null == f && (f = {}),
                    null == f.fill && (f.fill = s.hoverPaintStyle.stroke));
                    var m = s.anchors ? s.anchors[a] : s.anchor ? s.anchor : r(t.Defaults.Anchors[a], c, t) || r(e.Defaults.Anchors[a], c, t) || r(t.Defaults.Anchor, c, t) || r(e.Defaults.Anchor, c, t);
                    u = n({
                        paintStyle: d,
                        hoverPaintStyle: f,
                        endpoint: p,
                        connections: [i],
                        uuid: s.uuids ? s.uuids[a] : null,
                        anchor: m,
                        source: l,
                        scope: s.scope,
                        reattach: s.reattach || t.Defaults.ReattachConnections,
                        detachable: s.detachable || t.Defaults.ConnectionsDetachable
                    }),
                    null == o && u.setDeleteOnEmpty(!0),
                    i.endpoints[a] = u,
                    !1 === s.drawEndpoints && u.setVisible(!1, !0, !0)
                }
                return u
            },
            replaceEndpoint: function(t, e) {
                var n = this.endpoints[t]
                  , i = n.elementId
                  , r = this._jsPlumb.instance.getEndpoints(i)
                  , o = r.indexOf(n)
                  , a = this.makeEndpoint(0 === t, n.element, i, null, e);
                this.endpoints[t] = a,
                r.splice(o, 1, a),
                this._jsPlumb.instance.deleteObject({
                    endpoint: n,
                    deleteAttachedObjects: !1
                }),
                this._jsPlumb.instance.fire('endpointReplaced', {
                    previous: n,
                    current: a
                }),
                this._jsPlumb.instance.anchorManager.updateOtherEndpoint(this.endpoints[0].elementId, this.endpoints[1].elementId, this.endpoints[1].elementId, this)
            }
        })
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumbUtil
          , e = this.jsPlumb;
        e.AnchorManager = function(n) {
            var i = {}
              , r = {}
              , o = {}
              , a = {}
              , s = this
              , l = {}
              , c = n.jsPlumbInstance
              , h = {}
              , u = function(t, e) {
                return e[0][0] - t[0][0]
            }
              , p = function(t, e) {
                return (t[0][0] < 0 ? -Math.PI - t[0][0] : Math.PI - t[0][0]) - (e[0][0] < 0 ? -Math.PI - e[0][0] : Math.PI - e[0][0])
            }
              , d = {
                top: p,
                right: u,
                bottom: u,
                left: p
            }
              , f = function(t, e) {
                var n = c.getCachedData(t)
                  , i = n.s
                  , a = n.o
                  , s = function(e, n, i, a, s, l, c) {
                    if (a.length > 0)
                        for (var h = function(t, e, n, i, r, o, a) {
                            for (var s = [], l = e[r ? 0 : 1] / (i.length + 1), c = 0; c < i.length; c++) {
                                var h = (c + 1) * l
                                  , u = o * e[r ? 1 : 0];
                                a && (h = e[r ? 0 : 1] - h);
                                var p = r ? h : u
                                  , d = n[0] + p
                                  , f = p / e[0]
                                  , m = r ? u : h
                                  , g = n[1] + m
                                  , v = m / e[1];
                                s.push([d, g, f, v, i[c][1], i[c][2]])
                            }
                            return s
                        }(0, n, i, (v = d[e],
                        a.sort(v)), s, l, 'right' === e || 'top' === e), u = function(t, e) {
                            r[t.id] = [e[0], e[1], e[2], e[3]],
                            o[t.id] = c
                        }, p = 0; p < h.length; p++) {
                            var f = h[p][4]
                              , m = f.endpoints[0].elementId === t
                              , g = f.endpoints[1].elementId === t;
                            m && u(f.endpoints[0], h[p]),
                            g && u(f.endpoints[1], h[p])
                        }
                    var v
                };
                s('bottom', i, [a.left, a.top], e.bottom, !0, 1, [0, 1]),
                s('top', i, [a.left, a.top], e.top, !0, 0, [0, -1]),
                s('left', i, [a.left, a.top], e.left, !1, 0, [-1, 0]),
                s('right', i, [a.left, a.top], e.right, !1, 1, [1, 0])
            };
            this.reset = function() {
                i = {},
                a = {},
                l = {}
            }
            ,
            this.addFloatingConnection = function(t, e) {
                h[t] = e
            }
            ,
            this.removeFloatingConnection = function(t) {
                delete h[t]
            }
            ,
            this.newConnection = function(n) {
                var i = n.sourceId
                  , r = n.targetId
                  , o = n.endpoints
                  , s = !0
                  , l = function(l, c, h, u, p) {
                    i === r && h.isContinuous && (n._jsPlumb.instance.removeElement(o[1].canvas),
                    s = !1),
                    t.addToList(a, u, [p, c, h.constructor === e.DynamicAnchor])
                };
                l(0, o[0], o[0].anchor, r, n),
                s && l(0, o[1], o[1].anchor, i, n)
            }
            ;
            var m = function(e) {
                !function(e, n) {
                    if (e) {
                        var i = function(t) {
                            return t[4] === n
                        };
                        t.removeWithFunction(e.top, i),
                        t.removeWithFunction(e.left, i),
                        t.removeWithFunction(e.bottom, i),
                        t.removeWithFunction(e.right, i)
                    }
                }(l[e.elementId], e.id)
            };
            this.connectionDetached = function(e, n) {
                var i = e.connection || e
                  , r = e.sourceId
                  , o = e.targetId
                  , l = i.endpoints
                  , c = function(e, n, i, r, o) {
                    t.removeWithFunction(a[r], (function(t) {
                        return t[0].id === o.id
                    }
                    ))
                };
                c(0, l[1], l[1].anchor, r, i),
                c(0, l[0], l[0].anchor, o, i),
                i.floatingId && (c(i.floatingIndex, i.floatingEndpoint, i.floatingEndpoint.anchor, i.floatingId, i),
                m(i.floatingEndpoint)),
                m(i.endpoints[0]),
                m(i.endpoints[1]),
                n || (s.redraw(i.sourceId),
                i.targetId !== i.sourceId && s.redraw(i.targetId))
            }
            ,
            this.add = function(e, n) {
                t.addToList(i, n, e)
            }
            ,
            this.changeId = function(t, e) {
                a[e] = a[t],
                i[e] = i[t],
                delete a[t],
                delete i[t]
            }
            ,
            this.getConnectionsFor = function(t) {
                return a[t] || []
            }
            ,
            this.getEndpointsFor = function(t) {
                return i[t] || []
            }
            ,
            this.deleteEndpoint = function(e) {
                t.removeWithFunction(i[e.elementId], (function(t) {
                    return t.id === e.id
                }
                )),
                m(e)
            }
            ,
            this.clearFor = function(t) {
                delete i[t],
                i[t] = []
            }
            ;
            var g = function(e, i, r, o, a, s, l, c, h, u, p, d) {
                var f, m, g = -1, v = o.endpoints[l], y = v.id, x = [1, 0][l], b = [[i, r], o, a, s, y], _ = e[h], M = v._continuousAnchorEdge ? e[v._continuousAnchorEdge] : null;
                if (M) {
                    var w = t.findWithFunction(M, (function(t) {
                        return t[4] === y
                    }
                    ));
                    if (-1 !== w)
                        for (M.splice(w, 1),
                        f = 0; f < M.length; f++)
                            m = M[f][1],
                            t.addWithFunction(p, m, (function(t) {
                                return t.id === m.id
                            }
                            )),
                            t.addWithFunction(d, M[f][1].endpoints[l], (function(t) {
                                return t.id === m.endpoints[l].id
                            }
                            )),
                            t.addWithFunction(d, M[f][1].endpoints[x], (function(t) {
                                return t.id === m.endpoints[x].id
                            }
                            ))
                }
                for (f = 0; f < _.length; f++)
                    m = _[f][1],
                    1 === n.idx && _[f][3] === s && -1 === g && (g = f),
                    t.addWithFunction(p, m, (function(t) {
                        return t.id === m.id
                    }
                    )),
                    t.addWithFunction(d, _[f][1].endpoints[l], (function(t) {
                        return t.id === m.endpoints[l].id
                    }
                    )),
                    t.addWithFunction(d, _[f][1].endpoints[x], (function(t) {
                        return t.id === m.endpoints[x].id
                    }
                    ));
                var S = c ? -1 !== g ? g : 0 : _.length;
                _.splice(S, 0, b),
                v._continuousAnchorEdge = h
            };
            this.updateOtherEndpoint = function(n, i, r, o) {
                var s = t.findWithFunction(a[n], (function(t) {
                    return t[0].id === o.id
                }
                ))
                  , l = t.findWithFunction(a[i], (function(t) {
                    return t[0].id === o.id
                }
                ));
                -1 !== s && (a[n][s][0] = o,
                a[n][s][1] = o.endpoints[1],
                a[n][s][2] = o.endpoints[1].anchor.constructor === e.DynamicAnchor),
                l > -1 && (a[i].splice(l, 1),
                t.addToList(a, r, [o, o.endpoints[0], o.endpoints[0].anchor.constructor === e.DynamicAnchor])),
                o.updateConnectedClass()
            }
            ,
            this.sourceChanged = function(n, i, r, o) {
                if (n !== i) {
                    r.sourceId = i,
                    r.source = o,
                    t.removeWithFunction(a[n], (function(t) {
                        return t[0].id === r.id
                    }
                    ));
                    var s = t.findWithFunction(a[r.targetId], (function(t) {
                        return t[0].id === r.id
                    }
                    ));
                    s > -1 && (a[r.targetId][s][0] = r,
                    a[r.targetId][s][1] = r.endpoints[0],
                    a[r.targetId][s][2] = r.endpoints[0].anchor.constructor === e.DynamicAnchor),
                    t.addToList(a, i, [r, r.endpoints[1], r.endpoints[1].anchor.constructor === e.DynamicAnchor]),
                    r.endpoints[1].anchor.isContinuous && (r.source === r.target ? r._jsPlumb.instance.removeElement(r.endpoints[1].canvas) : null == r.endpoints[1].canvas.parentNode && r._jsPlumb.instance.appendElement(r.endpoints[1].canvas)),
                    r.updateConnectedClass()
                }
            }
            ,
            this.rehomeEndpoint = function(t, e, n) {
                var r = i[e] || []
                  , o = c.getId(n);
                if (o !== e) {
                    var a = r.indexOf(t);
                    if (a > -1) {
                        var l = r.splice(a, 1)[0];
                        s.add(l, o)
                    }
                }
                for (var h = 0; h < t.connections.length; h++)
                    t.connections[h].sourceId === e ? s.sourceChanged(e, t.elementId, t.connections[h], t.element) : t.connections[h].targetId === e && (t.connections[h].targetId = t.elementId,
                    t.connections[h].target = t.element,
                    s.updateOtherEndpoint(t.connections[h].sourceId, e, t.elementId, t.connections[h]))
            }
            ,
            this.redraw = function(n, r, o, s, u, p) {
                if (!c.isSuspendDrawing()) {
                    var d = i[n] || []
                      , m = a[n] || []
                      , v = []
                      , y = []
                      , x = [];
                    o = o || c.timestamp(),
                    s = s || {
                        left: 0,
                        top: 0
                    },
                    r && (r = {
                        left: r.left + s.left,
                        top: r.top + s.top
                    });
                    for (var b = c.updateOffset({
                        elId: n,
                        offset: r,
                        recalc: !1,
                        timestamp: o
                    }), _ = {}, M = 0; M < m.length; M++) {
                        var w = m[M][0]
                          , S = w.sourceId
                          , P = w.targetId
                          , C = w.endpoints[0].anchor.isContinuous
                          , A = w.endpoints[1].anchor.isContinuous;
                        if (C || A) {
                            var E = S + '_' + P
                              , T = _[E]
                              , L = w.sourceId === n ? 1 : 0;
                            C && !l[S] && (l[S] = {
                                top: [],
                                right: [],
                                bottom: [],
                                left: []
                            }),
                            A && !l[P] && (l[P] = {
                                top: [],
                                right: [],
                                bottom: [],
                                left: []
                            }),
                            n !== P && c.updateOffset({
                                elId: P,
                                timestamp: o
                            }),
                            n !== S && c.updateOffset({
                                elId: S,
                                timestamp: o
                            });
                            var D = c.getCachedData(P)
                              , I = c.getCachedData(S);
                            P === S && (C || A) ? (g(l[S], -Math.PI / 2, 0, w, !1, P, 0, !1, 'top', 0, v, y),
                            g(l[P], -Math.PI / 2, 0, w, !1, S, 1, !1, 'top', 0, v, y)) : (T || (T = this.calculateOrientation(S, P, I.o, D.o, w.endpoints[0].anchor, w.endpoints[1].anchor, w),
                            _[E] = T),
                            C && g(l[S], T.theta, 0, w, !1, P, 0, !1, T.a[0], 0, v, y),
                            A && g(l[P], T.theta2, -1, w, !0, S, 1, !0, T.a[1], 0, v, y)),
                            C && t.addWithFunction(x, S, (function(t) {
                                return t === S
                            }
                            )),
                            A && t.addWithFunction(x, P, (function(t) {
                                return t === P
                            }
                            )),
                            t.addWithFunction(v, w, (function(t) {
                                return t.id === w.id
                            }
                            )),
                            (C && 0 === L || A && 1 === L) && t.addWithFunction(y, w.endpoints[L], (function(t) {
                                return t.id === w.endpoints[L].id
                            }
                            ))
                        }
                    }
                    for (M = 0; M < d.length; M++)
                        0 === d[M].connections.length && d[M].anchor.isContinuous && (l[n] || (l[n] = {
                            top: [],
                            right: [],
                            bottom: [],
                            left: []
                        }),
                        g(l[n], -Math.PI / 2, 0, {
                            endpoints: [d[M], d[M]],
                            paint: function() {}
                        }, !1, n, 0, !1, d[M].anchor.getDefaultFace(), 0, v, y),
                        t.addWithFunction(x, n, (function(t) {
                            return t === n
                        }
                        )));
                    for (M = 0; M < x.length; M++)
                        f(x[M], l[x[M]]);
                    for (M = 0; M < d.length; M++)
                        d[M].paint({
                            timestamp: o,
                            offset: b,
                            dimensions: b.s,
                            recalc: !0 !== p
                        });
                    for (M = 0; M < y.length; M++) {
                        var O = c.getCachedData(y[M].elementId);
                        y[M].paint({
                            timestamp: null,
                            offset: O,
                            dimensions: O.s
                        })
                    }
                    for (M = 0; M < m.length; M++) {
                        var j = m[M][1];
                        if (j.anchor.constructor === e.DynamicAnchor) {
                            j.paint({
                                elementWithPrecedence: n,
                                timestamp: o
                            }),
                            t.addWithFunction(v, m[M][0], (function(t) {
                                return t.id === m[M][0].id
                            }
                            ));
                            for (var N = 0; N < j.connections.length; N++)
                                j.connections[N] !== m[M][0] && t.addWithFunction(v, j.connections[N], (function(t) {
                                    return t.id === j.connections[N].id
                                }
                                ))
                        } else
                            t.addWithFunction(v, m[M][0], (function(t) {
                                return t.id === m[M][0].id
                            }
                            ))
                    }
                    var k = h[n];
                    for (k && k.paint({
                        timestamp: o,
                        recalc: !1,
                        elId: n
                    }),
                    M = 0; M < v.length; M++)
                        v[M].paint({
                            elId: n,
                            timestamp: null,
                            recalc: !1,
                            clearEdits: u
                        })
                }
            }
            ;
            var v = function(e) {
                t.EventGenerator.apply(this),
                this.type = 'Continuous',
                this.isDynamic = !0,
                this.isContinuous = !0;
                for (var n = e.faces || ['top', 'right', 'bottom', 'left'], i = !(!1 === e.clockwise), a = {}, s = {
                    top: 'bottom',
                    right: 'left',
                    left: 'right',
                    bottom: 'top'
                }, l = {
                    top: 'right',
                    right: 'bottom',
                    left: 'top',
                    bottom: 'left'
                }, c = {
                    top: 'left',
                    right: 'top',
                    left: 'bottom',
                    bottom: 'right'
                }, h = i ? l : c, u = i ? c : l, p = e.cssClass || '', d = null, f = null, m = ['left', 'right'], g = ['top', 'bottom'], v = null, y = 0; y < n.length; y++)
                    a[n[y]] = !0;
                this.getDefaultFace = function() {
                    return 0 === n.length ? 'top' : n[0]
                }
                ,
                this.isRelocatable = function() {
                    return !0
                }
                ,
                this.isSnapOnRelocate = function() {
                    return !0
                }
                ,
                this.verifyEdge = function(t) {
                    return a[t] ? t : a[s[t]] ? s[t] : a[h[t]] ? h[t] : a[u[t]] ? u[t] : t
                }
                ,
                this.isEdgeSupported = function(t) {
                    return null == v ? null == f ? !0 === a[t] : f === t : -1 !== v.indexOf(t)
                }
                ,
                this.setCurrentFace = function(t, e) {
                    d = t,
                    e && null != f && (f = d)
                }
                ,
                this.getCurrentFace = function() {
                    return d
                }
                ,
                this.getSupportedFaces = function() {
                    var t = [];
                    for (var e in a)
                        a[e] && t.push(e);
                    return t
                }
                ,
                this.lock = function() {
                    f = d
                }
                ,
                this.unlock = function() {
                    f = null
                }
                ,
                this.isLocked = function() {
                    return null != f
                }
                ,
                this.lockCurrentAxis = function() {
                    null != d && (v = 'left' === d || 'right' === d ? m : g)
                }
                ,
                this.unlockCurrentAxis = function() {
                    v = null
                }
                ,
                this.compute = function(t) {
                    return r[t.element.id] || [0, 0]
                }
                ,
                this.getCurrentLocation = function(t) {
                    return r[t.element.id] || [0, 0]
                }
                ,
                this.getOrientation = function(t) {
                    return o[t.id] || [0, 0]
                }
                ,
                this.getCssClass = function() {
                    return p
                }
            };
            c.continuousAnchorFactory = {
                get: function(t) {
                    return new v(t)
                },
                clear: function(t) {
                    delete r[t]
                }
            }
        }
        ,
        e.AnchorManager.prototype.calculateOrientation = function(t, e, n, i, r, o) {
            var a = ['left', 'top', 'right', 'bottom'];
            if (t === e)
                return {
                    orientation: 'identity',
                    a: ['top', 'top']
                };
            var s = Math.atan2(i.centery - n.centery, i.centerx - n.centerx)
              , l = Math.atan2(n.centery - i.centery, n.centerx - i.centerx)
              , c = []
              , h = {};
            !function(t, e) {
                for (var n = 0; n < t.length; n++)
                    h[t[n]] = {
                        left: [e[n].left, e[n].centery],
                        right: [e[n].right, e[n].centery],
                        top: [e[n].centerx, e[n].top],
                        bottom: [e[n].centerx, e[n].bottom]
                    }
            }(['source', 'target'], [n, i]);
            for (var u = 0; u < a.length; u++)
                for (var p = 0; p < a.length; p++)
                    c.push({
                        source: a[u],
                        target: a[p],
                        dist: Biltong.lineLength(h.source[a[u]], h.target[a[p]])
                    });
            c.sort((function(t, e) {
                return t.dist < e.dist ? -1 : t.dist > e.dist ? 1 : 0
            }
            ));
            for (var d = c[0].source, f = c[0].target, m = 0; m < c.length && (d = !r.isContinuous || r.isEdgeSupported(c[m].source) ? c[m].source : null,
            f = !o.isContinuous || o.isEdgeSupported(c[m].target) ? c[m].target : null,
            null == d || null == f); m++)
                ;
            return r.isContinuous && r.setCurrentFace(d),
            o.isContinuous && o.setCurrentFace(f),
            {
                a: [d, f],
                theta: s,
                theta2: l
            }
        }
        ,
        e.Anchor = function(e) {
            this.x = e.x || 0,
            this.y = e.y || 0,
            this.elementId = e.elementId,
            this.cssClass = e.cssClass || '',
            this.userDefinedLocation = null,
            this.orientation = e.orientation || [0, 0],
            this.lastReturnValue = null,
            this.offsets = e.offsets || [0, 0],
            this.timestamp = null;
            var n = !1 !== e.relocatable;
            this.isRelocatable = function() {
                return n
            }
            ,
            this.setRelocatable = function(t) {
                n = t
            }
            ;
            var i = !1 !== e.snapOnRelocate;
            this.isSnapOnRelocate = function() {
                return i
            }
            ;
            var r = !1;
            this.lock = function() {
                r = !0
            }
            ,
            this.unlock = function() {
                r = !1
            }
            ,
            this.isLocked = function() {
                return r
            }
            ,
            t.EventGenerator.apply(this),
            this.compute = function(t) {
                var e = t.xy
                  , n = t.wh
                  , i = t.timestamp;
                return t.clearUserDefinedLocation && (this.userDefinedLocation = null),
                i && i === this.timestamp ? this.lastReturnValue : (null != this.userDefinedLocation ? this.lastReturnValue = this.userDefinedLocation : this.lastReturnValue = [e[0] + this.x * n[0] + this.offsets[0], e[1] + this.y * n[1] + this.offsets[1], this.x, this.y],
                this.timestamp = i,
                this.lastReturnValue)
            }
            ,
            this.getCurrentLocation = function(t) {
                return t = t || {},
                null == this.lastReturnValue || null != t.timestamp && this.timestamp !== t.timestamp ? this.compute(t) : this.lastReturnValue
            }
            ,
            this.setPosition = function(t, e, n, i, o) {
                r && !o || (this.x = t,
                this.y = e,
                this.orientation = [n, i],
                this.lastReturnValue = null)
            }
        }
        ,
        t.extend(e.Anchor, t.EventGenerator, {
            equals: function(t) {
                if (!t)
                    return !1;
                var e = t.getOrientation()
                  , n = this.getOrientation();
                return this.x === t.x && this.y === t.y && this.offsets[0] === t.offsets[0] && this.offsets[1] === t.offsets[1] && n[0] === e[0] && n[1] === e[1]
            },
            getUserDefinedLocation: function() {
                return this.userDefinedLocation
            },
            setUserDefinedLocation: function(t) {
                this.userDefinedLocation = t
            },
            clearUserDefinedLocation: function() {
                this.userDefinedLocation = null
            },
            getOrientation: function() {
                return this.orientation
            },
            getCssClass: function() {
                return this.cssClass
            }
        }),
        e.FloatingAnchor = function(t) {
            e.Anchor.apply(this, arguments);
            var n = t.reference
              , i = t.referenceCanvas
              , r = e.getSize(i)
              , o = 0
              , a = 0
              , s = null
              , l = null;
            this.orientation = null,
            this.x = 0,
            this.y = 0,
            this.isFloating = !0,
            this.compute = function(t) {
                var e = t.xy
                  , n = [e[0] + r[0] / 2, e[1] + r[1] / 2];
                return l = n,
                n
            }
            ,
            this.getOrientation = function(t) {
                if (s)
                    return s;
                var e = n.getOrientation(t);
                return [Math.abs(e[0]) * o * -1, Math.abs(e[1]) * a * -1]
            }
            ,
            this.over = function(t, e) {
                s = t.getOrientation(e)
            }
            ,
            this.out = function() {
                s = null
            }
            ,
            this.getCurrentLocation = function(t) {
                return null == l ? this.compute(t) : l
            }
        }
        ,
        t.extend(e.FloatingAnchor, e.Anchor);
        var n = function(t, n, i) {
            return t.constructor === e.Anchor ? t : n.makeAnchor(t, i, n)
        };
        e.DynamicAnchor = function(t) {
            e.Anchor.apply(this, arguments),
            this.isDynamic = !0,
            this.anchors = [],
            this.elementId = t.elementId,
            this.jsPlumbInstance = t.jsPlumbInstance;
            for (var i = 0; i < t.anchors.length; i++)
                this.anchors[i] = n(t.anchors[i], this.jsPlumbInstance, this.elementId);
            this.getAnchors = function() {
                return this.anchors
            }
            ;
            var r = this.anchors.length > 0 ? this.anchors[0] : null
              , o = r
              , a = this
              , s = function(t, e, n, i, r) {
                var o = i[0] + t.x * r[0]
                  , a = i[1] + t.y * r[1]
                  , s = i[0] + r[0] / 2
                  , l = i[1] + r[1] / 2;
                return Math.sqrt(Math.pow(e - o, 2) + Math.pow(n - a, 2)) + Math.sqrt(Math.pow(s - o, 2) + Math.pow(l - a, 2))
            }
              , l = t.selector || function(t, e, n, i, r) {
                for (var o = n[0] + i[0] / 2, a = n[1] + i[1] / 2, l = -1, c = 1 / 0, h = 0; h < r.length; h++) {
                    var u = s(r[h], o, a, t, e);
                    u < c && (l = h + 0,
                    c = u)
                }
                return r[l]
            }
            ;
            this.compute = function(t) {
                var e = t.xy
                  , n = t.wh
                  , i = t.txy
                  , s = t.twh;
                this.timestamp = t.timestamp;
                var c = a.getUserDefinedLocation();
                return null != c ? c : this.isLocked() || null == i || null == s ? r.compute(t) : (t.timestamp = null,
                r = l(e, n, i, s, this.anchors),
                this.x = r.x,
                this.y = r.y,
                r !== o && this.fire('anchorChanged', r),
                o = r,
                r.compute(t))
            }
            ,
            this.getCurrentLocation = function(t) {
                return this.getUserDefinedLocation() || (null != r ? r.getCurrentLocation(t) : null)
            }
            ,
            this.getOrientation = function(t) {
                return null != r ? r.getOrientation(t) : [0, 0]
            }
            ,
            this.over = function(t, e) {
                null != r && r.over(t, e)
            }
            ,
            this.out = function() {
                null != r && r.out()
            }
            ,
            this.setAnchor = function(t) {
                r = t
            }
            ,
            this.getCssClass = function() {
                return r && r.getCssClass() || ''
            }
            ,
            this.setAnchorCoordinates = function(t) {
                var e = jsPlumbUtil.findWithFunction(this.anchors, (function(e) {
                    return e.x === t[0] && e.y === t[1]
                }
                ));
                return -1 !== e && (this.setAnchor(this.anchors[e]),
                !0)
            }
        }
        ,
        t.extend(e.DynamicAnchor, e.Anchor);
        var i = function(t, n, i, r, o, a) {
            e.Anchors[o] = function(e) {
                var s = e.jsPlumbInstance.makeAnchor([t, n, i, r, 0, 0], e.elementId, e.jsPlumbInstance);
                return s.type = o,
                a && a(s, e),
                s
            }
        };
        i(.5, 0, 0, -1, 'TopCenter'),
        i(.5, 1, 0, 1, 'BottomCenter'),
        i(0, .5, -1, 0, 'LeftMiddle'),
        i(1, .5, 1, 0, 'RightMiddle'),
        i(.5, 0, 0, -1, 'Top'),
        i(.5, 1, 0, 1, 'Bottom'),
        i(0, .5, -1, 0, 'Left'),
        i(1, .5, 1, 0, 'Right'),
        i(.5, .5, 0, 0, 'Center'),
        i(1, 0, 0, -1, 'TopRight'),
        i(1, 1, 0, 1, 'BottomRight'),
        i(0, 0, 0, -1, 'TopLeft'),
        i(0, 1, 0, 1, 'BottomLeft'),
        e.Defaults.DynamicAnchors = function(t) {
            return t.jsPlumbInstance.makeAnchors(['TopCenter', 'RightMiddle', 'BottomCenter', 'LeftMiddle'], t.elementId, t.jsPlumbInstance)
        }
        ,
        e.Anchors.AutoDefault = function(t) {
            var n = t.jsPlumbInstance.makeDynamicAnchor(e.Defaults.DynamicAnchors(t));
            return n.type = 'AutoDefault',
            n
        }
        ;
        var r = function(t, n) {
            e.Anchors[t] = function(e) {
                var i = e.jsPlumbInstance.makeAnchor(['Continuous', {
                    faces: n
                }], e.elementId, e.jsPlumbInstance);
                return i.type = t,
                i
            }
        };
        e.Anchors.Continuous = function(t) {
            return t.jsPlumbInstance.continuousAnchorFactory.get(t)
        }
        ,
        r('ContinuousLeft', ['left']),
        r('ContinuousTop', ['top']),
        r('ContinuousBottom', ['bottom']),
        r('ContinuousRight', ['right']),
        i(0, 0, 0, 0, 'Assign', (function(t, e) {
            var n = e.position || 'Fixed';
            t.positionFinder = n.constructor === String ? e.jsPlumbInstance.AnchorPositionFinders[n] : n,
            t.constructorParams = e
        }
        )),
        this.jsPlumbInstance.prototype.AnchorPositionFinders = {
            Fixed: function(t, e, n) {
                return [(t.left - e.left) / n[0], (t.top - e.top) / n[1]]
            },
            Grid: function(t, e, n, i) {
                var r = t.left - e.left
                  , o = t.top - e.top
                  , a = n[0] / i.grid[0]
                  , s = n[1] / i.grid[1]
                  , l = Math.floor(r / a)
                  , c = Math.floor(o / s);
                return [(l * a + a / 2) / n[0], (c * s + s / 2) / n[1]]
            }
        },
        e.Anchors.Perimeter = function(t) {
            var e = (t = t || {}).anchorCount || 60
              , n = t.shape;
            if (!n)
                throw new Error('no shape supplied to Perimeter Anchor type');
            var i = function() {
                for (var t = 2 * Math.PI / e, n = 0, i = [], r = 0; r < e; r++) {
                    var o = .5 + .5 * Math.sin(n)
                      , a = .5 + .5 * Math.cos(n);
                    i.push([o, a, 0, 0]),
                    n += t
                }
                return i
            }
              , r = function(t) {
                for (var n = e / t.length, i = [], r = function(t, r, o, a, s, l, c) {
                    for (var h = (o - t) / (n = e * s), u = (a - r) / n, p = 0; p < n; p++)
                        i.push([t + h * p, r + u * p, null == l ? 0 : l, null == c ? 0 : c])
                }, o = 0; o < t.length; o++)
                    r.apply(null, t[o]);
                return i
            }
              , o = function(t) {
                for (var e = [], n = 0; n < t.length; n++)
                    e.push([t[n][0], t[n][1], t[n][2], t[n][3], 1 / t.length, t[n][4], t[n][5]]);
                return r(e)
            }
              , a = function() {
                return o([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]])
            }
              , s = {
                Circle: i,
                Ellipse: i,
                Diamond: function() {
                    return o([[.5, 0, 1, .5], [1, .5, .5, 1], [.5, 1, 0, .5], [0, .5, .5, 0]])
                },
                Rectangle: a,
                Square: a,
                Triangle: function() {
                    return o([[.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, .5, 0]])
                },
                Path: function(t) {
                    for (var e = t.points, n = [], i = 0, o = 0; o < e.length - 1; o++) {
                        var a = Math.sqrt(Math.pow(e[o][2] - e[o][0]) + Math.pow(e[o][3] - e[o][1]));
                        i += a,
                        n.push([e[o][0], e[o][1], e[o + 1][0], e[o + 1][1], a])
                    }
                    for (var s = 0; s < n.length; s++)
                        n[s][4] = n[s][4] / i;
                    return r(n)
                }
            };
            if (!s[n])
                throw new Error('Shape [' + n + '] is unknown by Perimeter Anchor type');
            var l = s[n](t);
            t.rotation && (l = function(t, e) {
                for (var n = [], i = e / 180 * Math.PI, r = 0; r < t.length; r++) {
                    var o = t[r][0] - .5
                      , a = t[r][1] - .5;
                    n.push([o * Math.cos(i) - a * Math.sin(i) + .5, o * Math.sin(i) + a * Math.cos(i) + .5, t[r][2], t[r][3]])
                }
                return n
            }(l, t.rotation));
            var c = t.jsPlumbInstance.makeDynamicAnchor(l);
            return c.type = 'Perimeter',
            c
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , e = t.jsPlumb
          , n = t.jsPlumbUtil
          , i = t.Biltong;
        e.Segments = {
            AbstractSegment: function(t) {
                this.params = t,
                this.findClosestPointOnPath = function(t, e) {
                    return {
                        d: 1 / 0,
                        x: null,
                        y: null,
                        l: null
                    }
                }
                ,
                this.getBounds = function() {
                    return {
                        minX: Math.min(t.x1, t.x2),
                        minY: Math.min(t.y1, t.y2),
                        maxX: Math.max(t.x1, t.x2),
                        maxY: Math.max(t.y1, t.y2)
                    }
                }
                ,
                this.lineIntersection = function(t, e, n, i) {
                    return []
                }
                ,
                this.boxIntersection = function(t, e, n, i) {
                    var r = [];
                    return r.push.apply(r, this.lineIntersection(t, e, t + n, e)),
                    r.push.apply(r, this.lineIntersection(t + n, e, t + n, e + i)),
                    r.push.apply(r, this.lineIntersection(t + n, e + i, t, e + i)),
                    r.push.apply(r, this.lineIntersection(t, e + i, t, e)),
                    r
                }
                ,
                this.boundingBoxIntersection = function(t) {
                    return this.boxIntersection(t.x, t.y, t.w, t.y)
                }
            },
            Straight: function(t) {
                e.Segments.AbstractSegment.apply(this, arguments);
                var n, r, o, a, s, l, c, h = function() {
                    n = Math.sqrt(Math.pow(s - a, 2) + Math.pow(c - l, 2)),
                    r = i.gradient({
                        x: a,
                        y: l
                    }, {
                        x: s,
                        y: c
                    }),
                    o = -1 / r
                };
                this.type = 'Straight',
                this.getLength = function() {
                    return n
                }
                ,
                this.getGradient = function() {
                    return r
                }
                ,
                this.getCoordinates = function() {
                    return {
                        x1: a,
                        y1: l,
                        x2: s,
                        y2: c
                    }
                }
                ,
                this.setCoordinates = function(t) {
                    a = t.x1,
                    l = t.y1,
                    s = t.x2,
                    c = t.y2,
                    h()
                }
                ,
                this.setCoordinates({
                    x1: t.x1,
                    y1: t.y1,
                    x2: t.x2,
                    y2: t.y2
                }),
                this.getBounds = function() {
                    return {
                        minX: Math.min(a, s),
                        minY: Math.min(l, c),
                        maxX: Math.max(a, s),
                        maxY: Math.max(l, c)
                    }
                }
                ,
                this.pointOnPath = function(t, e) {
                    if (0 !== t || e) {
                        if (1 !== t || e) {
                            var r = e ? t > 0 ? t : n + t : t * n;
                            return i.pointOnLine({
                                x: a,
                                y: l
                            }, {
                                x: s,
                                y: c
                            }, r)
                        }
                        return {
                            x: s,
                            y: c
                        }
                    }
                    return {
                        x: a,
                        y: l
                    }
                }
                ,
                this.gradientAtPoint = function(t) {
                    return r
                }
                ,
                this.pointAlongPathFrom = function(t, e, n) {
                    var r = this.pointOnPath(t, n)
                      , o = e <= 0 ? {
                        x: a,
                        y: l
                    } : {
                        x: s,
                        y: c
                    };
                    return e <= 0 && Math.abs(e) > 1 && (e *= -1),
                    i.pointOnLine(r, o, e)
                }
                ;
                var u = function(t, e, n) {
                    return n >= Math.min(t, e) && n <= Math.max(t, e)
                }
                  , p = function(t, e, n) {
                    return Math.abs(n - t) < Math.abs(n - e) ? t : e
                };
                this.findClosestPointOnPath = function(t, e) {
                    var h = {
                        d: 1 / 0,
                        x: null,
                        y: null,
                        l: null,
                        x1: a,
                        x2: s,
                        y1: l,
                        y2: c
                    };
                    if (0 === r)
                        h.y = l,
                        h.x = u(a, s, t) ? t : p(a, s, t);
                    else if (r === 1 / 0 || r === -1 / 0)
                        h.x = a,
                        h.y = u(l, c, e) ? e : p(l, c, e);
                    else {
                        var d = l - r * a
                          , f = (e - o * t - d) / (r - o)
                          , m = r * f + d;
                        h.x = u(a, s, f) ? f : p(a, s, f),
                        h.y = u(l, c, m) ? m : p(l, c, m)
                    }
                    var g = i.lineLength([h.x, h.y], [a, l]);
                    return h.d = i.lineLength([t, e], [h.x, h.y]),
                    h.l = g / n,
                    h
                }
                ;
                var d = function(t, e, n) {
                    return n > e ? e <= t && t <= n : e >= t && t >= n
                }
                  , f = d;
                this.lineIntersection = function(t, e, n, o) {
                    var h = Math.abs(i.gradient({
                        x: t,
                        y: e
                    }, {
                        x: n,
                        y: o
                    }))
                      , u = Math.abs(r)
                      , p = u === 1 / 0 ? a : l - u * a
                      , d = []
                      , m = h === 1 / 0 ? t : e - h * t;
                    if (h !== u)
                        if (h === 1 / 0 && 0 === u)
                            f(t, a, s) && f(l, e, o) && (d = [t, l]);
                        else if (0 === h && u === 1 / 0)
                            f(e, l, c) && f(a, t, n) && (d = [a, e]);
                        else {
                            var g, v;
                            h === 1 / 0 ? f(g = t, a, s) && f(v = u * t + p, e, o) && (d = [g, v]) : 0 === h ? f(v = e, l, c) && f(g = (e - p) / u, t, n) && (d = [g, v]) : (v = u * (g = (m - p) / (u - h)) + p,
                            f(g, a, s) && f(v, l, c) && (d = [g, v]))
                        }
                    return d
                }
                ,
                this.boxIntersection = function(t, e, n, i) {
                    var r = [];
                    return r.push.apply(r, this.lineIntersection(t, e, t + n, e)),
                    r.push.apply(r, this.lineIntersection(t + n, e, t + n, e + i)),
                    r.push.apply(r, this.lineIntersection(t + n, e + i, t, e + i)),
                    r.push.apply(r, this.lineIntersection(t, e + i, t, e)),
                    r
                }
                ,
                this.boundingBoxIntersection = function(t) {
                    return this.boxIntersection(t.x, t.y, t.w, t.h)
                }
            },
            Arc: function(t) {
                e.Segments.AbstractSegment.apply(this, arguments);
                var n = function(e, n) {
                    return i.theta([t.cx, t.cy], [e, n])
                }
                  , r = function(t, e) {
                    if (t.anticlockwise) {
                        var n = t.startAngle < t.endAngle ? t.startAngle + o : t.startAngle;
                        return n - Math.abs(n - t.endAngle) * e
                    }
                    var i = t.endAngle < t.startAngle ? t.endAngle + o : t.endAngle
                      , r = Math.abs(i - t.startAngle);
                    return t.startAngle + r * e
                }
                  , o = 2 * Math.PI;
                this.radius = t.r,
                this.anticlockwise = t.ac,
                this.type = 'Arc',
                t.startAngle && t.endAngle ? (this.startAngle = t.startAngle,
                this.endAngle = t.endAngle,
                this.x1 = t.cx + this.radius * Math.cos(t.startAngle),
                this.y1 = t.cy + this.radius * Math.sin(t.startAngle),
                this.x2 = t.cx + this.radius * Math.cos(t.endAngle),
                this.y2 = t.cy + this.radius * Math.sin(t.endAngle)) : (this.startAngle = n(t.x1, t.y1),
                this.endAngle = n(t.x2, t.y2),
                this.x1 = t.x1,
                this.y1 = t.y1,
                this.x2 = t.x2,
                this.y2 = t.y2),
                this.endAngle < 0 && (this.endAngle += o),
                this.startAngle < 0 && (this.startAngle += o);
                var a = this.endAngle < this.startAngle ? this.endAngle + o : this.endAngle;
                this.sweep = Math.abs(a - this.startAngle),
                this.anticlockwise && (this.sweep = o - this.sweep);
                var s = 2 * Math.PI * this.radius
                  , l = this.sweep / o
                  , c = s * l;
                this.getLength = function() {
                    return c
                }
                ,
                this.getBounds = function() {
                    return {
                        minX: t.cx - t.r,
                        maxX: t.cx + t.r,
                        minY: t.cy - t.r,
                        maxY: t.cy + t.r
                    }
                }
                ;
                var h = 1e-10
                  , u = function(t) {
                    var e = Math.floor(t)
                      , n = Math.ceil(t);
                    return t - e < h ? e : n - t < h ? n : t
                };
                this.pointOnPath = function(e, n) {
                    if (0 === e)
                        return {
                            x: this.x1,
                            y: this.y1,
                            theta: this.startAngle
                        };
                    if (1 === e)
                        return {
                            x: this.x2,
                            y: this.y2,
                            theta: this.endAngle
                        };
                    n && (e /= c);
                    var i = r(this, e)
                      , o = t.cx + t.r * Math.cos(i)
                      , a = t.cy + t.r * Math.sin(i);
                    return {
                        x: u(o),
                        y: u(a),
                        theta: i
                    }
                }
                ,
                this.gradientAtPoint = function(e, n) {
                    var r = this.pointOnPath(e, n)
                      , o = i.normal([t.cx, t.cy], [r.x, r.y]);
                    return this.anticlockwise || o !== 1 / 0 && o !== -1 / 0 || (o *= -1),
                    o
                }
                ,
                this.pointAlongPathFrom = function(e, n, i) {
                    var r = this.pointOnPath(e, i)
                      , o = n / s * 2 * Math.PI
                      , a = this.anticlockwise ? -1 : 1
                      , l = r.theta + a * o;
                    return {
                        x: t.cx + this.radius * Math.cos(l),
                        y: t.cy + this.radius * Math.sin(l)
                    }
                }
            },
            Bezier: function(n) {
                this.curve = [{
                    x: n.x1,
                    y: n.y1
                }, {
                    x: n.cp1x,
                    y: n.cp1y
                }, {
                    x: n.cp2x,
                    y: n.cp2y
                }, {
                    x: n.x2,
                    y: n.y2
                }];
                e.Segments.AbstractSegment.apply(this, arguments);
                this.bounds = {
                    minX: Math.min(n.x1, n.x2, n.cp1x, n.cp2x),
                    minY: Math.min(n.y1, n.y2, n.cp1y, n.cp2y),
                    maxX: Math.max(n.x1, n.x2, n.cp1x, n.cp2x),
                    maxY: Math.max(n.y1, n.y2, n.cp1y, n.cp2y)
                },
                this.type = 'Bezier';
                var i = function(e, n, i) {
                    return i && (n = t.jsBezier.locationAlongCurveFrom(e, n > 0 ? 0 : 1, n)),
                    n
                };
                this.pointOnPath = function(e, n) {
                    return e = i(this.curve, e, n),
                    t.jsBezier.pointOnCurve(this.curve, e)
                }
                ,
                this.gradientAtPoint = function(e, n) {
                    return e = i(this.curve, e, n),
                    t.jsBezier.gradientAtPoint(this.curve, e)
                }
                ,
                this.pointAlongPathFrom = function(e, n, r) {
                    return e = i(this.curve, e, r),
                    t.jsBezier.pointAlongCurveFrom(this.curve, e, n)
                }
                ,
                this.getLength = function() {
                    return t.jsBezier.getLength(this.curve)
                }
                ,
                this.getBounds = function() {
                    return this.bounds
                }
                ,
                this.findClosestPointOnPath = function(e, n) {
                    var i = t.jsBezier.nearestPointOnCurve({
                        x: e,
                        y: n
                    }, this.curve);
                    return {
                        d: Math.sqrt(Math.pow(i.point.x - e, 2) + Math.pow(i.point.y - n, 2)),
                        x: i.point.x,
                        y: i.point.y,
                        l: 1 - i.location,
                        s: this
                    }
                }
                ,
                this.lineIntersection = function(e, n, i, r) {
                    return t.jsBezier.lineIntersection(e, n, i, r, this.curve)
                }
            }
        },
        e.SegmentRenderer = {
            getPath: function(t, e) {
                return {
                    Straight: function(e) {
                        var n = t.getCoordinates();
                        return (e ? 'M ' + n.x1 + ' ' + n.y1 + ' ' : '') + 'L ' + n.x2 + ' ' + n.y2
                    },
                    Bezier: function(e) {
                        var n = t.params;
                        return (e ? 'M ' + n.x2 + ' ' + n.y2 + ' ' : '') + 'C ' + n.cp2x + ' ' + n.cp2y + ' ' + n.cp1x + ' ' + n.cp1y + ' ' + n.x1 + ' ' + n.y1
                    },
                    Arc: function(e) {
                        var n = t.params
                          , i = t.sweep > Math.PI ? 1 : 0
                          , r = t.anticlockwise ? 0 : 1;
                        return (e ? 'M' + t.x1 + ' ' + t.y1 + ' ' : '') + 'A ' + t.radius + ' ' + n.r + ' 0 ' + i + ',' + r + ' ' + t.x2 + ' ' + t.y2
                    }
                }[t.type](e)
            }
        };
        var r = function() {
            this.resetBounds = function() {
                this.bounds = {
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                }
            }
            ,
            this.resetBounds()
        };
        e.Connectors.AbstractConnector = function(t) {
            r.apply(this, arguments);
            var o = []
              , a = 0
              , s = []
              , l = []
              , c = t.stub || 0
              , h = n.isArray(c) ? c[0] : c
              , u = n.isArray(c) ? c[1] : c
              , p = t.gap || 0
              , d = n.isArray(p) ? p[0] : p
              , f = n.isArray(p) ? p[1] : p
              , m = null
              , g = null;
            this.getPathData = function() {
                for (var t = '', n = 0; n < o.length; n++)
                    t += e.SegmentRenderer.getPath(o[n], 0 === n),
                    t += ' ';
                return t
            }
            ,
            this.findSegmentForPoint = function(t, e) {
                for (var n = {
                    d: 1 / 0,
                    s: null,
                    x: null,
                    y: null,
                    l: null
                }, i = 0; i < o.length; i++) {
                    var r = o[i].findClosestPointOnPath(t, e);
                    r.d < n.d && (n.d = r.d,
                    n.l = r.l,
                    n.x = r.x,
                    n.y = r.y,
                    n.s = o[i],
                    n.x1 = r.x1,
                    n.x2 = r.x2,
                    n.y1 = r.y1,
                    n.y2 = r.y2,
                    n.index = i,
                    n.connectorLocation = s[i][0] + r.l * (s[i][1] - s[i][0]))
                }
                return n
            }
            ,
            this.lineIntersection = function(t, e, n, i) {
                for (var r = [], a = 0; a < o.length; a++)
                    r.push.apply(r, o[a].lineIntersection(t, e, n, i));
                return r
            }
            ,
            this.boxIntersection = function(t, e, n, i) {
                for (var r = [], a = 0; a < o.length; a++)
                    r.push.apply(r, o[a].boxIntersection(t, e, n, i));
                return r
            }
            ,
            this.boundingBoxIntersection = function(t) {
                for (var e = [], n = 0; n < o.length; n++)
                    e.push.apply(e, o[n].boundingBoxIntersection(t));
                return e
            }
            ;
            var v = function() {
                for (var t = 0, e = 0; e < o.length; e++) {
                    var n = o[e].getLength();
                    l[e] = n / a,
                    s[e] = [t, t += n / a]
                }
            }
              , y = function(t, e) {
                e && (t = t > 0 ? t / a : (a + t) / a);
                for (var n = s.length - 1, i = 1, r = 0; r < s.length; r++)
                    if (s[r][1] >= t) {
                        n = r,
                        i = 1 === t ? 1 : 0 === t ? 0 : (t - s[r][0]) / l[r];
                        break
                    }
                return {
                    segment: o[n],
                    proportion: i,
                    index: n
                }
            }
              , x = function(t, n, i) {
                if (i.x1 !== i.x2 || i.y1 !== i.y2) {
                    var r = new e.Segments[n](i);
                    o.push(r),
                    a += r.getLength(),
                    t.updateBounds(r)
                }
            }
              , b = function() {
                a = o.length = s.length = l.length = 0
            };
            this.setSegments = function(t) {
                m = [],
                a = 0;
                for (var e = 0; e < t.length; e++)
                    m.push(t[e]),
                    a += t[e].getLength()
            }
            ,
            this.getLength = function() {
                return a
            }
            ;
            var _ = function(t) {
                this.strokeWidth = t.strokeWidth;
                var e = i.quadrant(t.sourcePos, t.targetPos)
                  , n = t.targetPos[0] < t.sourcePos[0]
                  , r = t.targetPos[1] < t.sourcePos[1]
                  , o = t.strokeWidth || 1
                  , a = t.sourceEndpoint.anchor.getOrientation(t.sourceEndpoint)
                  , s = t.targetEndpoint.anchor.getOrientation(t.targetEndpoint)
                  , l = n ? t.targetPos[0] : t.sourcePos[0]
                  , c = r ? t.targetPos[1] : t.sourcePos[1]
                  , p = Math.abs(t.targetPos[0] - t.sourcePos[0])
                  , m = Math.abs(t.targetPos[1] - t.sourcePos[1]);
                if (0 === a[0] && 0 === a[1] || 0 === s[0] && 0 === s[1]) {
                    var g = p > m ? 0 : 1
                      , v = [1, 0][g];
                    s = [],
                    (a = [])[g] = t.sourcePos[g] > t.targetPos[g] ? -1 : 1,
                    s[g] = t.sourcePos[g] > t.targetPos[g] ? 1 : -1,
                    a[v] = 0,
                    s[v] = 0
                }
                var y = n ? p + d * a[0] : d * a[0]
                  , x = r ? m + d * a[1] : d * a[1]
                  , b = n ? f * s[0] : p + f * s[0]
                  , _ = r ? f * s[1] : m + f * s[1]
                  , M = a[0] * s[0] + a[1] * s[1]
                  , w = {
                    sx: y,
                    sy: x,
                    tx: b,
                    ty: _,
                    lw: o,
                    xSpan: Math.abs(b - y),
                    ySpan: Math.abs(_ - x),
                    mx: (y + b) / 2,
                    my: (x + _) / 2,
                    so: a,
                    to: s,
                    x: l,
                    y: c,
                    w: p,
                    h: m,
                    segment: e,
                    startStubX: y + a[0] * h,
                    startStubY: x + a[1] * h,
                    endStubX: b + s[0] * u,
                    endStubY: _ + s[1] * u,
                    isXGreaterThanStubTimes2: Math.abs(y - b) > h + u,
                    isYGreaterThanStubTimes2: Math.abs(x - _) > h + u,
                    opposite: -1 === M,
                    perpendicular: 0 === M,
                    orthogonal: 1 === M,
                    sourceAxis: 0 === a[0] ? 'y' : 'x',
                    points: [l, c, p, m, y, x, b, _],
                    stubs: [h, u]
                };
                return w.anchorOrientation = w.opposite ? 'opposite' : w.orthogonal ? 'orthogonal' : 'perpendicular',
                w
            };
            this.getSegments = function() {
                return o
            }
            ,
            this.updateBounds = function(t) {
                var e = t.getBounds();
                this.bounds.minX = Math.min(this.bounds.minX, e.minX),
                this.bounds.maxX = Math.max(this.bounds.maxX, e.maxX),
                this.bounds.minY = Math.min(this.bounds.minY, e.minY),
                this.bounds.maxY = Math.max(this.bounds.maxY, e.maxY)
            }
            ;
            return this.pointOnPath = function(t, e) {
                var n = y(t, e);
                return n.segment && n.segment.pointOnPath(n.proportion, !1) || [0, 0]
            }
            ,
            this.gradientAtPoint = function(t, e) {
                var n = y(t, e);
                return n.segment && n.segment.gradientAtPoint(n.proportion, !1) || 0
            }
            ,
            this.pointAlongPathFrom = function(t, e, n) {
                var i = y(t, n);
                return i.segment && i.segment.pointAlongPathFrom(i.proportion, e, !1) || [0, 0]
            }
            ,
            this.compute = function(t) {
                g = _.call(this, t),
                b(),
                this._compute(g, t),
                this.x = g.points[0],
                this.y = g.points[1],
                this.w = g.points[2],
                this.h = g.points[3],
                this.segment = g.segment,
                v()
            }
            ,
            {
                addSegment: x,
                prepareCompute: _,
                sourceStub: h,
                targetStub: u,
                maxStub: Math.max(h, u),
                sourceGap: d,
                targetGap: f,
                maxGap: Math.max(d, f)
            }
        }
        ,
        n.extend(e.Connectors.AbstractConnector, r),
        e.Endpoints.AbstractEndpoint = function(t) {
            r.apply(this, arguments);
            var e = this.compute = function(t, e, n, i) {
                var r = this._compute.apply(this, arguments);
                return this.x = r[0],
                this.y = r[1],
                this.w = r[2],
                this.h = r[3],
                this.bounds.minX = this.x,
                this.bounds.minY = this.y,
                this.bounds.maxX = this.x + this.w,
                this.bounds.maxY = this.y + this.h,
                r
            }
            ;
            return {
                compute: e,
                cssClass: t.cssClass
            }
        }
        ,
        n.extend(e.Endpoints.AbstractEndpoint, r),
        e.Endpoints.Dot = function(t) {
            this.type = 'Dot';
            e.Endpoints.AbstractEndpoint.apply(this, arguments);
            t = t || {},
            this.radius = t.radius || 10,
            this.defaultOffset = .5 * this.radius,
            this.defaultInnerRadius = this.radius / 3,
            this._compute = function(t, e, n, i) {
                this.radius = n.radius || this.radius;
                var r = t[0] - this.radius
                  , o = t[1] - this.radius
                  , a = 2 * this.radius
                  , s = 2 * this.radius;
                if (n.stroke) {
                    var l = n.strokeWidth || 1;
                    r -= l,
                    o -= l,
                    a += 2 * l,
                    s += 2 * l
                }
                return [r, o, a, s, this.radius]
            }
        }
        ,
        n.extend(e.Endpoints.Dot, e.Endpoints.AbstractEndpoint),
        e.Endpoints.Rectangle = function(t) {
            this.type = 'Rectangle';
            e.Endpoints.AbstractEndpoint.apply(this, arguments);
            t = t || {},
            this.width = t.width || 20,
            this.height = t.height || 20,
            this._compute = function(t, e, n, i) {
                var r = n.width || this.width
                  , o = n.height || this.height;
                return [t[0] - r / 2, t[1] - o / 2, r, o]
            }
        }
        ,
        n.extend(e.Endpoints.Rectangle, e.Endpoints.AbstractEndpoint);
        var o = function(t) {
            e.jsPlumbUIComponent.apply(this, arguments),
            this._jsPlumb.displayElements = []
        };
        n.extend(o, e.jsPlumbUIComponent, {
            getDisplayElements: function() {
                return this._jsPlumb.displayElements
            },
            appendDisplayElement: function(t) {
                this._jsPlumb.displayElements.push(t)
            }
        }),
        e.Endpoints.Image = function(i) {
            this.type = 'Image',
            o.apply(this, arguments),
            e.Endpoints.AbstractEndpoint.apply(this, arguments);
            var r = i.onload
              , a = i.src || i.url
              , s = i.cssClass ? ' ' + i.cssClass : '';
            this._jsPlumb.img = new Image,
            this._jsPlumb.ready = !1,
            this._jsPlumb.initialized = !1,
            this._jsPlumb.deleted = !1,
            this._jsPlumb.widthToUse = i.width,
            this._jsPlumb.heightToUse = i.height,
            this._jsPlumb.endpoint = i.endpoint,
            this._jsPlumb.img.onload = function() {
                null != this._jsPlumb && (this._jsPlumb.ready = !0,
                this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width,
                this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height,
                r && r(this))
            }
            .bind(this),
            this._jsPlumb.endpoint.setImage = function(t, e) {
                var n = t.constructor === String ? t : t.src;
                r = e,
                this._jsPlumb.img.src = n,
                null != this.canvas && this.canvas.setAttribute('src', this._jsPlumb.img.src)
            }
            .bind(this),
            this._jsPlumb.endpoint.setImage(a, r),
            this._compute = function(t, e, n, i) {
                return this.anchorPoint = t,
                this._jsPlumb.ready ? [t[0] - this._jsPlumb.widthToUse / 2, t[1] - this._jsPlumb.heightToUse / 2, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse] : [0, 0, 0, 0]
            }
            ,
            this.canvas = e.createElement('img', {
                position: 'absolute',
                margin: 0,
                padding: 0,
                outline: 0
            }, this._jsPlumb.instance.endpointClass + s),
            this._jsPlumb.widthToUse && this.canvas.setAttribute('width', this._jsPlumb.widthToUse),
            this._jsPlumb.heightToUse && this.canvas.setAttribute('height', this._jsPlumb.heightToUse),
            this._jsPlumb.instance.appendElement(this.canvas),
            this.actuallyPaint = function(t, e, i) {
                if (!this._jsPlumb.deleted) {
                    this._jsPlumb.initialized || (this.canvas.setAttribute('src', this._jsPlumb.img.src),
                    this.appendDisplayElement(this.canvas),
                    this._jsPlumb.initialized = !0);
                    var r = this.anchorPoint[0] - this._jsPlumb.widthToUse / 2
                      , o = this.anchorPoint[1] - this._jsPlumb.heightToUse / 2;
                    n.sizeElement(this.canvas, r, o, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse)
                }
            }
            ,
            this.paint = function(e, n) {
                null != this._jsPlumb && (this._jsPlumb.ready ? this.actuallyPaint(e, n) : t.setTimeout(function() {
                    this.paint(e, n)
                }
                .bind(this), 200))
            }
        }
        ,
        n.extend(e.Endpoints.Image, [o, e.Endpoints.AbstractEndpoint], {
            cleanup: function(t) {
                t && (this._jsPlumb.deleted = !0,
                this.canvas && this.canvas.parentNode.removeChild(this.canvas),
                this.canvas = null)
            }
        }),
        e.Endpoints.Blank = function(t) {
            e.Endpoints.AbstractEndpoint.apply(this, arguments);
            this.type = 'Blank',
            o.apply(this, arguments),
            this._compute = function(t, e, n, i) {
                return [t[0], t[1], 10, 0]
            }
            ;
            var i = t.cssClass ? ' ' + t.cssClass : '';
            this.canvas = e.createElement('div', {
                display: 'block',
                width: '1px',
                height: '1px',
                background: 'transparent',
                position: 'absolute'
            }, this._jsPlumb.instance.endpointClass + i),
            this._jsPlumb.instance.appendElement(this.canvas),
            this.paint = function(t, e) {
                n.sizeElement(this.canvas, this.x, this.y, this.w, this.h)
            }
        }
        ,
        n.extend(e.Endpoints.Blank, [e.Endpoints.AbstractEndpoint, o], {
            cleanup: function() {
                this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)
            }
        }),
        e.Endpoints.Triangle = function(t) {
            this.type = 'Triangle',
            e.Endpoints.AbstractEndpoint.apply(this, arguments);
            var n = this;
            (t = t || {}).width = t.width || 55,
            t.height = t.height || 55,
            this.width = t.width,
            this.height = t.height,
            this._compute = function(t, e, i, r) {
                var o = i.width || n.width
                  , a = i.height || n.height;
                return [t[0] - o / 2, t[1] - a / 2, o, a]
            }
        }
        ;
        var a = e.Overlays.AbstractOverlay = function(t) {
            this.visible = !0,
            this.isAppendedAtTopLevel = !0,
            this.component = t.component,
            this.loc = null == t.location ? .5 : t.location,
            this.endpointLoc = null == t.endpointLocation ? [.5, .5] : t.endpointLocation,
            this.visible = !1 !== t.visible
        }
        ;
        a.prototype = {
            cleanup: function(t) {
                t && (this.component = null,
                this.canvas = null,
                this.endpointLoc = null)
            },
            reattach: function(t, e) {},
            setVisible: function(t) {
                this.visible = t,
                this.component.repaint()
            },
            isVisible: function() {
                return this.visible
            },
            hide: function() {
                this.setVisible(!1)
            },
            show: function() {
                this.setVisible(!0)
            },
            incrementLocation: function(t) {
                this.loc += t,
                this.component.repaint()
            },
            setLocation: function(t) {
                this.loc = t,
                this.component.repaint()
            },
            getLocation: function() {
                return this.loc
            },
            updateFrom: function() {}
        },
        e.Overlays.Arrow = function(t) {
            this.type = 'Arrow',
            a.apply(this, arguments),
            this.isAppendedAtTopLevel = !1,
            t = t || {};
            var r = this;
            this.length = t.length || 20,
            this.width = t.width || 20,
            this.id = t.id,
            this.direction = (t.direction || 1) < 0 ? -1 : 1;
            var o = t.paintStyle || {
                'stroke-width': 1
            }
              , s = t.foldback || .623;
            this.computeMaxSize = function() {
                return 1.5 * r.width
            }
            ,
            this.elementCreated = function(n, i) {
                if (this.path = n,
                t.events)
                    for (var r in t.events)
                        e.on(n, r, t.events[r])
            }
            ,
            this.draw = function(t, e) {
                var r, a, l, c;
                if (t.pointAlongPathFrom) {
                    if (n.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                        var h = parseInt(this.loc, 10)
                          , u = this.loc < 0 ? 1 : 0;
                        r = t.pointAlongPathFrom(u, h, !1),
                        a = t.pointAlongPathFrom(u, h - this.direction * this.length / 2, !1),
                        l = i.pointOnLine(r, a, this.length)
                    } else if (1 === this.loc) {
                        if (r = t.pointOnPath(this.loc),
                        a = t.pointAlongPathFrom(this.loc, -this.length),
                        l = i.pointOnLine(r, a, this.length),
                        -1 === this.direction) {
                            var p = l;
                            l = r,
                            r = p
                        }
                    } else if (0 === this.loc) {
                        if (l = t.pointOnPath(this.loc),
                        a = t.pointAlongPathFrom(this.loc, this.length),
                        r = i.pointOnLine(l, a, this.length),
                        -1 === this.direction) {
                            var d = l;
                            l = r,
                            r = d
                        }
                    } else
                        r = t.pointAlongPathFrom(this.loc, this.direction * this.length / 2),
                        a = t.pointOnPath(this.loc),
                        l = i.pointOnLine(r, a, this.length);
                    var f = {
                        hxy: r,
                        tail: c = i.perpendicularLineTo(r, l, this.width),
                        cxy: i.pointOnLine(r, l, s * this.length)
                    }
                      , m = o.stroke || e.stroke
                      , g = o.fill || e.stroke;
                    return {
                        component: t,
                        d: f,
                        'stroke-width': o.strokeWidth || e.strokeWidth,
                        stroke: m,
                        fill: g,
                        minX: Math.min(r.x, c[0].x, c[1].x),
                        maxX: Math.max(r.x, c[0].x, c[1].x),
                        minY: Math.min(r.y, c[0].y, c[1].y),
                        maxY: Math.max(r.y, c[0].y, c[1].y)
                    }
                }
                return {
                    component: t,
                    minX: 0,
                    maxX: 0,
                    minY: 0,
                    maxY: 0
                }
            }
        }
        ,
        n.extend(e.Overlays.Arrow, a, {
            updateFrom: function(t) {
                this.length = t.length || this.length,
                this.width = t.width || this.width,
                this.direction = null != t.direction ? t.direction : this.direction,
                this.foldback = t.foldback || this.foldback
            },
            cleanup: function() {
                this.path && this.canvas && this.canvas.removeChild(this.path)
            }
        }),
        e.Overlays.PlainArrow = function(t) {
            t = t || {};
            var n = e.extend(t, {
                foldback: 1
            });
            e.Overlays.Arrow.call(this, n),
            this.type = 'PlainArrow'
        }
        ,
        n.extend(e.Overlays.PlainArrow, e.Overlays.Arrow),
        e.Overlays.Diamond = function(t) {
            var n = (t = t || {}).length || 40
              , i = e.extend(t, {
                length: n / 2,
                foldback: 2
            });
            e.Overlays.Arrow.call(this, i),
            this.type = 'Diamond'
        }
        ,
        n.extend(e.Overlays.Diamond, e.Overlays.Arrow);
        var s = function(t, e) {
            return (null == t._jsPlumb.cachedDimensions || e) && (t._jsPlumb.cachedDimensions = t.getDimensions()),
            t._jsPlumb.cachedDimensions
        }
          , l = function(t) {
            e.jsPlumbUIComponent.apply(this, arguments),
            a.apply(this, arguments);
            var i = this.fire;
            this.fire = function() {
                i.apply(this, arguments),
                this.component && this.component.fire.apply(this.component, arguments)
            }
            ,
            this.detached = !1,
            this.id = t.id,
            this._jsPlumb.div = null,
            this._jsPlumb.initialised = !1,
            this._jsPlumb.component = t.component,
            this._jsPlumb.cachedDimensions = null,
            this._jsPlumb.create = t.create,
            this._jsPlumb.initiallyInvisible = !1 === t.visible,
            this.getElement = function() {
                if (null == this._jsPlumb.div) {
                    var n = this._jsPlumb.div = e.getElement(this._jsPlumb.create(this._jsPlumb.component));
                    n.style.position = 'absolute',
                    jsPlumb.addClass(n, this._jsPlumb.instance.overlayClass + ' ' + (this.cssClass ? this.cssClass : t.cssClass ? t.cssClass : '')),
                    this._jsPlumb.instance.appendElement(n),
                    this._jsPlumb.instance.getId(n),
                    this.canvas = n;
                    var i = 'translate(-50%, -50%)';
                    n.style.webkitTransform = i,
                    n.style.mozTransform = i,
                    n.style.msTransform = i,
                    n.style.oTransform = i,
                    n.style.transform = i,
                    n._jsPlumb = this,
                    !1 === t.visible && (n.style.display = 'none')
                }
                return this._jsPlumb.div
            }
            ,
            this.draw = function(t, e, i) {
                var r = s(this);
                if (null != r && 2 === r.length) {
                    var o = {
                        x: 0,
                        y: 0
                    };
                    if (i)
                        o = {
                            x: i[0],
                            y: i[1]
                        };
                    else if (t.pointOnPath) {
                        var a = this.loc
                          , l = !1;
                        (n.isString(this.loc) || this.loc < 0 || this.loc > 1) && (a = parseInt(this.loc, 10),
                        l = !0),
                        o = t.pointOnPath(a, l)
                    } else {
                        var c = this.loc.constructor === Array ? this.loc : this.endpointLoc;
                        o = {
                            x: c[0] * t.w,
                            y: c[1] * t.h
                        }
                    }
                    var h = o.x - r[0] / 2
                      , u = o.y - r[1] / 2;
                    return {
                        component: t,
                        d: {
                            minx: h,
                            miny: u,
                            td: r,
                            cxy: o
                        },
                        minX: h,
                        maxX: h + r[0],
                        minY: u,
                        maxY: u + r[1]
                    }
                }
                return {
                    minX: 0,
                    maxX: 0,
                    minY: 0,
                    maxY: 0
                }
            }
        };
        n.extend(l, [e.jsPlumbUIComponent, a], {
            getDimensions: function() {
                return [1, 1]
            },
            setVisible: function(t) {
                this._jsPlumb.div && (this._jsPlumb.div.style.display = t ? 'block' : 'none',
                t && this._jsPlumb.initiallyInvisible && (s(this, !0),
                this.component.repaint(),
                this._jsPlumb.initiallyInvisible = !1))
            },
            clearCachedDimensions: function() {
                this._jsPlumb.cachedDimensions = null
            },
            cleanup: function(t) {
                t ? null != this._jsPlumb.div && (this._jsPlumb.div._jsPlumb = null,
                this._jsPlumb.instance.removeElement(this._jsPlumb.div)) : (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div),
                this.detached = !0)
            },
            reattach: function(t, e) {
                null != this._jsPlumb.div && t.getContainer().appendChild(this._jsPlumb.div),
                this.detached = !1
            },
            computeMaxSize: function() {
                var t = s(this);
                return Math.max(t[0], t[1])
            },
            paint: function(t, e) {
                this._jsPlumb.initialised || (this.getElement(),
                t.component.appendDisplayElement(this._jsPlumb.div),
                this._jsPlumb.initialised = !0,
                this.detached && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div)),
                this._jsPlumb.div.style.left = t.component.x + t.d.minx + 'px',
                this._jsPlumb.div.style.top = t.component.y + t.d.miny + 'px'
            }
        }),
        e.Overlays.Custom = function(t) {
            this.type = 'Custom',
            l.apply(this, arguments)
        }
        ,
        n.extend(e.Overlays.Custom, l),
        e.Overlays.GuideLines = function() {
            var t = this;
            t.length = 50,
            t.strokeWidth = 5,
            this.type = 'GuideLines',
            a.apply(this, arguments),
            e.jsPlumbUIComponent.apply(this, arguments),
            this.draw = function(e, n) {
                var r = e.pointAlongPathFrom(t.loc, t.length / 2)
                  , o = e.pointOnPath(t.loc)
                  , a = i.pointOnLine(r, o, t.length)
                  , s = i.perpendicularLineTo(r, a, 40)
                  , l = i.perpendicularLineTo(a, r, 20);
                return {
                    connector: e,
                    head: r,
                    tail: a,
                    headLine: l,
                    tailLine: s,
                    minX: Math.min(r.x, a.x, l[0].x, l[1].x),
                    minY: Math.min(r.y, a.y, l[0].y, l[1].y),
                    maxX: Math.max(r.x, a.x, l[0].x, l[1].x),
                    maxY: Math.max(r.y, a.y, l[0].y, l[1].y)
                }
            }
        }
        ,
        e.Overlays.Label = function(t) {
            this.labelStyle = t.labelStyle;
            this.cssClass = null != this.labelStyle ? this.labelStyle.cssClass : null;
            var n = e.extend({
                create: function() {
                    return e.createElement('div')
                }
            }, t);
            if (e.Overlays.Custom.call(this, n),
            this.type = 'Label',
            this.label = t.label || '',
            this.labelText = null,
            this.labelStyle) {
                var i = this.getElement();
                if (this.labelStyle.font = this.labelStyle.font || '12px sans-serif',
                i.style.font = this.labelStyle.font,
                i.style.color = this.labelStyle.color || 'black',
                this.labelStyle.fill && (i.style.background = this.labelStyle.fill),
                this.labelStyle.borderWidth > 0) {
                    var r = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : 'black';
                    i.style.border = this.labelStyle.borderWidth + 'px solid ' + r
                }
                this.labelStyle.padding && (i.style.padding = this.labelStyle.padding)
            }
        }
        ,
        n.extend(e.Overlays.Label, e.Overlays.Custom, {
            cleanup: function(t) {
                t && (this.div = null,
                this.label = null,
                this.labelText = null,
                this.cssClass = null,
                this.labelStyle = null)
            },
            getLabel: function() {
                return this.label
            },
            setLabel: function(t) {
                this.label = t,
                this.labelText = null,
                this.clearCachedDimensions(),
                this.update(),
                this.component.repaint()
            },
            getDimensions: function() {
                return this.update(),
                l.prototype.getDimensions.apply(this, arguments)
            },
            update: function() {
                if ('function' == typeof this.label) {
                    var t = this.label(this);
                    this.getElement().innerHTML = t.replace(/\r\n/g, '<br/>')
                } else
                    null == this.labelText && (this.labelText = this.label,
                    this.getElement().innerHTML = this.labelText.replace(/\r\n/g, '<br/>'))
            },
            updateFrom: function(t) {
                null != t.label && this.setLabel(t.label)
            }
        })
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , e = t.jsPlumbUtil
          , n = t.jsPlumbInstance
          , i = 'stop'
          , r = 'revert'
          , o = '_jsPlumbGroup'
          , a = 'show'
          , s = 'hide'
          , l = function(t) {
            var n = {}
              , i = {}
              , r = {}
              , l = this;
            function c(e, n) {
                for (var i = e.getMembers(), r = 0; r < i.length; r++)
                    t[n ? a : s](i[r], !0)
            }
            t.bind('connection', (function(t) {
                null != t.source[o] && null != t.target[o] && t.source[o] === t.target[o] ? (i[t.connection.id] = t.source[o],
                r[t.connection.id] = t.source[o]) : (null != t.source[o] && (e.suggest(t.source[o].connections.source, t.connection),
                i[t.connection.id] = t.source[o]),
                null != t.target[o] && (e.suggest(t.target[o].connections.target, t.connection),
                r[t.connection.id] = t.target[o]))
            }
            )),
            t.bind('internal.connectionDetached', (function(t) {
                !function(t) {
                    delete t.proxies;
                    var n, o = i[t.id];
                    null != o && (n = function(e) {
                        return e.id === t.id
                    }
                    ,
                    e.removeWithFunction(o.connections.source, n),
                    e.removeWithFunction(o.connections.target, n),
                    delete i[t.id]),
                    null != (o = r[t.id]) && (n = function(e) {
                        return e.id === t.id
                    }
                    ,
                    e.removeWithFunction(o.connections.source, n),
                    e.removeWithFunction(o.connections.target, n),
                    delete r[t.id])
                }(t.connection)
            }
            )),
            t.bind('connectionMoved', (function(t) {
                var e = (0 === t.index ? i : r)[t.connection.id];
                if (e) {
                    var n = e.connections[0 === t.index ? 'source' : 'target']
                      , o = n.indexOf(t.connection);
                    -1 !== o && n.splice(o, 1)
                }
            }
            )),
            this.addGroup = function(e) {
                t.addClass(e.getEl(), 'jtk-group-expanded'),
                n[e.id] = e,
                e.manager = this,
                p(e),
                t.fire('group:add', {
                    group: e
                })
            }
            ,
            this.addToGroup = function(e, n, i) {
                if (e = this.getGroup(e)) {
                    var r = e.getEl();
                    if (n._isJsPlumbGroup)
                        return;
                    var o = n._jsPlumbGroup;
                    if (o !== e) {
                        t.removeFromDragSelection(n);
                        var a = t.getOffset(n, !0)
                          , s = e.collapsed ? t.getOffset(r, !0) : t.getOffset(e.getDragArea(), !0);
                        null != o && (o.remove(n, !1, i, !1, e),
                        l.updateConnectionsForGroup(o)),
                        e.add(n, i);
                        var c = function(t, n) {
                            var i = 0 === n ? 1 : 0;
                            t.each((function(t) {
                                t.setVisible(!1),
                                t.endpoints[i].element._jsPlumbGroup === e ? (t.endpoints[i].setVisible(!1),
                                u(t, i, e)) : (t.endpoints[n].setVisible(!1),
                                h(t, n, e))
                            }
                            ))
                        };
                        e.collapsed && (c(t.select({
                            source: n
                        }), 0),
                        c(t.select({
                            target: n
                        }), 1));
                        var p = t.getId(n);
                        t.dragManager.setParent(n, p, r, t.getId(r), a);
                        var d = {
                            left: a.left - s.left,
                            top: a.top - s.top
                        };
                        if (t.setPosition(n, d),
                        t.dragManager.revalidateParent(n, p, a),
                        l.updateConnectionsForGroup(e),
                        t.revalidate(p),
                        !i) {
                            var f = {
                                group: e,
                                el: n,
                                pos: d
                            };
                            o && (f.sourceGroup = o),
                            t.fire('group:addMember', f)
                        }
                    }
                }
            }
            ,
            this.removeFromGroup = function(t, e, n) {
                (t = this.getGroup(t)) && t.remove(e, null, n)
            }
            ,
            this.getGroup = function(t) {
                var i = t;
                if (e.isString(t) && null == (i = n[t]))
                    throw new TypeError('No such group [' + t + ']');
                return i
            }
            ,
            this.getGroups = function() {
                var t = [];
                for (var e in n)
                    t.push(n[e]);
                return t
            }
            ,
            this.removeGroup = function(e, i, r, o) {
                e = this.getGroup(e),
                this.expandGroup(e, !0);
                var a = e[i ? 'removeAll' : 'orphanAll'](r, o);
                return t.remove(e.getEl()),
                delete n[e.id],
                delete t._groups[e.id],
                t.fire('group:remove', {
                    group: e
                }),
                a
            }
            ,
            this.removeAllGroups = function(t, e, i) {
                for (var r in n)
                    this.removeGroup(n[r], t, e, i)
            }
            ;
            var h = function(e, n, i) {
                var r = e.endpoints[0 === n ? 1 : 0].element;
                if (!r[o] || r[o].shouldProxy() || !r[o].collapsed) {
                    var a = i.getEl()
                      , s = t.getId(a);
                    t.proxyConnection(e, n, a, s, (function(t, e) {
                        return i.getEndpoint(t, e)
                    }
                    ), (function(t, e) {
                        return i.getAnchor(t, e)
                    }
                    ))
                }
            };
            this.collapseGroup = function(e) {
                if (null != (e = this.getGroup(e)) && !e.collapsed) {
                    var n = e.getEl();
                    if (c(e, !1),
                    e.shouldProxy()) {
                        var i = function(t, n) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                h(r, n, e)
                            }
                        };
                        i(e.connections.source, 0),
                        i(e.connections.target, 1)
                    }
                    e.collapsed = !0,
                    t.removeClass(n, 'jtk-group-expanded'),
                    t.addClass(n, 'jtk-group-collapsed'),
                    t.revalidate(n),
                    t.fire('group:collapse', {
                        group: e
                    })
                }
            }
            ;
            var u = function(e, n, i) {
                t.unproxyConnection(e, n, t.getId(i.getEl()))
            };
            function p(e) {
                var n = e.getMembers()
                  , o = t.getConnections({
                    source: n,
                    scope: '*'
                }, !0)
                  , a = t.getConnections({
                    target: n,
                    scope: '*'
                }, !0)
                  , s = {};
                e.connections.source.length = 0,
                e.connections.target.length = 0;
                var l = function(t) {
                    for (var n = 0; n < t.length; n++)
                        s[t[n].id] || (s[t[n].id] = !0,
                        t[n].source._jsPlumbGroup === e ? (t[n].target._jsPlumbGroup !== e && e.connections.source.push(t[n]),
                        i[t[n].id] = e) : t[n].target._jsPlumbGroup === e && (e.connections.target.push(t[n]),
                        r[t[n].id] = e))
                };
                l(o),
                l(a)
            }
            this.expandGroup = function(e, n) {
                if (null != (e = this.getGroup(e)) && e.collapsed) {
                    var i = e.getEl();
                    if (c(e, !0),
                    e.shouldProxy()) {
                        var r = function(t, n) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                u(r, n, e)
                            }
                        };
                        r(e.connections.source, 0),
                        r(e.connections.target, 1)
                    }
                    e.collapsed = !1,
                    t.addClass(i, 'jtk-group-expanded'),
                    t.removeClass(i, 'jtk-group-collapsed'),
                    t.revalidate(i),
                    this.repaintGroup(e),
                    n || t.fire('group:expand', {
                        group: e
                    })
                }
            }
            ,
            this.repaintGroup = function(e) {
                for (var n = (e = this.getGroup(e)).getMembers(), i = 0; i < n.length; i++)
                    t.revalidate(n[i])
            }
            ,
            this.updateConnectionsForGroup = p,
            this.refreshAllGroups = function() {
                for (var e in n)
                    p(n[e]),
                    t.dragManager.updateOffsets(t.getId(n[e].getEl()))
            }
        }
          , c = function(n, a) {
            var s = this
              , l = a.el;
            this.getEl = function() {
                return l
            }
            ,
            this.id = a.id || e.uuid(),
            l._isJsPlumbGroup = !0;
            var c = this.getDragArea = function() {
                var t = n.getSelector(l, '[jtk-group-content]');
                return t && t.length > 0 ? t[0] : l
            }
              , h = !0 === a.ghost
              , u = h || !0 === a.constrain
              , p = !1 !== a.revert
              , d = !0 === a.orphan
              , f = !0 === a.prune
              , m = !0 === a.dropOverride
              , g = !1 !== a.proxied
              , v = [];
            if (this.connections = {
                source: [],
                target: [],
                internal: []
            },
            this.getAnchor = function(t, e) {
                return a.anchor || 'Continuous'
            }
            ,
            this.getEndpoint = function(t, e) {
                return a.endpoint || ['Dot', {
                    radius: 10
                }]
            }
            ,
            this.collapsed = !1,
            !1 !== a.draggable) {
                var y = {
                    stop: function(t) {
                        n.fire('groupDragStop', jsPlumb.extend(t, {
                            group: s
                        }))
                    },
                    scope: '_jsPlumbGroupDrag'
                };
                a.dragOptions && t.jsPlumb.extend(y, a.dragOptions),
                n.draggable(a.el, y)
            }
            !1 !== a.droppable && n.droppable(a.el, {
                drop: function(t) {
                    var e = t.drag.el;
                    if (!e._isJsPlumbGroup) {
                        var i = e._jsPlumbGroup;
                        if (i !== s) {
                            if (null != i && i.overrideDrop(e, s))
                                return;
                            n.getGroupManager().addToGroup(s, e, !1)
                        }
                    }
                }
            });
            var x = function(t, e) {
                for (var n = null == t.nodeType ? t : [t], i = 0; i < n.length; i++)
                    e(n[i])
            };
            function b(t, e) {
                var i = function(t) {
                    return t.offsetParent
                }(t)
                  , r = n.getSize(i)
                  , o = n.getSize(t)
                  , a = e[0]
                  , s = a + o[0]
                  , l = e[1]
                  , c = l + o[1];
                return s > 0 && a < r[0] && c > 0 && l < r[1]
            }
            function _(t) {
                var e = n.getId(t)
                  , i = n.getOffset(t);
                return t.parentNode.removeChild(t),
                n.getContainer().appendChild(t),
                n.setPosition(t, i),
                S(t),
                n.dragManager.clearParent(t, e),
                [e, i]
            }
            function M(t) {
                var e = [];
                function i(t, e, i) {
                    var r = null;
                    if (!b(t, [e, i])) {
                        var o = t._jsPlumbGroup;
                        f ? n.remove(t) : r = _(t),
                        o.remove(t)
                    }
                    return r
                }
                for (var r = 0; r < t.selection.length; r++)
                    e.push(i(t.selection[r][0], t.selection[r][1].left, t.selection[r][1].top));
                return 1 === e.length ? e[0] : e
            }
            function w(t) {
                var e = n.getId(t);
                n.revalidate(t),
                n.dragManager.revalidateParent(t, e)
            }
            function S(t) {
                t._katavorioDrag && ((f || d) && t._katavorioDrag.off(i, M),
                f || d || !p || (t._katavorioDrag.off(r, w),
                t._katavorioDrag.setRevert(null)))
            }
            function P(t) {
                t._katavorioDrag && ((f || d) && t._katavorioDrag.on(i, M),
                u && t._katavorioDrag.setConstrain(!0),
                h && t._katavorioDrag.setUseGhostProxy(!0),
                f || d || !p || (t._katavorioDrag.on(r, w),
                t._katavorioDrag.setRevert((function(t, e) {
                    return !b(t, e)
                }
                ))))
            }
            this.overrideDrop = function(t, e) {
                return m && (p || f || d)
            }
            ,
            this.add = function(t, e) {
                var i = c();
                x(t, (function(t) {
                    if (null != t._jsPlumbGroup) {
                        if (t._jsPlumbGroup === s)
                            return;
                        t._jsPlumbGroup.remove(t, !0, e, !1)
                    }
                    t._jsPlumbGroup = s,
                    v.push(t),
                    n.isAlreadyDraggable(t) && P(t),
                    t.parentNode !== i && i.appendChild(t)
                }
                )),
                n.getGroupManager().updateConnectionsForGroup(s)
            }
            ,
            this.remove = function(t, i, r, o, a) {
                x(t, (function(t) {
                    if (t._jsPlumbGroup === s) {
                        if (delete t._jsPlumbGroup,
                        e.removeWithFunction(v, (function(e) {
                            return e === t
                        }
                        )),
                        i)
                            try {
                                s.getDragArea().removeChild(t)
                            } catch (t) {
                                jsPlumbUtil.log('Could not remove element from Group ' + t)
                            }
                        if (S(t),
                        !r) {
                            var o = {
                                group: s,
                                el: t
                            };
                            a && (o.targetGroup = a),
                            n.fire('group:removeMember', o)
                        }
                    }
                }
                )),
                o || n.getGroupManager().updateConnectionsForGroup(s)
            }
            ,
            this.removeAll = function(t, e) {
                for (var i = 0, r = v.length; i < r; i++) {
                    var o = v[0];
                    s.remove(o, t, e, !0),
                    n.remove(o, !0)
                }
                v.length = 0,
                n.getGroupManager().updateConnectionsForGroup(s)
            }
            ,
            this.orphanAll = function() {
                for (var t = {}, e = 0; e < v.length; e++) {
                    var n = _(v[e]);
                    t[n[0]] = n[1]
                }
                return v.length = 0,
                t
            }
            ,
            this.getMembers = function() {
                return v
            }
            ,
            l[o] = this,
            n.bind('elementDraggable', function(t) {
                t.el._jsPlumbGroup === this && P(t.el)
            }
            .bind(this)),
            this.shouldProxy = function() {
                return g
            }
            ,
            n.getGroupManager().addGroup(this)
        };
        n.prototype.addGroup = function(t) {
            var e = this;
            if (e._groups = e._groups || {},
            null != e._groups[t.id])
                throw new TypeError('cannot create Group [' + t.id + ']; a Group with that ID exists');
            if (null != t.el[o])
                throw new TypeError('cannot create Group [' + t.id + ']; the given element is already a Group');
            var n = new c(e,t);
            return e._groups[n.id] = n,
            t.collapsed && this.collapseGroup(n),
            n
        }
        ,
        n.prototype.addToGroup = function(t, e, n) {
            var i = function(e) {
                var i = this.getId(e);
                this.manage(i, e),
                this.getGroupManager().addToGroup(t, e, n)
            }
            .bind(this);
            if (Array.isArray(e))
                for (var r = 0; r < e.length; r++)
                    i(e[r]);
            else
                i(e)
        }
        ,
        n.prototype.removeFromGroup = function(t, e, n) {
            this.getGroupManager().removeFromGroup(t, e, n)
        }
        ,
        n.prototype.removeGroup = function(t, e, n, i) {
            return this.getGroupManager().removeGroup(t, e, n, i)
        }
        ,
        n.prototype.removeAllGroups = function(t, e, n) {
            this.getGroupManager().removeAllGroups(t, e, n)
        }
        ,
        n.prototype.getGroup = function(t) {
            return this.getGroupManager().getGroup(t)
        }
        ,
        n.prototype.getGroups = function() {
            return this.getGroupManager().getGroups()
        }
        ,
        n.prototype.expandGroup = function(t) {
            this.getGroupManager().expandGroup(t)
        }
        ,
        n.prototype.collapseGroup = function(t) {
            this.getGroupManager().collapseGroup(t)
        }
        ,
        n.prototype.repaintGroup = function(t) {
            this.getGroupManager().repaintGroup(t)
        }
        ,
        n.prototype.toggleGroup = function(t) {
            null != (t = this.getGroupManager().getGroup(t)) && this.getGroupManager()[t.collapsed ? 'expandGroup' : 'collapseGroup'](t)
        }
        ,
        n.prototype.getGroupManager = function() {
            var t = this._groupManager;
            return null == t && (t = this._groupManager = new l(this)),
            t
        }
        ,
        n.prototype.removeGroupManager = function() {
            delete this._groupManager
        }
        ,
        n.prototype.getGroupFor = function(t) {
            if (t = this.getElement(t))
                return t[o]
        }
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil;
        t.Connectors.Flowchart = function(e) {
            this.type = 'Flowchart',
            (e = e || {}).stub = null == e.stub ? 30 : e.stub;
            var n, i = t.Connectors.AbstractConnector.apply(this, arguments), r = null == e.midpoint ? .5 : e.midpoint, o = !0 === e.alwaysRespectStubs, a = null, s = null, l = null != e.cornerRadius ? e.cornerRadius : 0, c = (e.loopbackRadius,
            function(t) {
                return t < 0 ? -1 : 0 === t ? 0 : 1
            }
            ), h = function(t) {
                return [c(t[2] - t[0]), c(t[3] - t[1])]
            }, u = function(t, e, n, i) {
                if (a !== e || s !== n) {
                    var r = null == a ? i.sx : a
                      , o = null == s ? i.sy : s
                      , l = r === e ? 'v' : 'h';
                    a = e,
                    s = n,
                    t.push([r, o, e, n, l])
                }
            }, p = function(t) {
                return Math.sqrt(Math.pow(t[0] - t[2], 2) + Math.pow(t[1] - t[3], 2))
            }, d = function(t) {
                var e = [];
                return e.push.apply(e, t),
                e
            }, f = function(t, e, n) {
                for (var r, o, a, s = null, c = 0; c < e.length - 1; c++) {
                    if (s = s || d(e[c]),
                    r = d(e[c + 1]),
                    o = h(s),
                    a = h(r),
                    l > 0 && s[4] !== r[4]) {
                        var u = Math.min(p(s), p(r))
                          , f = Math.min(l, u / 2);
                        s[2] -= o[0] * f,
                        s[3] -= o[1] * f,
                        r[0] += a[0] * f,
                        r[1] += a[1] * f;
                        var m = o[1] === a[0] && 1 === a[0] || o[1] === a[0] && 0 === a[0] && o[0] !== a[1] || o[1] === a[0] && -1 === a[0]
                          , g = (r[1] > s[3] ? 1 : -1) === (r[0] > s[2] ? 1 : -1)
                          , v = g && m || !g && !m ? r[0] : s[2]
                          , y = g && m || !g && !m ? s[3] : r[1];
                        i.addSegment(t, 'Straight', {
                            x1: s[0],
                            y1: s[1],
                            x2: s[2],
                            y2: s[3]
                        }),
                        i.addSegment(t, 'Arc', {
                            r: f,
                            x1: s[2],
                            y1: s[3],
                            x2: r[0],
                            y2: r[1],
                            cx: v,
                            cy: y,
                            ac: m
                        })
                    } else {
                        var x = s[2] === s[0] ? 0 : s[2] > s[0] ? n.lw / 2 : -n.lw / 2
                          , b = s[3] === s[1] ? 0 : s[3] > s[1] ? n.lw / 2 : -n.lw / 2;
                        i.addSegment(t, 'Straight', {
                            x1: s[0] - x,
                            y1: s[1] - b,
                            x2: s[2] + x,
                            y2: s[3] + b
                        })
                    }
                    s = r
                }
                null != r && i.addSegment(t, 'Straight', {
                    x1: r[0],
                    y1: r[1],
                    x2: r[2],
                    y2: r[3]
                })
            };
            this._compute = function(t, e) {
                n = [],
                a = null,
                s = null,
                null;
                var l = function() {
                    return [t.startStubX, t.startStubY, t.endStubX, t.endStubY]
                }
                  , c = {
                    perpendicular: l,
                    orthogonal: l,
                    opposite: function(e) {
                        var n = t
                          , i = 'x' === e ? 0 : 1;
                        return !o && {
                            x: function() {
                                return 1 === n.so[i] && (n.startStubX > n.endStubX && n.tx > n.startStubX || n.sx > n.endStubX && n.tx > n.sx) || -1 === n.so[i] && (n.startStubX < n.endStubX && n.tx < n.startStubX || n.sx < n.endStubX && n.tx < n.sx)
                            },
                            y: function() {
                                return 1 === n.so[i] && (n.startStubY > n.endStubY && n.ty > n.startStubY || n.sy > n.endStubY && n.ty > n.sy) || -1 === n.so[i] && (n.startStubY < n.endStubY && n.ty < n.startStubY || n.sy < n.endStubY && n.ty < n.sy)
                            }
                        }[e]() ? {
                            x: [(t.sx + t.tx) / 2, t.startStubY, (t.sx + t.tx) / 2, t.endStubY],
                            y: [t.startStubX, (t.sy + t.ty) / 2, t.endStubX, (t.sy + t.ty) / 2]
                        }[e] : [t.startStubX, t.startStubY, t.endStubX, t.endStubY]
                    }
                }[t.anchorOrientation](t.sourceAxis)
                  , h = 'x' === t.sourceAxis ? 0 : 1
                  , p = 'x' === t.sourceAxis ? 1 : 0
                  , d = c[h]
                  , m = c[p]
                  , g = c[h + 2]
                  , v = c[p + 2];
                u(n, c[0], c[1], t);
                var y = t.startStubX + (t.endStubX - t.startStubX) * r
                  , x = t.startStubY + (t.endStubY - t.startStubY) * r
                  , b = {
                    x: [0, 1],
                    y: [1, 0]
                }
                  , _ = {
                    perpendicular: function(e) {
                        var n = t
                          , i = {
                            x: [[n.startStubX, n.endStubX], null, [n.endStubX, n.startStubX]],
                            y: [[n.startStubY, n.endStubY], null, [n.endStubY, n.startStubY]]
                        }
                          , r = {
                            x: [[y, n.startStubY], [y, n.endStubY]],
                            y: [[n.startStubX, x], [n.endStubX, x]]
                        }
                          , o = {
                            x: [[n.endStubX, n.startStubY]],
                            y: [[n.startStubX, n.endStubY]]
                        }
                          , a = {
                            x: [[n.startStubX, n.endStubY], [n.endStubX, n.endStubY]],
                            y: [[n.endStubX, n.startStubY], [n.endStubX, n.endStubY]]
                        }
                          , s = {
                            x: [[n.startStubX, x], [n.endStubX, x], [n.endStubX, n.endStubY]],
                            y: [[y, n.startStubY], [y, n.endStubY], [n.endStubX, n.endStubY]]
                        }
                          , l = {
                            x: [n.startStubY, n.endStubY],
                            y: [n.startStubX, n.endStubX]
                        }
                          , c = b[e][0]
                          , h = b[e][1]
                          , u = n.so[c] + 1
                          , p = n.to[h] + 1
                          , d = -1 === n.to[h] && l[e][1] < l[e][0] || 1 === n.to[h] && l[e][1] > l[e][0]
                          , f = i[e][u][0]
                          , m = i[e][u][1]
                          , g = {
                            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
                            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
                        }[e][u][p];
                        return n.segment === g[3] || n.segment === g[2] && d ? r[e] : n.segment === g[2] && m < f ? o[e] : n.segment === g[2] && m >= f || n.segment === g[1] && !d ? s[e] : n.segment === g[0] || n.segment === g[1] && d ? a[e] : void 0
                    },
                    orthogonal: function(e, n, i, r, o) {
                        var a = t
                          , s = {
                            x: -1 === a.so[0] ? Math.min(n, r) : Math.max(n, r),
                            y: -1 === a.so[1] ? Math.min(n, r) : Math.max(n, r)
                        }[e];
                        return {
                            x: [[s, i], [s, o], [r, o]],
                            y: [[i, s], [o, s], [o, r]]
                        }[e]
                    },
                    opposite: function(n, r, o, a) {
                        var s = t
                          , l = {
                            x: 'y',
                            y: 'x'
                        }[n]
                          , c = {
                            x: 'height',
                            y: 'width'
                        }[n]
                          , u = s['is' + n.toUpperCase() + 'GreaterThanStubTimes2'];
                        if (e.sourceEndpoint.elementId === e.targetEndpoint.elementId) {
                            var p = o + (1 - e.sourceEndpoint.anchor[l]) * e.sourceInfo[c] + i.maxStub;
                            return {
                                x: [[r, p], [a, p]],
                                y: [[p, r], [p, a]]
                            }[n]
                        }
                        return !u || 1 === s.so[h] && r > a || -1 === s.so[h] && r < a ? {
                            x: [[r, x], [a, x]],
                            y: [[y, r], [y, a]]
                        }[n] : 1 === s.so[h] && r < a || -1 === s.so[h] && r > a ? {
                            x: [[y, s.sy], [y, s.ty]],
                            y: [[s.sx, x], [s.tx, x]]
                        }[n] : void 0
                    }
                }[t.anchorOrientation](t.sourceAxis, d, m, g, v);
                if (_)
                    for (var M = 0; M < _.length; M++)
                        u(n, _[M][0], _[M][1], t);
                u(n, c[2], c[3], t),
                u(n, t.tx, t.ty, t),
                f(this, n, t)
            }
        }
        ,
        e.extend(t.Connectors.Flowchart, t.Connectors.AbstractConnector)
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil;
        t.Connectors.AbstractBezierConnector = function(e) {
            var n, i = !1 !== (e = e || {}).showLoopback, r = (e.curviness,
            e.margin || 5), o = (e.proximityLimit,
            e.orientation && 'clockwise' === e.orientation), a = e.loopbackRadius || 25;
            return this._compute = function(t, e) {
                var s = e.sourcePos
                  , l = e.targetPos
                  , c = Math.abs(s[0] - l[0])
                  , h = Math.abs(s[1] - l[1]);
                if (i && e.sourceEndpoint.elementId === e.targetEndpoint.elementId) {
                    !0;
                    var u = e.sourcePos[0]
                      , p = e.sourcePos[1] - r
                      , d = u
                      , f = p - a
                      , m = d - a
                      , g = f - a;
                    c = 2 * a,
                    h = 2 * a,
                    t.points[0] = m,
                    t.points[1] = g,
                    t.points[2] = c,
                    t.points[3] = h,
                    n.addSegment(this, 'Arc', {
                        loopback: !0,
                        x1: u - m + 4,
                        y1: p - g,
                        startAngle: 0,
                        endAngle: 2 * Math.PI,
                        r: a,
                        ac: !o,
                        x2: u - m - 4,
                        y2: p - g,
                        cx: d - m,
                        cy: f - g
                    })
                } else
                    !1,
                    this._computeBezier(t, e, s, l, c, h)
            }
            ,
            n = t.Connectors.AbstractConnector.apply(this, arguments)
        }
        ,
        e.extend(t.Connectors.AbstractBezierConnector, t.Connectors.AbstractConnector);
        var n = function(e) {
            e = e || {},
            this.type = 'Bezier';
            var n = t.Connectors.AbstractBezierConnector.apply(this, arguments)
              , i = e.curviness || 150
              , r = 10;
            this.getCurviness = function() {
                return i
            }
            ,
            this._findControlPoint = function(t, e, n, o, a, s, l) {
                var c = [];
                return s[0] !== l[0] || s[1] === l[1] ? (0 === l[0] ? c.push(n[0] < e[0] ? t[0] + r : t[0] - r) : c.push(t[0] + i * l[0]),
                0 === l[1] ? c.push(n[1] < e[1] ? t[1] + r : t[1] - r) : c.push(t[1] + i * s[1])) : (0 === s[0] ? c.push(e[0] < n[0] ? t[0] + r : t[0] - r) : c.push(t[0] - i * s[0]),
                0 === s[1] ? c.push(e[1] < n[1] ? t[1] + r : t[1] - r) : c.push(t[1] + i * l[1])),
                c
            }
            ,
            this._computeBezier = function(t, e, i, r, o, a) {
                var s, l, c = i[0] < r[0] ? o : 0, h = i[1] < r[1] ? a : 0, u = i[0] < r[0] ? 0 : o, p = i[1] < r[1] ? 0 : a;
                s = this._findControlPoint([c, h], i, r, e.sourceEndpoint, e.targetEndpoint, t.so, t.to),
                l = this._findControlPoint([u, p], r, i, e.targetEndpoint, e.sourceEndpoint, t.to, t.so),
                n.addSegment(this, 'Bezier', {
                    x1: c,
                    y1: h,
                    x2: u,
                    y2: p,
                    cp1x: s[0],
                    cp1y: s[1],
                    cp2x: l[0],
                    cp2y: l[1]
                })
            }
        };
        t.Connectors.Bezier = n,
        e.extend(n, t.Connectors.AbstractBezierConnector)
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil
          , n = function(t, e, n, i) {
            return t <= n && i <= e ? 1 : t <= n && e <= i ? 2 : n <= t && i >= e ? 3 : 4
        }
          , i = function(t, e, n, i, r, o, a, s, l) {
            return s <= l ? [t, e] : 1 === n ? i[3] <= 0 && r[3] >= 1 ? [t + (i[2] < .5 ? -1 * o : o), e] : i[2] >= 1 && r[2] <= 0 ? [t, e + (i[3] < .5 ? -1 * a : a)] : [t + -1 * o, e + -1 * a] : 2 === n ? i[3] >= 1 && r[3] <= 0 ? [t + (i[2] < .5 ? -1 * o : o), e] : i[2] >= 1 && r[2] <= 0 ? [t, e + (i[3] < .5 ? -1 * a : a)] : [t + o, e + -1 * a] : 3 === n ? i[3] >= 1 && r[3] <= 0 ? [t + (i[2] < .5 ? -1 * o : o), e] : i[2] <= 0 && r[2] >= 1 ? [t, e + (i[3] < .5 ? -1 * a : a)] : [t + -1 * o, e + -1 * a] : 4 === n ? i[3] <= 0 && r[3] >= 1 ? [t + (i[2] < .5 ? -1 * o : o), e] : i[2] <= 0 && r[2] >= 1 ? [t, e + (i[3] < .5 ? -1 * a : a)] : [t + o, e + -1 * a] : void 0
        }
          , r = function(e) {
            e = e || {},
            this.type = 'StateMachine';
            var r, o = t.Connectors.AbstractBezierConnector.apply(this, arguments), a = e.curviness || 10, s = e.margin || 5, l = e.proximityLimit || 80;
            e.orientation && e.orientation;
            this._computeBezier = function(t, e, c, h, u, p) {
                var d = e.sourcePos[0] < e.targetPos[0] ? 0 : u
                  , f = e.sourcePos[1] < e.targetPos[1] ? 0 : p
                  , m = e.sourcePos[0] < e.targetPos[0] ? u : 0
                  , g = e.sourcePos[1] < e.targetPos[1] ? p : 0;
                0 === e.sourcePos[2] && (d -= s),
                1 === e.sourcePos[2] && (d += s),
                0 === e.sourcePos[3] && (f -= s),
                1 === e.sourcePos[3] && (f += s),
                0 === e.targetPos[2] && (m -= s),
                1 === e.targetPos[2] && (m += s),
                0 === e.targetPos[3] && (g -= s),
                1 === e.targetPos[3] && (g += s);
                var v, y, x, b, _ = (d + m) / 2, M = (f + g) / 2, w = n(d, f, m, g), S = Math.sqrt(Math.pow(m - d, 2) + Math.pow(g - f, 2));
                v = (r = i(_, M, w, e.sourcePos, e.targetPos, a, a, S, l))[0],
                y = r[0],
                x = r[1],
                b = r[1],
                o.addSegment(this, 'Bezier', {
                    x1: m,
                    y1: g,
                    x2: d,
                    y2: f,
                    cp1x: v,
                    cp1y: x,
                    cp2x: y,
                    cp2y: b
                })
            }
        };
        t.Connectors.StateMachine = r,
        e.extend(r, t.Connectors.AbstractBezierConnector)
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil
          , n = function(e) {
            this.type = 'Straight';
            var n = t.Connectors.AbstractConnector.apply(this, arguments);
            this._compute = function(t, e) {
                n.addSegment(this, 'Straight', {
                    x1: t.sx,
                    y1: t.sy,
                    x2: t.startStubX,
                    y2: t.startStubY
                }),
                n.addSegment(this, 'Straight', {
                    x1: t.startStubX,
                    y1: t.startStubY,
                    x2: t.endStubX,
                    y2: t.endStubY
                }),
                n.addSegment(this, 'Straight', {
                    x1: t.endStubX,
                    y1: t.endStubY,
                    x2: t.tx,
                    y2: t.ty
                })
            }
        };
        t.Connectors.Straight = n,
        e.extend(n, t.Connectors.AbstractConnector)
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this.jsPlumb
          , e = this.jsPlumbUtil
          , n = {
            'stroke-linejoin': 'stroke-linejoin',
            'stroke-dashoffset': 'stroke-dashoffset',
            'stroke-linecap': 'stroke-linecap'
        }
          , i = 'http://www.w3.org/2000/svg'
          , r = function(t, e) {
            for (var n in e)
                t.setAttribute(n, '' + e[n])
        }
          , o = function(e, n) {
            return (n = n || {}).version = '1.1',
            n.xmlns = i,
            t.createElementNS(i, e, null, null, n)
        }
          , a = function(t) {
            return 'position:absolute;left:' + t[0] + 'px;top:' + t[1] + 'px'
        }
          , s = function(t) {
            for (var e = t.querySelectorAll(' defs,linearGradient,radialGradient'), n = 0; n < e.length; n++)
                e[n].parentNode.removeChild(e[n])
        }
          , l = function(t, e, i, r, a) {
            if (e.setAttribute('fill', i.fill ? i.fill : 'none'),
            e.setAttribute('stroke', i.stroke ? i.stroke : 'none'),
            i.gradient ? function(t, e, n, i, r) {
                var a, l = 'jsplumb_gradient_' + r._jsPlumb.instance.idstamp();
                s(t),
                a = n.gradient.offset ? o('radialGradient', {
                    id: l
                }) : o('linearGradient', {
                    id: l,
                    gradientUnits: 'userSpaceOnUse'
                });
                var c = o('defs');
                t.appendChild(c),
                c.appendChild(a);
                for (var h = 0; h < n.gradient.stops.length; h++) {
                    var u = 1 === r.segment || 2 === r.segment ? h : n.gradient.stops.length - 1 - h
                      , p = n.gradient.stops[u][1]
                      , d = o('stop', {
                        offset: Math.floor(100 * n.gradient.stops[h][0]) + '%',
                        'stop-color': p
                    });
                    a.appendChild(d)
                }
                var f = n.stroke ? 'stroke' : 'fill';
                e.setAttribute(f, 'url(#' + l + ')')
            }(t, e, i, 0, a) : (s(t),
            e.setAttribute('style', '')),
            i.strokeWidth && e.setAttribute('stroke-width', i.strokeWidth),
            i.dashstyle && i.strokeWidth && !i['stroke-dasharray']) {
                var l = -1 === i.dashstyle.indexOf(',') ? ' ' : ','
                  , c = i.dashstyle.split(l)
                  , h = '';
                c.forEach((function(t) {
                    h += Math.floor(t * i.strokeWidth) + l
                }
                )),
                e.setAttribute('stroke-dasharray', h)
            } else
                i['stroke-dasharray'] && e.setAttribute('stroke-dasharray', i['stroke-dasharray']);
            for (var u in n)
                i[u] && e.setAttribute(n[u], i[u])
        }
          , c = function(t, e, n) {
            t.childNodes.length > n ? t.insertBefore(e, t.childNodes[n]) : t.appendChild(e)
        };
        e.svg = {
            node: o,
            attr: r,
            pos: a
        };
        var h = function(n) {
            var i = n.pointerEventsSpec || 'all'
              , s = {};
            t.jsPlumbUIComponent.apply(this, n.originalArgs),
            this.canvas = null,
            this.path = null,
            this.svg = null,
            this.bgCanvas = null;
            var l = n.cssClass + ' ' + (n.originalArgs[0].cssClass || '')
              , c = {
                style: '',
                width: 0,
                height: 0,
                'pointer-events': i,
                position: 'absolute'
            };
            this.svg = o('svg', c),
            n.useDivWrapper ? (this.canvas = t.createElement('div', {
                position: 'absolute'
            }),
            e.sizeElement(this.canvas, 0, 0, 1, 1),
            this.canvas.className = l) : (r(this.svg, {
                class: l
            }),
            this.canvas = this.svg),
            n._jsPlumb.appendElement(this.canvas, n.originalArgs[0].parent),
            n.useDivWrapper && this.canvas.appendChild(this.svg);
            var h = [this.canvas];
            return this.getDisplayElements = function() {
                return h
            }
            ,
            this.appendDisplayElement = function(t) {
                h.push(t)
            }
            ,
            this.paint = function(t, i, o) {
                if (null != t) {
                    var l, c = [this.x, this.y], h = [this.w, this.h];
                    null != o && (o.xmin < 0 && (c[0] += o.xmin),
                    o.ymin < 0 && (c[1] += o.ymin),
                    h[0] = o.xmax + (o.xmin < 0 ? -o.xmin : 0),
                    h[1] = o.ymax + (o.ymin < 0 ? -o.ymin : 0)),
                    n.useDivWrapper ? (e.sizeElement(this.canvas, c[0], c[1], h[0], h[1]),
                    c[0] = 0,
                    c[1] = 0,
                    l = a([0, 0])) : l = a([c[0], c[1]]),
                    s.paint.apply(this, arguments),
                    r(this.svg, {
                        style: l,
                        width: h[0] || 0,
                        height: h[1] || 0
                    })
                }
            }
            ,
            {
                renderer: s
            }
        };
        e.extend(h, t.jsPlumbUIComponent, {
            cleanup: function(t) {
                t || null == this.typeId ? (this.canvas && (this.canvas._jsPlumb = null),
                this.svg && (this.svg._jsPlumb = null),
                this.bgCanvas && (this.bgCanvas._jsPlumb = null),
                this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
                this.bgCanvas && this.bgCanvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
                this.svg = null,
                this.canvas = null,
                this.path = null,
                this.group = null) : (this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
                this.bgCanvas && this.bgCanvas.parentNode && this.bgCanvas.parentNode.removeChild(this.bgCanvas))
            },
            reattach: function(t) {
                var e = t.getContainer();
                this.canvas && null == this.canvas.parentNode && e.appendChild(this.canvas),
                this.bgCanvas && null == this.bgCanvas.parentNode && e.appendChild(this.bgCanvas)
            },
            setVisible: function(t) {
                this.canvas && (this.canvas.style.display = t ? 'block' : 'none')
            }
        }),
        t.ConnectorRenderers.svg = function(e) {
            var n = this
              , i = h.apply(this, [{
                cssClass: e._jsPlumb.connectorClass,
                originalArgs: arguments,
                pointerEventsSpec: 'none',
                _jsPlumb: e._jsPlumb
            }]);
            i.renderer.paint = function(i, a, s) {
                var h = n.getSegments()
                  , u = [0, 0];
                if (s.xmin < 0 && (u[0] = -s.xmin),
                s.ymin < 0 && (u[1] = -s.ymin),
                h.length > 0) {
                    var p = {
                        d: n.getPathData(),
                        transform: 'translate(' + u[0] + ',' + u[1] + ')',
                        'pointer-events': e['pointer-events'] || 'visibleStroke'
                    }
                      , d = null;
                    n.x,
                    n.y,
                    n.w,
                    n.h;
                    if (i.outlineStroke) {
                        var f = i.outlineWidth || 1
                          , m = i.strokeWidth + 2 * f;
                        delete (d = t.extend({}, i)).gradient,
                        d.stroke = i.outlineStroke,
                        d.strokeWidth = m,
                        null == n.bgPath ? (n.bgPath = o('path', p),
                        t.addClass(n.bgPath, t.connectorOutlineClass),
                        c(n.svg, n.bgPath, 0)) : r(n.bgPath, p),
                        l(n.svg, n.bgPath, d, 0, n)
                    }
                    null == n.path ? (n.path = o('path', p),
                    c(n.svg, n.path, i.outlineStroke ? 1 : 0)) : r(n.path, p),
                    l(n.svg, n.path, i, 0, n)
                }
            }
        }
        ,
        e.extend(t.ConnectorRenderers.svg, h);
        var u = t.SvgEndpoint = function(e) {
            var n = h.apply(this, [{
                cssClass: e._jsPlumb.endpointClass,
                originalArgs: arguments,
                pointerEventsSpec: 'all',
                useDivWrapper: !0,
                _jsPlumb: e._jsPlumb
            }]);
            n.renderer.paint = function(e) {
                var n = t.extend({}, e);
                n.outlineStroke && (n.stroke = n.outlineStroke),
                null == this.node ? (this.node = this.makeNode(n),
                this.svg.appendChild(this.node)) : null != this.updateNode && this.updateNode(this.node),
                l(this.svg, this.node, n, (this.x,
                this.y,
                this.w,
                this.h), this),
                a(this.node, (this.x,
                this.y))
            }
            .bind(this)
        }
        ;
        e.extend(u, h),
        t.Endpoints.svg.Dot = function() {
            t.Endpoints.Dot.apply(this, arguments),
            u.apply(this, arguments),
            this.makeNode = function(t) {
                return o('circle', {
                    cx: this.w / 2,
                    cy: this.h / 2,
                    r: this.radius
                })
            }
            ,
            this.updateNode = function(t) {
                r(t, {
                    cx: this.w / 2,
                    cy: this.h / 2,
                    r: this.radius
                })
            }
        }
        ,
        e.extend(t.Endpoints.svg.Dot, [t.Endpoints.Dot, u]),
        t.Endpoints.svg.Rectangle = function() {
            t.Endpoints.Rectangle.apply(this, arguments),
            u.apply(this, arguments),
            this.makeNode = function(t) {
                return o('rect', {
                    width: this.w,
                    height: this.h
                })
            }
            ,
            this.updateNode = function(t) {
                r(t, {
                    width: this.w,
                    height: this.h
                })
            }
        }
        ,
        e.extend(t.Endpoints.svg.Rectangle, [t.Endpoints.Rectangle, u]),
        t.Endpoints.svg.Image = t.Endpoints.Image,
        t.Endpoints.svg.Blank = t.Endpoints.Blank,
        t.Overlays.svg.Label = t.Overlays.Label,
        t.Overlays.svg.Custom = t.Overlays.Custom;
        var p = function(e, n) {
            e.apply(this, n),
            t.jsPlumbUIComponent.apply(this, n),
            this.isAppendedAtTopLevel = !1;
            this.path = null,
            this.paint = function(t, e) {
                if (t.component.svg && e) {
                    null == this.path && (this.path = o('path', {
                        'pointer-events': 'all'
                    }),
                    t.component.svg.appendChild(this.path),
                    this.elementCreated && this.elementCreated(this.path, t.component),
                    this.canvas = t.component.svg);
                    var a = n && 1 === n.length && n[0].cssClass || ''
                      , s = [0, 0];
                    e.xmin < 0 && (s[0] = -e.xmin),
                    e.ymin < 0 && (s[1] = -e.ymin),
                    r(this.path, {
                        d: i(t.d),
                        class: a,
                        stroke: t.stroke ? t.stroke : null,
                        fill: t.fill ? t.fill : null,
                        transform: 'translate(' + s[0] + ',' + s[1] + ')'
                    })
                }
            }
            ;
            var i = function(t) {
                return isNaN(t.cxy.x) || isNaN(t.cxy.y) ? '' : 'M' + t.hxy.x + ',' + t.hxy.y + ' L' + t.tail[0].x + ',' + t.tail[0].y + ' L' + t.cxy.x + ',' + t.cxy.y + ' L' + t.tail[1].x + ',' + t.tail[1].y + ' L' + t.hxy.x + ',' + t.hxy.y
            };
            this.transfer = function(t) {
                t.canvas && this.path && this.path.parentNode && (this.path.parentNode.removeChild(this.path),
                t.canvas.appendChild(this.path))
            }
        };
        e.extend(p, [t.jsPlumbUIComponent, t.Overlays.AbstractOverlay], {
            cleanup: function(t) {
                null != this.path && (t ? this._jsPlumb.instance.removeElement(this.path) : this.path.parentNode && this.path.parentNode.removeChild(this.path))
            },
            reattach: function(t, e) {
                this.path && e.canvas && e.canvas.appendChild(this.path)
            },
            setVisible: function(t) {
                null != this.path && (this.path.style.display = t ? 'block' : 'none')
            }
        }),
        t.Overlays.svg.Arrow = function() {
            p.apply(this, [t.Overlays.Arrow, arguments])
        }
        ,
        e.extend(t.Overlays.svg.Arrow, [t.Overlays.Arrow, p]),
        t.Overlays.svg.PlainArrow = function() {
            p.apply(this, [t.Overlays.PlainArrow, arguments])
        }
        ,
        e.extend(t.Overlays.svg.PlainArrow, [t.Overlays.PlainArrow, p]),
        t.Overlays.svg.Diamond = function() {
            p.apply(this, [t.Overlays.Diamond, arguments])
        }
        ,
        e.extend(t.Overlays.svg.Diamond, [t.Overlays.Diamond, p]),
        t.Overlays.svg.GuideLines = function() {
            var e, n, i = null, a = this;
            t.Overlays.GuideLines.apply(this, arguments),
            this.paint = function(t, l) {
                null == i && (i = o('path'),
                t.connector.svg.appendChild(i),
                a.attachListeners(i, t.connector),
                a.attachListeners(i, a),
                e = o('path'),
                t.connector.svg.appendChild(e),
                a.attachListeners(e, t.connector),
                a.attachListeners(e, a),
                n = o('path'),
                t.connector.svg.appendChild(n),
                a.attachListeners(n, t.connector),
                a.attachListeners(n, a));
                var c = [0, 0];
                l.xmin < 0 && (c[0] = -l.xmin),
                l.ymin < 0 && (c[1] = -l.ymin),
                r(i, {
                    d: s(t.head, t.tail),
                    stroke: 'red',
                    fill: null,
                    transform: 'translate(' + c[0] + ',' + c[1] + ')'
                }),
                r(e, {
                    d: s(t.tailLine[0], t.tailLine[1]),
                    stroke: 'blue',
                    fill: null,
                    transform: 'translate(' + c[0] + ',' + c[1] + ')'
                }),
                r(n, {
                    d: s(t.headLine[0], t.headLine[1]),
                    stroke: 'green',
                    fill: null,
                    transform: 'translate(' + c[0] + ',' + c[1] + ')'
                })
            }
            ;
            var s = function(t, e) {
                return 'M ' + t.x + ',' + t.y + ' L' + e.x + ',' + e.y
            }
        }
        ,
        e.extend(t.Overlays.svg.GuideLines, t.Overlays.GuideLines)
    }
    .call('undefined' != typeof window ? window : this),
    function() {
        'use strict';
        var t = this
          , e = t.jsPlumb
          , n = t.jsPlumbUtil
          , i = t.Katavorio
          , r = t.Biltong
          , o = function(t, n) {
            var o = '_katavorio_' + (n = n || 'main')
              , a = t[o]
              , s = t.getEventManager();
            return a || ((a = new i({
                bind: s.on,
                unbind: s.off,
                getSize: e.getSize,
                getConstrainingRectangle: function(t) {
                    return [t.parentNode.scrollWidth, t.parentNode.scrollHeight]
                },
                getPosition: function(e, n) {
                    var i = t.getOffset(e, n, e._katavorioDrag ? e.offsetParent : null);
                    return [i.left, i.top]
                },
                setPosition: function(t, e) {
                    t.style.left = e[0] + 'px',
                    t.style.top = e[1] + 'px'
                },
                addClass: e.addClass,
                removeClass: e.removeClass,
                intersects: r.intersects,
                indexOf: function(t, e) {
                    return t.indexOf(e)
                },
                scope: t.getDefaultScope(),
                css: {
                    noSelect: t.dragSelectClass,
                    droppable: 'jtk-droppable',
                    draggable: 'jtk-draggable',
                    drag: 'jtk-drag',
                    selected: 'jtk-drag-selected',
                    active: 'jtk-drag-active',
                    hover: 'jtk-drag-hover',
                    ghostProxy: 'jtk-ghost-proxy'
                }
            })).setZoom(t.getZoom()),
            t[o] = a,
            t.bind('zoom', a.setZoom)),
            a
        }
          , a = function(t) {
            var e = t.el._jsPlumbDragOptions
              , n = !0;
            return e.canDrag && (n = e.canDrag()),
            n && (this.setHoverSuspended(!0),
            this.select({
                source: t.el
            }).addClass(this.elementDraggingClass + ' ' + this.sourceElementDraggingClass, !0),
            this.select({
                target: t.el
            }).addClass(this.elementDraggingClass + ' ' + this.targetElementDraggingClass, !0),
            this.setConnectionBeingDragged(!0)),
            n
        }
          , s = function(t) {
            var e = this.getUIPosition(arguments, this.getZoom());
            if (null != e) {
                var n = t.el._jsPlumbDragOptions;
                this.draw(t.el, e, null, !0),
                n._dragging && this.addClass(t.el, 'jtk-dragged'),
                n._dragging = !0
            }
        }
          , l = function(t) {
            for (var e, n = t.selection, i = function(t) {
                null != t[1] && (e = this.getUIPosition([{
                    el: t[2].el,
                    pos: [t[1].left, t[1].top]
                }]),
                this.draw(t[2].el, e)),
                null != t[0]._jsPlumbDragOptions && delete t[0]._jsPlumbDragOptions._dragging,
                this.removeClass(t[0], 'jtk-dragged'),
                this.select({
                    source: t[2].el
                }).removeClass(this.elementDraggingClass + ' ' + this.sourceElementDraggingClass, !0),
                this.select({
                    target: t[2].el
                }).removeClass(this.elementDraggingClass + ' ' + this.targetElementDraggingClass, !0),
                this.getDragManager().dragEnded(t[2].el)
            }
            .bind(this), r = 0; r < n.length; r++)
                i(n[r]);
            this.setHoverSuspended(!1),
            this.setConnectionBeingDragged(!1)
        }
          , c = function(t, e) {
            if (null == e)
                return [0, 0];
            var n = f(e)
              , i = d(n, 0);
            return [i[t + 'X'], i[t + 'Y']]
        }
          , h = c.bind(this, 'page')
          , u = c.bind(this, 'screen')
          , p = c.bind(this, 'client')
          , d = function(t, e) {
            return t.item ? t.item(e) : t[e]
        }
          , f = function(t) {
            return t.touches && t.touches.length > 0 ? t.touches : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches : t.targetTouches && t.targetTouches.length > 0 ? t.targetTouches : [t]
        }
          , m = function(t) {
            var e = {}
              , n = []
              , i = {}
              , r = {}
              , o = {};
            this.register = function(a) {
                var s, l = t.getId(a);
                e[l] || (e[l] = a,
                n.push(a),
                i[l] = {});
                var c = function(e) {
                    if (e)
                        for (var n = 0; n < e.childNodes.length; n++)
                            if (3 !== e.childNodes[n].nodeType && 8 !== e.childNodes[n].nodeType) {
                                var h = jsPlumb.getElement(e.childNodes[n])
                                  , u = t.getId(e.childNodes[n], null, !0);
                                if (u && r[u] && r[u] > 0) {
                                    s || (s = t.getOffset(a));
                                    var p = t.getOffset(h);
                                    i[l][u] = {
                                        id: u,
                                        offset: {
                                            left: p.left - s.left,
                                            top: p.top - s.top
                                        }
                                    },
                                    o[u] = l
                                }
                                c(e.childNodes[n])
                            }
                };
                c(a)
            }
            ,
            this.updateOffsets = function(e, n) {
                if (null != e) {
                    n = n || {};
                    var r, a = jsPlumb.getElement(e), s = t.getId(a), l = i[s];
                    if (l)
                        for (var c in l)
                            if (l.hasOwnProperty(c)) {
                                var h = jsPlumb.getElement(c)
                                  , u = n[c] || t.getOffset(h);
                                if (null == h.offsetParent && null != i[s][c])
                                    continue;
                                r || (r = t.getOffset(a)),
                                i[s][c] = {
                                    id: c,
                                    offset: {
                                        left: u.left - r.left,
                                        top: u.top - r.top
                                    }
                                },
                                o[c] = s
                            }
                }
            }
            ,
            this.endpointAdded = function(n, a) {
                a = a || t.getId(n);
                var s = document.body
                  , l = n.parentNode;
                for (r[a] = r[a] ? r[a] + 1 : 1; null != l && l !== s; ) {
                    var c = t.getId(l, null, !0);
                    if (c && e[c]) {
                        var h = t.getOffset(l);
                        if (null == i[c][a]) {
                            var u = t.getOffset(n);
                            i[c][a] = {
                                id: a,
                                offset: {
                                    left: u.left - h.left,
                                    top: u.top - h.top
                                }
                            },
                            o[a] = c
                        }
                        break
                    }
                    l = l.parentNode
                }
            }
            ,
            this.endpointDeleted = function(t) {
                if (r[t.elementId] && (r[t.elementId]--,
                r[t.elementId] <= 0))
                    for (var e in i)
                        i.hasOwnProperty(e) && i[e] && (delete i[e][t.elementId],
                        delete o[t.elementId])
            }
            ,
            this.changeId = function(t, e) {
                i[e] = i[t],
                i[t] = {},
                o[e] = o[t],
                o[t] = null
            }
            ,
            this.getElementsForDraggable = function(t) {
                return i[t]
            }
            ,
            this.elementRemoved = function(t) {
                var e = o[t];
                e && (delete i[e][t],
                delete o[t])
            }
            ,
            this.reset = function() {
                e = {},
                n = [],
                i = {},
                r = {}
            }
            ,
            this.dragEnded = function(e) {
                if (null != e.offsetParent) {
                    var n = t.getId(e)
                      , i = o[n];
                    i && this.updateOffsets(i)
                }
            }
            ,
            this.setParent = function(e, n, r, a, s) {
                var l = o[n];
                i[a] || (i[a] = {});
                var c = t.getOffset(r)
                  , h = s || t.getOffset(e);
                l && i[l] && delete i[l][n],
                i[a][n] = {
                    id: n,
                    offset: {
                        left: h.left - c.left,
                        top: h.top - c.top
                    }
                },
                o[n] = a
            }
            ,
            this.clearParent = function(t, e) {
                var n = o[e];
                n && (delete i[n][e],
                delete o[e])
            }
            ,
            this.revalidateParent = function(e, n, i) {
                var r = o[n];
                if (r) {
                    var a = {};
                    a[n] = i,
                    this.updateOffsets(r, a),
                    t.revalidate(r)
                }
            }
            ,
            this.getDragAncestor = function(e) {
                var n = jsPlumb.getElement(e)
                  , i = t.getId(n)
                  , r = o[i];
                return r ? jsPlumb.getElement(r) : null
            }
        }
          , g = function(t, e, i) {
            e = n.fastTrim(e),
            void 0 !== t.className.baseVal ? t.className.baseVal = e : t.className = e;
            try {
                var r = t.classList;
                if (null != r) {
                    for (; r.length > 0; )
                        r.remove(r.item(0));
                    for (var o = 0; o < i.length; o++)
                        i[o] && r.add(i[o])
                }
            } catch (t) {
                n.log('JSPLUMB: cannot set class list', t)
            }
        }
          , v = function(t) {
            return void 0 === t.className.baseVal ? t.className : t.className.baseVal
        }
          , y = function(t, e, i) {
            e = null == e ? [] : n.isArray(e) ? e : e.split(/\s+/),
            i = null == i ? [] : n.isArray(i) ? i : i.split(/\s+/);
            var r = v(t).split(/\s+/)
              , o = function(t, e) {
                for (var n = 0; n < e.length; n++)
                    if (t)
                        -1 === r.indexOf(e[n]) && r.push(e[n]);
                    else {
                        var i = r.indexOf(e[n]);
                        -1 !== i && r.splice(i, 1)
                    }
            };
            o(!0, e),
            o(!1, i),
            g(t, r.join(' '), r)
        };
        t.jsPlumb.extend(t.jsPlumbInstance.prototype, {
            headless: !1,
            pageLocation: h,
            screenLocation: u,
            clientLocation: p,
            getDragManager: function() {
                return null == this.dragManager && (this.dragManager = new m(this)),
                this.dragManager
            },
            recalculateOffsets: function(t) {
                this.getDragManager().updateOffsets(t)
            },
            createElement: function(t, e, n, i) {
                return this.createElementNS(null, t, e, n, i)
            },
            createElementNS: function(t, e, n, i, r) {
                var o, a = null == t ? document.createElement(e) : document.createElementNS(t, e);
                for (o in n = n || {})
                    a.style[o] = n[o];
                for (o in i && (a.className = i),
                r = r || {})
                    a.setAttribute(o, '' + r[o]);
                return a
            },
            getAttribute: function(t, e) {
                return null != t.getAttribute ? t.getAttribute(e) : null
            },
            setAttribute: function(t, e, n) {
                null != t.setAttribute && t.setAttribute(e, n)
            },
            setAttributes: function(t, e) {
                for (var n in e)
                    e.hasOwnProperty(n) && t.setAttribute(n, e[n])
            },
            appendToRoot: function(t) {
                document.body.appendChild(t)
            },
            getRenderModes: function() {
                return ['svg']
            },
            getClass: v,
            addClass: function(t, e) {
                jsPlumb.each(t, (function(t) {
                    y(t, e)
                }
                ))
            },
            hasClass: function(t, e) {
                return (t = jsPlumb.getElement(t)).classList ? t.classList.contains(e) : -1 !== v(t).indexOf(e)
            },
            removeClass: function(t, e) {
                jsPlumb.each(t, (function(t) {
                    y(t, null, e)
                }
                ))
            },
            toggleClass: function(t, e) {
                jsPlumb.hasClass(t, e) ? jsPlumb.removeClass(t, e) : jsPlumb.addClass(t, e)
            },
            updateClasses: function(t, e, n) {
                jsPlumb.each(t, (function(t) {
                    y(t, e, n)
                }
                ))
            },
            setClass: function(t, e) {
                null != e && jsPlumb.each(t, (function(t) {
                    g(t, e, e.split(/\s+/))
                }
                ))
            },
            setPosition: function(t, e) {
                t.style.left = e.left + 'px',
                t.style.top = e.top + 'px'
            },
            getPosition: function(t) {
                var e = function(e) {
                    var n = t.style[e];
                    return n ? n.substring(0, n.length - 2) : 0
                };
                return {
                    left: e('left'),
                    top: e('top')
                }
            },
            getStyle: function(t, e) {
                return void 0 !== window.getComputedStyle ? getComputedStyle(t, null).getPropertyValue(e) : t.currentStyle[e]
            },
            getSelector: function(t, e) {
                return 1 === arguments.length ? null != t.nodeType ? t : document.querySelectorAll(t) : t.querySelectorAll(e)
            },
            getOffset: function(t, e, n) {
                t = jsPlumb.getElement(t),
                n = n || this.getContainer();
                for (var i = {
                    left: t.offsetLeft,
                    top: t.offsetTop
                }, r = e || null != n && t !== n && t.offsetParent !== n ? t.offsetParent : null, o = function(t) {
                    null != t && t !== document.body && (t.scrollTop > 0 || t.scrollLeft > 0) && (i.left -= t.scrollLeft,
                    i.top -= t.scrollTop)
                }
                .bind(this); null != r; )
                    i.left += r.offsetLeft,
                    i.top += r.offsetTop,
                    o(r),
                    r = e ? r.offsetParent : r.offsetParent === n ? null : r.offsetParent;
                if (null != n && !e && (n.scrollTop > 0 || n.scrollLeft > 0)) {
                    var a = null != t.offsetParent ? this.getStyle(t.offsetParent, 'position') : 'static'
                      , s = this.getStyle(t, 'position');
                    'absolute' !== s && 'fixed' !== s && 'absolute' !== a && 'fixed' !== a && (i.left -= n.scrollLeft,
                    i.top -= n.scrollTop)
                }
                return i
            },
            getPositionOnElement: function(t, e, n) {
                var i = void 0 !== e.getBoundingClientRect ? e.getBoundingClientRect() : {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                }
                  , r = document.body
                  , o = document.documentElement
                  , a = window.pageYOffset || o.scrollTop || r.scrollTop
                  , s = window.pageXOffset || o.scrollLeft || r.scrollLeft
                  , l = o.clientTop || r.clientTop || 0
                  , c = o.clientLeft || r.clientLeft || 0
                  , h = i.top + a - l + 0 * n
                  , u = i.left + s - c + 0 * n
                  , p = jsPlumb.pageLocation(t)
                  , d = i.width || e.offsetWidth * n
                  , f = i.height || e.offsetHeight * n;
                return [(p[0] - u) / d, (p[1] - h) / f]
            },
            getAbsolutePosition: function(t) {
                var e = function(e) {
                    var n = t.style[e];
                    if (n)
                        return parseFloat(n.substring(0, n.length - 2))
                };
                return [e('left'), e('top')]
            },
            setAbsolutePosition: function(t, e, n, i) {
                n ? this.animate(t, {
                    left: '+=' + (e[0] - n[0]),
                    top: '+=' + (e[1] - n[1])
                }, i) : (t.style.left = e[0] + 'px',
                t.style.top = e[1] + 'px')
            },
            getSize: function(t) {
                return [t.offsetWidth, t.offsetHeight]
            },
            getWidth: function(t) {
                return t.offsetWidth
            },
            getHeight: function(t) {
                return t.offsetHeight
            },
            getRenderMode: function() {
                return 'svg'
            },
            draggable: function(t, e) {
                var i;
                return t = n.isArray(t) || null != t.length && !n.isString(t) ? t : [t],
                Array.prototype.slice.call(t).forEach(function(t) {
                    (i = this.info(t)).el && this._initDraggableIfNecessary(i.el, !0, e, i.id, !0)
                }
                .bind(this)),
                this
            },
            snapToGrid: function(t, e, n) {
                var i = []
                  , r = function(t) {
                    var r = this.info(t);
                    if (null != r.el && r.el._katavorioDrag) {
                        var o = r.el._katavorioDrag.snap(e, n);
                        this.revalidate(r.el),
                        i.push([r.el, o])
                    }
                }
                .bind(this);
                if (1 === arguments.length || 3 === arguments.length)
                    r(t, e, n);
                else {
                    var o = this.getManagedElements();
                    for (var a in o)
                        r(a, arguments[0], arguments[1])
                }
                return i
            },
            initDraggable: function(t, e, n) {
                o(this, n).draggable(t, e),
                t._jsPlumbDragOptions = e
            },
            destroyDraggable: function(t, e) {
                o(this, e).destroyDraggable(t),
                delete t._jsPlumbDragOptions
            },
            unbindDraggable: function(t, e, n, i) {
                o(this, i).destroyDraggable(t, e, n)
            },
            setDraggable: function(t, e) {
                return jsPlumb.each(t, function(t) {
                    this.isDragSupported(t) && (this._draggableStates[this.getAttribute(t, 'id')] = e,
                    this.setElementDraggable(t, e))
                }
                .bind(this))
            },
            _draggableStates: {},
            toggleDraggable: function(t) {
                var e;
                return jsPlumb.each(t, function(t) {
                    var n = this.getAttribute(t, 'id');
                    return e = !(e = null != this._draggableStates[n] && this._draggableStates[n]),
                    this._draggableStates[n] = e,
                    this.setDraggable(t, e),
                    e
                }
                .bind(this)),
                e
            },
            _initDraggableIfNecessary: function(t, e, i, r, o) {
                if (!jsPlumb.headless && (null != e && e && jsPlumb.isDragSupported(t, this))) {
                    var c = i || this.Defaults.DragOptions;
                    if (c = jsPlumb.extend({}, c),
                    jsPlumb.isAlreadyDraggable(t, this))
                        i.force && this.initDraggable(t, c);
                    else {
                        var h = jsPlumb.dragEvents.drag
                          , u = jsPlumb.dragEvents.stop
                          , p = jsPlumb.dragEvents.start;
                        this.manage(r, t),
                        c[p] = n.wrap(c[p], a.bind(this)),
                        c[h] = n.wrap(c[h], s.bind(this)),
                        c[u] = n.wrap(c[u], l.bind(this));
                        var d = this.getId(t);
                        this._draggableStates[d] = !0;
                        var f = this._draggableStates[d];
                        c.disabled = null != f && !f,
                        this.initDraggable(t, c),
                        this.getDragManager().register(t),
                        o && this.fire('elementDraggable', {
                            el: t,
                            options: c
                        })
                    }
                }
            },
            animationSupported: !0,
            getElement: function(t) {
                return null == t ? null : 'string' == typeof (t = 'string' == typeof t ? t : null != t.length && null == t.enctype ? t[0] : t) ? document.getElementById(t) : t
            },
            removeElement: function(t) {
                o(this).elementRemoved(t),
                this.getEventManager().remove(t)
            },
            doAnimate: function(t, i, r) {
                r = r || {};
                var o = this.getOffset(t)
                  , a = function(t, e) {
                    var i = function(i) {
                        if (null != e[i]) {
                            if (n.isString(e[i])) {
                                var r = e[i].match(/-=/) ? -1 : 1
                                  , o = e[i].substring(2);
                                return t[i] + r * o
                            }
                            return e[i]
                        }
                        return t[i]
                    };
                    return [i('left'), i('top')]
                }(o, i)
                  , s = a[0] - o.left
                  , l = a[1] - o.top
                  , c = r.duration || 250
                  , h = c / 15
                  , u = 15 / c * s
                  , p = 15 / c * l
                  , d = 0
                  , f = setInterval((function() {
                    e.setPosition(t, {
                        left: o.left + u * (d + 1),
                        top: o.top + p * (d + 1)
                    }),
                    null != r.step && r.step(d, Math.ceil(h)),
                    ++d >= h && (window.clearInterval(f),
                    null != r.complete && r.complete())
                }
                ), 15)
            },
            destroyDroppable: function(t, e) {
                o(this, e).destroyDroppable(t)
            },
            unbindDroppable: function(t, e, n, i) {
                o(this, i).destroyDroppable(t, e, n)
            },
            droppable: function(t, e) {
                var i;
                return t = n.isArray(t) || null != t.length && !n.isString(t) ? t : [t],
                (e = e || {}).allowLoopback = !1,
                Array.prototype.slice.call(t).forEach(function(t) {
                    (i = this.info(t)).el && this.initDroppable(i.el, e)
                }
                .bind(this)),
                this
            },
            initDroppable: function(t, e, n) {
                o(this, n).droppable(t, e)
            },
            isAlreadyDraggable: function(t) {
                return null != t._katavorioDrag
            },
            isDragSupported: function(t, e) {
                return !0
            },
            isDropSupported: function(t, e) {
                return !0
            },
            isElementDraggable: function(t) {
                return (t = e.getElement(t))._katavorioDrag && t._katavorioDrag.isEnabled()
            },
            getDragObject: function(t) {
                return t[0].drag.getDragElement()
            },
            getDragScope: function(t) {
                return t._katavorioDrag && t._katavorioDrag.scopes.join(' ') || ''
            },
            getDropEvent: function(t) {
                return t[0].e
            },
            getUIPosition: function(t, e) {
                var n = t[0].el;
                if (null == n.offsetParent)
                    return null;
                var i = t[0].finalPos || t[0].pos
                  , r = {
                    left: i[0],
                    top: i[1]
                };
                if (n._katavorioDrag && n.offsetParent !== this.getContainer()) {
                    var o = this.getOffset(n.offsetParent);
                    r.left += o.left,
                    r.top += o.top
                }
                return r
            },
            setDragFilter: function(t, e, n) {
                t._katavorioDrag && t._katavorioDrag.setFilter(e, n)
            },
            setElementDraggable: function(t, n) {
                (t = e.getElement(t))._katavorioDrag && t._katavorioDrag.setEnabled(n)
            },
            setDragScope: function(t, e) {
                t._katavorioDrag && t._katavorioDrag.k.setDragScope(t, e)
            },
            setDropScope: function(t, e) {
                t._katavorioDrop && t._katavorioDrop.length > 0 && t._katavorioDrop[0].k.setDropScope(t, e)
            },
            addToPosse: function(t, n) {
                var i = Array.prototype.slice.call(arguments, 1)
                  , r = o(this);
                e.each(t, (function(t) {
                    (t = [e.getElement(t)]).push.apply(t, i),
                    r.addToPosse.apply(r, t)
                }
                ))
            },
            setPosse: function(t, n) {
                var i = Array.prototype.slice.call(arguments, 1)
                  , r = o(this);
                e.each(t, (function(t) {
                    (t = [e.getElement(t)]).push.apply(t, i),
                    r.setPosse.apply(r, t)
                }
                ))
            },
            removeFromPosse: function(t, n) {
                var i = Array.prototype.slice.call(arguments, 1)
                  , r = o(this);
                e.each(t, (function(t) {
                    (t = [e.getElement(t)]).push.apply(t, i),
                    r.removeFromPosse.apply(r, t)
                }
                ))
            },
            removeFromAllPosses: function(t) {
                var n = o(this);
                e.each(t, (function(t) {
                    n.removeFromAllPosses(e.getElement(t))
                }
                ))
            },
            setPosseState: function(t, n, i) {
                var r = o(this);
                e.each(t, (function(t) {
                    r.setPosseState(e.getElement(t), n, i)
                }
                ))
            },
            dragEvents: {
                start: 'start',
                stop: 'stop',
                drag: 'drag',
                step: 'step',
                over: 'over',
                out: 'out',
                drop: 'drop',
                complete: 'complete',
                beforeStart: 'beforeStart'
            },
            animEvents: {
                step: 'step',
                complete: 'complete'
            },
            stopDrag: function(t) {
                t._katavorioDrag && t._katavorioDrag.abort()
            },
            addToDragSelection: function(t) {
                var e = this.getElement(t);
                null == e || !e._isJsPlumbGroup && null != e._jsPlumbGroup || o(this).select(t)
            },
            removeFromDragSelection: function(t) {
                o(this).deselect(t)
            },
            getDragSelection: function() {
                return o(this).getSelection()
            },
            clearDragSelection: function() {
                o(this).deselectAll()
            },
            trigger: function(t, e, n, i) {
                this.getEventManager().trigger(t, e, n, i)
            },
            doReset: function() {
                for (var t in this)
                    0 === t.indexOf('_katavorio_') && this[t].reset()
            },
            getEventManager: function() {
                return (n = (e = this)._mottle) || (n = e._mottle = new t.Mottle),
                n;
                var e, n
            },
            on: function(t, e, n) {
                return this.getEventManager().on.apply(this, arguments),
                this
            },
            off: function(t, e, n) {
                return this.getEventManager().off.apply(this, arguments),
                this
            }
        });
        var x, b;
        x = e.init,
        (b = function() {
            /complete|loaded|interactive/.test(document.readyState) && void 0 !== document.body && null != document.body ? x() : setTimeout(b, 9)
        }
        )()
    }
    .call('undefined' != typeof window ? window : this)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = 'active'
      , o = document.getElementById('button-trigger-CH1')
      , a = document.getElementById('button-trigger-CH2')
      , s = document.getElementById('button-trigger-EXT')
      , l = document.getElementById('button-trigger-AC')
      , c = document.getElementById('button-trigger-DC')
      , h = document.getElementById('button-trigger-LF');
    function u(t) {
        t !== i.globalState.triggerSettings.channel ? d(t) : d(i.TriggerChannel.NONE)
    }
    function p(t) {
        if (l.classList.remove(r),
        c.classList.remove(r),
        h.classList.remove(r),
        i.globalState.triggerSettings.channel !== i.TriggerChannel.NONE)
            switch (t) {
            case i.TriggerMode.AC:
                l.classList.add(r),
                i.globalState.triggerSettings.mode = i.TriggerMode.AC;
                break;
            case i.TriggerMode.DC:
                c.classList.add(r),
                i.globalState.triggerSettings.mode = i.TriggerMode.DC;
                break;
            case i.TriggerMode.LF:
                h.classList.add(r),
                i.globalState.triggerSettings.mode = i.TriggerMode.LF
            }
    }
    function d(t) {
        switch (o.classList.remove(r),
        a.classList.remove(r),
        s.classList.remove(r),
        t) {
        case i.TriggerChannel.CH1:
            o.classList.add(r),
            i.globalState.triggerSettings.channel = i.TriggerChannel.CH1;
            break;
        case i.TriggerChannel.CH2:
            a.classList.add(r),
            i.globalState.triggerSettings.channel = i.TriggerChannel.CH2;
            break;
        case i.TriggerChannel.EXT:
            s.classList.add(r),
            i.globalState.triggerSettings.channel = i.TriggerChannel.EXT;
            break;
        case i.TriggerChannel.NONE:
            i.globalState.triggerSettings.channel = i.TriggerChannel.NONE
        }
        p(i.globalState.triggerSettings.mode)
    }
    o.onclick = ()=>u(i.TriggerChannel.CH1),
    a.onclick = ()=>u(i.TriggerChannel.CH2),
    s.onclick = ()=>u(i.TriggerChannel.EXT),
    l.onclick = ()=>p(i.TriggerMode.AC),
    c.onclick = ()=>p(i.TriggerMode.DC),
    h.onclick = ()=>p(i.TriggerMode.LF),
    d(i.globalState.triggerSettings.channel)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(5)
      , r = n(2)
      , o = n(0);
    new i.RotaryKnob(document.getElementById('knob-CH1'),'rotary-button-CH1',r.RotaryButtonType.VOLTAGE,t=>o.globalState.rotaryPane.voltsCH1 = t,o.globalState.rotaryPane.voltsCH1),
    new i.RotaryKnob(document.getElementById('knob-CH2'),'rotary-button-CH2',r.RotaryButtonType.VOLTAGE,t=>o.globalState.rotaryPane.voltsCH2 = t,o.globalState.rotaryPane.voltsCH2),
    new i.RotaryKnob(document.getElementById('knob-TIME'),'rotary-button-TIME',r.RotaryButtonType.TIME,t=>o.globalState.rotaryPane.time = t,o.globalState.rotaryPane.time),
    new i.RotaryKnob(document.getElementById('knob-POS1'),'rotary-button-POS1',r.RotaryButtonType.STANDARD,t=>o.globalState.rotaryPane.position1 = t,o.globalState.rotaryPane.position1),
    new i.RotaryKnob(document.getElementById('knob-POS2'),'rotary-button-POS2',r.RotaryButtonType.STANDARD,t=>o.globalState.rotaryPane.position2 = t,o.globalState.rotaryPane.position2),
    new i.RotaryKnob(document.getElementById('knob-TL'),'rotary-button-TL',r.RotaryButtonType.STANDARD,t=>o.globalState.triggerSettings.triggerLevel = t,o.globalState.triggerSettings.triggerLevel),
    new i.RotaryKnob(document.getElementById('knob-XPOS'),'rotary-button-XPOS',r.RotaryButtonType.STANDARD,t=>o.globalState.rotaryPane.xPosition = t,o.globalState.rotaryPane.xPosition)
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = document.getElementById('button-plus')
      , o = document.getElementById('button-minus')
      , a = document.getElementById('button-select');
    r.onclick = function() {
        switch (i.globalState.adjustMode) {
        case i.AdjustMode.INTENSITY:
            i.globalState.adjustValue.intensity < 100 && (i.globalState.adjustValue.intensity += 1);
            break;
        case i.AdjustMode.FOCUS:
            i.globalState.adjustValue.focus < 100 && (i.globalState.adjustValue.focus += 1);
            break;
        case i.AdjustMode.TRACE:
            i.globalState.adjustValue.trace < 100 && (i.globalState.adjustValue.trace += 1)
        }
    }
    ,
    o.onclick = function() {
        switch (i.globalState.adjustMode) {
        case i.AdjustMode.INTENSITY:
            i.globalState.adjustValue.intensity > 0 && (i.globalState.adjustValue.intensity -= 1);
            break;
        case i.AdjustMode.FOCUS:
            i.globalState.adjustValue.focus > 0 && (i.globalState.adjustValue.focus -= 1);
            break;
        case i.AdjustMode.TRACE:
            i.globalState.adjustValue.trace > 0 && (i.globalState.adjustValue.trace -= 1)
        }
    }
    ,
    a.onclick = function() {
        switch (i.globalState.adjustMode) {
        case i.AdjustMode.INTENSITY:
            i.globalState.adjustMode = i.AdjustMode.FOCUS,
            s.classList.remove('active'),
            l.classList.add('active');
            break;
        case i.AdjustMode.FOCUS:
            i.globalState.adjustMode = i.AdjustMode.TRACE,
            l.classList.remove('active'),
            c.classList.add('active');
            break;
        case i.AdjustMode.TRACE:
            i.globalState.adjustMode = i.AdjustMode.INTENSITY,
            c.classList.remove('active'),
            s.classList.add('active')
        }
    }
    ;
    const s = document.getElementById('indicator-intens')
      , l = document.getElementById('indicator-focus')
      , c = document.getElementById('indicator-trace');
    !function() {
        switch (i.globalState.adjustMode) {
        case i.AdjustMode.INTENSITY:
            s.classList.add('active');
            break;
        case i.AdjustMode.FOCUS:
            l.classList.add('active');
            break;
        case i.AdjustMode.TRACE:
            c.classList.add('active')
        }
    }()
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = document.getElementById('button-trigger-slope');
    r.onclick = ()=>{
        i.globalState.triggerSettings.slope ? (i.globalState.triggerSettings.slope = !1,
        r.classList.remove('active')) : (i.globalState.triggerSettings.slope = !0,
        r.classList.add('active'))
    }
    ,
    i.globalState.triggerSettings.slope && r.classList.add('active');
    const o = document.getElementById('button-trigger-norm');
    o.onclick = ()=>{
        i.globalState.triggerSettings.auto === i.AutoTriggerMode.NORM ? (i.globalState.triggerSettings.auto = i.AutoTriggerMode.AUTO,
        o.classList.remove('active')) : (i.globalState.triggerSettings.auto = i.AutoTriggerMode.NORM,
        o.classList.add('active'))
    }
    ,
    i.globalState.triggerSettings.auto === i.AutoTriggerMode.NORM && o.classList.add('active')
}
, function(t, e, n) {
    'use strict';
    Object.defineProperty(e, '__esModule', {
        value: !0
    });
    const i = n(0)
      , r = document.getElementById('button-trigger-xmag');
    r.onclick = ()=>{
        i.globalState.xMag ? (i.globalState.xMag = !1,
        r.classList.remove('active')) : (i.globalState.xMag = !0,
        r.classList.add('active'))
    }
    ,
    i.globalState.xMag && r.classList.add('active')
}
, function(t, e, n) {
    'use strict';
    n.r(e),
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return 'number' == typeof t && isFinite(t) && Math.floor(t) === t
    }
    ),
    void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }
    ),
    'name'in Function.prototype == !1 && Object.defineProperty(Function.prototype, 'name', {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(t) {
        if (null == t)
            throw new TypeError('Cannot convert undefined or null to object');
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var i = arguments[n];
            if (null != i)
                for (var r in i)
                    Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
        }
        return e
    }
    );
    var i = 0
      , r = 1
      , o = 2
      , a = 1
      , s = 2
      , l = 3
      , c = 0
      , h = 1
      , u = 2
      , p = 0
      , d = 1
      , f = 2
      , m = 0
      , g = 1
      , v = 2
      , y = 3
      , x = 4
      , b = 5
      , _ = 100
      , M = 101
      , w = 102
      , S = 103
      , P = 104
      , C = 200
      , A = 201
      , E = 202
      , T = 203
      , L = 204
      , D = 205
      , I = 206
      , O = 207
      , j = 208
      , N = 209
      , k = 210
      , F = 0
      , z = 1
      , R = 2
      , U = 3
      , B = 4
      , V = 5
      , G = 6
      , H = 7
      , W = 0
      , X = 1
      , q = 2
      , Y = 0
      , J = 1
      , Z = 2
      , K = 3
      , Q = 4
      , $ = 5
      , tt = 301
      , et = 302
      , nt = 303
      , it = 304
      , rt = 305
      , ot = 306
      , at = 307
      , st = 1e3
      , lt = 1001
      , ct = 1002
      , ht = 1003
      , ut = 1004
      , pt = 1005
      , dt = 1006
      , ft = 1007
      , mt = 1008
      , gt = 1009
      , vt = 1010
      , yt = 1011
      , xt = 1012
      , bt = 1013
      , _t = 1014
      , Mt = 1015
      , wt = 1016
      , St = 1017
      , Pt = 1018
      , Ct = 1019
      , At = 1020
      , Et = 1021
      , Tt = 1022
      , Lt = 1023
      , Dt = 1024
      , It = 1025
      , Ot = 1026
      , jt = 1027
      , Nt = 1028
      , kt = 33776
      , Ft = 33777
      , zt = 33778
      , Rt = 33779
      , Ut = 35840
      , Bt = 35841
      , Vt = 35842
      , Gt = 35843
      , Ht = 36196
      , Wt = 37808
      , Xt = 37809
      , qt = 37810
      , Yt = 37811
      , Jt = 37812
      , Zt = 37813
      , Kt = 37814
      , Qt = 37815
      , $t = 37816
      , te = 37817
      , ee = 37818
      , ne = 37819
      , ie = 37820
      , re = 37821
      , oe = 2201
      , ae = 2400
      , se = 0
      , le = 1
      , ce = 2
      , he = 3e3
      , ue = 3001
      , pe = 3007
      , de = 3002
      , fe = 3003
      , me = 3004
      , ge = 3005
      , ve = 3006
      , ye = 3200
      , xe = 3201
      , be = 0
      , _e = 1
      , Me = 7680
      , we = 519
      , Se = 35044;
    function Pe() {}
    Object.assign(Pe.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var i = n.indexOf(e);
                    -1 !== i && n.splice(i, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
                        n[i].call(this, t)
                }
            }
        }
    });
    for (var Ce = [], Ae = 0; Ae < 256; Ae++)
        Ce[Ae] = (Ae < 16 ? '0' : '') + Ae.toString(16);
    var Ee = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (Ce[255 & t] + Ce[t >> 8 & 255] + Ce[t >> 16 & 255] + Ce[t >> 24 & 255] + '-' + Ce[255 & e] + Ce[e >> 8 & 255] + '-' + Ce[e >> 16 & 15 | 64] + Ce[e >> 24 & 255] + '-' + Ce[63 & n | 128] + Ce[n >> 8 & 255] + '-' + Ce[n >> 16 & 255] + Ce[n >> 24 & 255] + Ce[255 & i] + Ce[i >> 8 & 255] + Ce[i >> 16 & 255] + Ce[i >> 24 & 255]).toUpperCase()
        },
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function(t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function(t) {
            return t * Ee.DEG2RAD
        },
        radToDeg: function(t) {
            return t * Ee.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    };
    function Te(t, e) {
        this.x = t || 0,
        this.y = e || 0
    }
    function Le(t, e, n, i) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._w = void 0 !== i ? i : 1
    }
    Object.defineProperties(Te.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }),
    Object.assign(Te.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t,
            this.y = e,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error('index is out of range: ' + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        },
        multiply: function(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y
              , i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6],
            this.y = i[1] * e + i[4] * n + i[7],
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this
        },
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI),
            t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e)
              , i = Math.sin(e)
              , r = this.x - t.x
              , o = this.y - t.y;
            return this.x = r * n - o * i + t.x,
            this.y = r * i + o * n + t.y,
            this
        }
    }),
    Object.assign(Le, {
        slerp: function(t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function(t, e, n, i, r, o, a) {
            var s = n[i + 0]
              , l = n[i + 1]
              , c = n[i + 2]
              , h = n[i + 3]
              , u = r[o + 0]
              , p = r[o + 1]
              , d = r[o + 2]
              , f = r[o + 3];
            if (h !== f || s !== u || l !== p || c !== d) {
                var m = 1 - a
                  , g = s * u + l * p + c * d + h * f
                  , v = g >= 0 ? 1 : -1
                  , y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var x = Math.sqrt(y)
                      , b = Math.atan2(x, g * v);
                    m = Math.sin(m * b) / x,
                    a = Math.sin(a * b) / x
                }
                var _ = a * v;
                if (s = s * m + u * _,
                l = l * m + p * _,
                c = c * m + d * _,
                h = h * m + f * _,
                m === 1 - a) {
                    var M = 1 / Math.sqrt(s * s + l * l + c * c + h * h);
                    s *= M,
                    l *= M,
                    c *= M,
                    h *= M
                }
            }
            t[e] = s,
            t[e + 1] = l,
            t[e + 2] = c,
            t[e + 3] = h
        }
    }),
    Object.defineProperties(Le.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this._onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign(Le.prototype, {
        isQuaternion: !0,
        set: function(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = i,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this._onChangeCallback(),
            this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler)
                throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            var n = t._x
              , i = t._y
              , r = t._z
              , o = t.order
              , a = Math.cos
              , s = Math.sin
              , l = a(n / 2)
              , c = a(i / 2)
              , h = a(r / 2)
              , u = s(n / 2)
              , p = s(i / 2)
              , d = s(r / 2);
            return 'XYZ' === o ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h - u * p * d) : 'YXZ' === o ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h + u * p * d) : 'ZXY' === o ? (this._x = u * c * h - l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h - u * p * d) : 'ZYX' === o ? (this._x = u * c * h - l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h + u * p * d) : 'YZX' === o ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h - u * p * d) : 'XZY' === o && (this._x = u * c * h - l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h + u * p * d),
            !1 !== e && this._onChangeCallback(),
            this
        },
        setFromAxisAngle: function(t, e) {
            var n = e / 2
              , i = Math.sin(n);
            return this._x = t.x * i,
            this._y = t.y * i,
            this._z = t.z * i,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t) {
            var e, n = t.elements, i = n[0], r = n[4], o = n[8], a = n[1], s = n[5], l = n[9], c = n[2], h = n[6], u = n[10], p = i + s + u;
            return p > 0 ? (e = .5 / Math.sqrt(p + 1),
            this._w = .25 / e,
            this._x = (h - l) * e,
            this._y = (o - c) * e,
            this._z = (a - r) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u),
            this._w = (h - l) / e,
            this._x = .25 * e,
            this._y = (r + a) / e,
            this._z = (o + c) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u),
            this._w = (o - c) / e,
            this._x = (r + a) / e,
            this._y = .25 * e,
            this._z = (l + h) / e) : (e = 2 * Math.sqrt(1 + u - i - s),
            this._w = (a - r) / e,
            this._x = (o + c) / e,
            this._y = (l + h) / e,
            this._z = .25 * e),
            this._onChangeCallback(),
            this
        },
        setFromUnitVectors: function(t, e) {
            var n = t.dot(e) + 1;
            return n < 1e-6 ? (n = 0,
            Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
            this._y = t.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y,
            this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
            this._y = t.z * e.x - t.x * e.z,
            this._z = t.x * e.y - t.y * e.x,
            this._w = n),
            this.normalize()
        },
        angleTo: function(t) {
            return 2 * Math.acos(Math.abs(Ee.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function(t, e) {
            var n = this.angleTo(t);
            if (0 === n)
                return this;
            var i = Math.min(1, e / n);
            return this.slerp(t, i),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (t = 1 / t,
            this._x = this._x * t,
            this._y = this._y * t,
            this._z = this._z * t,
            this._w = this._w * t),
            this._onChangeCallback(),
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x
              , i = t._y
              , r = t._z
              , o = t._w
              , a = e._x
              , s = e._y
              , l = e._z
              , c = e._w;
            return this._x = n * c + o * a + i * l - r * s,
            this._y = i * c + o * s + r * a - n * l,
            this._z = r * c + o * l + n * s - i * a,
            this._w = o * c - n * a - i * s - r * l,
            this._onChangeCallback(),
            this
        },
        slerp: function(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            var n = this._x
              , i = this._y
              , r = this._z
              , o = this._w
              , a = o * t._w + n * t._x + i * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            a = -a) : this.copy(t),
            a >= 1)
                return this._w = o,
                this._x = n,
                this._y = i,
                this._z = r,
                this;
            var s = 1 - a * a;
            if (s <= Number.EPSILON) {
                var l = 1 - e;
                return this._w = l * o + e * this._w,
                this._x = l * n + e * this._x,
                this._y = l * i + e * this._y,
                this._z = l * r + e * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            var c = Math.sqrt(s)
              , h = Math.atan2(c, a)
              , u = Math.sin((1 - e) * h) / c
              , p = Math.sin(e * h) / c;
            return this._w = o * u + this._w * p,
            this._x = n * u + this._x * p,
            this._y = i * u + this._y * p,
            this._z = r * u + this._z * p,
            this._onChangeCallback(),
            this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this._onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        },
        _onChange: function(t) {
            return this._onChangeCallback = t,
            this
        },
        _onChangeCallback: function() {}
    });
    var De = new Oe
      , Ie = new Le;
    function Oe(t, e, n) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0
    }
    Object.assign(Oe.prototype, {
        isVector3: !0,
        set: function(t, e, n) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error('index is out of range: ' + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        },
        applyEuler: function(t) {
            return !t || t.isEuler,
            this.applyQuaternion(Ie.setFromEuler(t))
        },
        applyAxisAngle: function(t, e) {
            return this.applyQuaternion(Ie.setFromAxisAngle(t, e))
        },
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i,
            this.y = r[1] * e + r[4] * n + r[7] * i,
            this.z = r[2] * e + r[5] * n + r[8] * i,
            this
        },
        applyNormalMatrix: function(t) {
            return this.applyMatrix3(t).normalize()
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements
              , o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o,
            this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o,
            this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o,
            this
        },
        applyQuaternion: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = t.x
              , o = t.y
              , a = t.z
              , s = t.w
              , l = s * e + o * i - a * n
              , c = s * n + a * e - r * i
              , h = s * i + r * n - o * e
              , u = -r * e - o * n - a * i;
            return this.x = l * s + u * -r + c * -a - h * -o,
            this.y = c * s + u * -o + h * -r - l * -a,
            this.z = h * s + u * -a + l * -o - c * -r,
            this
        },
        project: function(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        },
        transformDirection: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i,
            this.y = r[1] * e + r[5] * n + r[9] * i,
            this.z = r[2] * e + r[6] * n + r[10] * i,
            this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this
        },
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var n = t.x
              , i = t.y
              , r = t.z
              , o = e.x
              , a = e.y
              , s = e.z;
            return this.x = i * s - r * a,
            this.y = r * o - n * s,
            this.z = n * a - i * o,
            this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function(t) {
            return De.copy(this).projectOnVector(t),
            this.sub(De)
        },
        reflect: function(t) {
            return this.sub(De.copy(t).multiplyScalar(2 * this.dot(t)))
        },
        angleTo: function(t) {
            var e = Math.sqrt(this.lengthSq() * t.lengthSq())
              , n = this.dot(t) / e;
            return Math.acos(Ee.clamp(n, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , n = this.y - t.y
              , i = this.z - t.z;
            return e * e + n * n + i * i
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function(t, e, n) {
            var i = Math.sin(e) * t;
            return this.x = i * Math.sin(n),
            this.y = Math.cos(e) * t,
            this.z = i * Math.cos(n),
            this
        },
        setFromCylindrical: function(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function(t, e, n) {
            return this.x = t * Math.sin(e),
            this.y = n,
            this.z = t * Math.cos(e),
            this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length()
              , n = this.setFromMatrixColumn(t, 1).length()
              , i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = n,
            this.z = i,
            this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
    });
    var je, Ne = new Oe;
    function ke() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length
    }
    Object.assign(ke.prototype, {
        isMatrix3: !0,
        set: function(t, e, n, i, r, o, a, s, l) {
            var c = this.elements;
            return c[0] = t,
            c[1] = i,
            c[2] = a,
            c[3] = e,
            c[4] = r,
            c[5] = s,
            c[6] = n,
            c[7] = o,
            c[8] = l,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        },
        applyToBufferAttribute: function(t) {
            for (var e = 0, n = t.count; e < n; e++)
                Ne.x = t.getX(e),
                Ne.y = t.getY(e),
                Ne.z = t.getZ(e),
                Ne.applyMatrix3(this),
                t.setXYZ(e, Ne.x, Ne.y, Ne.z);
            return t
        },
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , i = e.elements
              , r = this.elements
              , o = n[0]
              , a = n[3]
              , s = n[6]
              , l = n[1]
              , c = n[4]
              , h = n[7]
              , u = n[2]
              , p = n[5]
              , d = n[8]
              , f = i[0]
              , m = i[3]
              , g = i[6]
              , v = i[1]
              , y = i[4]
              , x = i[7]
              , b = i[2]
              , _ = i[5]
              , M = i[8];
            return r[0] = o * f + a * v + s * b,
            r[3] = o * m + a * y + s * _,
            r[6] = o * g + a * x + s * M,
            r[1] = l * f + c * v + h * b,
            r[4] = l * m + c * y + h * _,
            r[7] = l * g + c * x + h * M,
            r[2] = u * f + p * v + d * b,
            r[5] = u * m + p * y + d * _,
            r[8] = u * g + p * x + d * M,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        },
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , o = t[4]
              , a = t[5]
              , s = t[6]
              , l = t[7]
              , c = t[8];
            return e * o * c - e * a * l - n * r * c + n * a * s + i * r * l - i * o * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4;
            var n = t.elements
              , i = this.elements
              , r = n[0]
              , o = n[1]
              , a = n[2]
              , s = n[3]
              , l = n[4]
              , c = n[5]
              , h = n[6]
              , u = n[7]
              , p = n[8]
              , d = p * l - c * u
              , f = c * h - p * s
              , m = u * s - l * h
              , g = r * d + o * f + a * m;
            if (0 === g) {
                if (!0 === e)
                    throw new Error('THREE.Matrix3: .getInverse() can\'t invert matrix, determinant is 0');
                return this.identity()
            }
            var v = 1 / g;
            return i[0] = d * v,
            i[1] = (a * u - p * o) * v,
            i[2] = (c * o - a * l) * v,
            i[3] = f * v,
            i[4] = (p * r - a * h) * v,
            i[5] = (a * s - c * r) * v,
            i[6] = m * v,
            i[7] = (o * h - u * r) * v,
            i[8] = (l * r - o * s) * v,
            this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        },
        setUvTransform: function(t, e, n, i, r, o, a) {
            var s = Math.cos(r)
              , l = Math.sin(r);
            this.set(n * s, n * l, -n * (s * o + l * a) + o + t, -i * l, i * s, -i * (-l * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var n = this.elements;
            return n[0] *= t,
            n[3] *= t,
            n[6] *= t,
            n[1] *= e,
            n[4] *= e,
            n[7] *= e,
            this
        },
        rotate: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t)
              , i = this.elements
              , r = i[0]
              , o = i[3]
              , a = i[6]
              , s = i[1]
              , l = i[4]
              , c = i[7];
            return i[0] = e * r + n * s,
            i[3] = e * o + n * l,
            i[6] = e * a + n * c,
            i[1] = -n * r + e * s,
            i[4] = -n * o + e * l,
            i[7] = -n * a + e * c,
            this
        },
        translate: function(t, e) {
            var n = this.elements;
            return n[0] += t * n[2],
            n[3] += t * n[5],
            n[6] += t * n[8],
            n[1] += e * n[2],
            n[4] += e * n[5],
            n[7] += e * n[8],
            this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                if (e[i] !== n[i])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
    });
    var Fe = {
        getDataURL: function(t) {
            var e;
            if ('undefined' == typeof HTMLCanvasElement)
                return t.src;
            if (t instanceof HTMLCanvasElement)
                e = t;
            else {
                void 0 === je && (je = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')),
                je.width = t.width,
                je.height = t.height;
                var n = je.getContext('2d');
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                e = je
            }
            return e.width > 2048 || e.height > 2048 ? e.toDataURL('image/jpeg', .6) : e.toDataURL('image/png')
        }
    }
      , ze = 0;
    function Re(t, e, n, i, r, o, a, s, l, c) {
        Object.defineProperty(this, 'id', {
            value: ze++
        }),
        this.uuid = Ee.generateUUID(),
        this.name = '',
        this.image = void 0 !== t ? t : Re.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== e ? e : Re.DEFAULT_MAPPING,
        this.wrapS = void 0 !== n ? n : lt,
        this.wrapT = void 0 !== i ? i : lt,
        this.magFilter = void 0 !== r ? r : dt,
        this.minFilter = void 0 !== o ? o : mt,
        this.anisotropy = void 0 !== l ? l : 1,
        this.format = void 0 !== a ? a : Lt,
        this.type = void 0 !== s ? s : gt,
        this.offset = new Te(0,0),
        this.repeat = new Te(1,1),
        this.center = new Te(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new ke,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== c ? c : he,
        this.version = 0,
        this.onUpdate = null
    }
    function Ue(t, e, n, i) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0,
        this.w = void 0 !== i ? i : 1
    }
    function Be(t, e, n) {
        this.width = t,
        this.height = e,
        this.scissor = new Ue(0,0,t,e),
        this.scissorTest = !1,
        this.viewport = new Ue(0,0,t,e),
        n = n || {},
        this.texture = new Re(void 0,void 0,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.texture.image = {},
        this.texture.image.width = t,
        this.texture.image.height = e,
        this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
        this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : dt,
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }
    function Ve(t, e, n) {
        Be.call(this, t, e, n),
        this.samples = 4
    }
    Re.DEFAULT_IMAGE = void 0,
    Re.DEFAULT_MAPPING = 300,
    Re.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: Re,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            var e = void 0 === t || 'string' == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = Ee.generateUUID()),
                !e && void 0 === t.images[i.uuid]) {
                    var r;
                    if (Array.isArray(i)) {
                        r = [];
                        for (var o = 0, a = i.length; o < a; o++)
                            r.push(Fe.getDataURL(i[o]))
                    } else
                        r = Fe.getDataURL(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: r
                    }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n),
            n
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        },
        transformUv: function(t) {
            if (300 !== this.mapping)
                return t;
            if (t.applyMatrix3(this.matrix),
            t.x < 0 || t.x > 1)
                switch (this.wrapS) {
                case st:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case lt:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case ct:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
            if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                case st:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case lt:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case ct:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
            return this.flipY && (t.y = 1 - t.y),
            t
        }
    }),
    Object.defineProperty(Re.prototype, 'needsUpdate', {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.defineProperties(Ue.prototype, {
        width: {
            get: function() {
                return this.z
            },
            set: function(t) {
                this.z = t
            }
        },
        height: {
            get: function() {
                return this.w
            },
            set: function(t) {
                this.w = t
            }
        }
    }),
    Object.assign(Ue.prototype, {
        isVector4: !0,
        set: function(t, e, n, i) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = i,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setW: function(t) {
            return this.w = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error('index is out of range: ' + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , i = this.z
              , r = this.w
              , o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r,
            this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r,
            this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r,
            this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, n, i, r, o = t.elements, a = o[0], s = o[4], l = o[8], c = o[1], h = o[5], u = o[9], p = o[2], d = o[6], f = o[10];
            if (Math.abs(s - c) < .01 && Math.abs(l - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(s + c) < .1 && Math.abs(l + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + h + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                e = Math.PI;
                var m = (a + 1) / 2
                  , g = (h + 1) / 2
                  , v = (f + 1) / 2
                  , y = (s + c) / 4
                  , x = (l + p) / 4
                  , b = (u + d) / 4;
                return m > g && m > v ? m < .01 ? (n = 0,
                i = .707106781,
                r = .707106781) : (i = y / (n = Math.sqrt(m)),
                r = x / n) : g > v ? g < .01 ? (n = .707106781,
                i = 0,
                r = .707106781) : (n = y / (i = Math.sqrt(g)),
                r = b / i) : v < .01 ? (n = .707106781,
                i = .707106781,
                r = 0) : (n = x / (r = Math.sqrt(v)),
                i = b / r),
                this.set(n, i, r, e),
                this
            }
            var _ = Math.sqrt((d - u) * (d - u) + (l - p) * (l - p) + (c - s) * (c - s));
            return Math.abs(_) < .001 && (_ = 1),
            this.x = (d - u) / _,
            this.y = (l - p) / _,
            this.z = (c - s) / _,
            this.w = Math.acos((a + h + f - 1) / 2),
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        },
        clampScalar: function(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this.w = Math.max(t, Math.min(e, this.w)),
            this
        },
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
    }),
    Be.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: Be,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t,
            this.height = e,
            this.texture.image.width = t,
            this.texture.image.height = e,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        }
    }),
    Ve.prototype = Object.assign(Object.create(Be.prototype), {
        constructor: Ve,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(t) {
            return Be.prototype.copy.call(this, t),
            this.samples = t.samples,
            this
        }
    });
    var Ge = new Oe
      , He = new Ze
      , We = new Oe(0,0,0)
      , Xe = new Oe(1,1,1)
      , qe = new Oe
      , Ye = new Oe
      , Je = new Oe;
    function Ze() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length
    }
    Object.assign(Ze.prototype, {
        isMatrix4: !0,
        set: function(t, e, n, i, r, o, a, s, l, c, h, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = n,
            g[12] = i,
            g[1] = r,
            g[5] = o,
            g[9] = a,
            g[13] = s,
            g[2] = l,
            g[6] = c,
            g[10] = h,
            g[14] = u,
            g[3] = p,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new Ze).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            e[9] = n[9],
            e[10] = n[10],
            e[11] = n[11],
            e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            e[15] = n[15],
            this
        },
        copyPosition: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function(t) {
            var e = this.elements
              , n = t.elements
              , i = 1 / Ge.setFromMatrixColumn(t, 0).length()
              , r = 1 / Ge.setFromMatrixColumn(t, 1).length()
              , o = 1 / Ge.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i,
            e[1] = n[1] * i,
            e[2] = n[2] * i,
            e[3] = 0,
            e[4] = n[4] * r,
            e[5] = n[5] * r,
            e[6] = n[6] * r,
            e[7] = 0,
            e[8] = n[8] * o,
            e[9] = n[9] * o,
            e[10] = n[10] * o,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        makeRotationFromEuler: function(t) {
            !t || t.isEuler;
            var e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z
              , o = Math.cos(n)
              , a = Math.sin(n)
              , s = Math.cos(i)
              , l = Math.sin(i)
              , c = Math.cos(r)
              , h = Math.sin(r);
            if ('XYZ' === t.order) {
                var u = o * c
                  , p = o * h
                  , d = a * c
                  , f = a * h;
                e[0] = s * c,
                e[4] = -s * h,
                e[8] = l,
                e[1] = p + d * l,
                e[5] = u - f * l,
                e[9] = -a * s,
                e[2] = f - u * l,
                e[6] = d + p * l,
                e[10] = o * s
            } else if ('YXZ' === t.order) {
                var m = s * c
                  , g = s * h
                  , v = l * c
                  , y = l * h;
                e[0] = m + y * a,
                e[4] = v * a - g,
                e[8] = o * l,
                e[1] = o * h,
                e[5] = o * c,
                e[9] = -a,
                e[2] = g * a - v,
                e[6] = y + m * a,
                e[10] = o * s
            } else if ('ZXY' === t.order) {
                m = s * c,
                g = s * h,
                v = l * c,
                y = l * h;
                e[0] = m - y * a,
                e[4] = -o * h,
                e[8] = v + g * a,
                e[1] = g + v * a,
                e[5] = o * c,
                e[9] = y - m * a,
                e[2] = -o * l,
                e[6] = a,
                e[10] = o * s
            } else if ('ZYX' === t.order) {
                u = o * c,
                p = o * h,
                d = a * c,
                f = a * h;
                e[0] = s * c,
                e[4] = d * l - p,
                e[8] = u * l + f,
                e[1] = s * h,
                e[5] = f * l + u,
                e[9] = p * l - d,
                e[2] = -l,
                e[6] = a * s,
                e[10] = o * s
            } else if ('YZX' === t.order) {
                var x = o * s
                  , b = o * l
                  , _ = a * s
                  , M = a * l;
                e[0] = s * c,
                e[4] = M - x * h,
                e[8] = _ * h + b,
                e[1] = h,
                e[5] = o * c,
                e[9] = -a * c,
                e[2] = -l * c,
                e[6] = b * h + _,
                e[10] = x - M * h
            } else if ('XZY' === t.order) {
                x = o * s,
                b = o * l,
                _ = a * s,
                M = a * l;
                e[0] = s * c,
                e[4] = -h,
                e[8] = l * c,
                e[1] = x * h + M,
                e[5] = o * c,
                e[9] = b * h - _,
                e[2] = _ * h - b,
                e[6] = a * c,
                e[10] = M * h + x
            }
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        makeRotationFromQuaternion: function(t) {
            return this.compose(We, t, Xe)
        },
        lookAt: function(t, e, n) {
            var i = this.elements;
            return Je.subVectors(t, e),
            0 === Je.lengthSq() && (Je.z = 1),
            Je.normalize(),
            qe.crossVectors(n, Je),
            0 === qe.lengthSq() && (1 === Math.abs(n.z) ? Je.x += 1e-4 : Je.z += 1e-4,
            Je.normalize(),
            qe.crossVectors(n, Je)),
            qe.normalize(),
            Ye.crossVectors(Je, qe),
            i[0] = qe.x,
            i[4] = Ye.x,
            i[8] = Je.x,
            i[1] = qe.y,
            i[5] = Ye.y,
            i[9] = Je.y,
            i[2] = qe.z,
            i[6] = Ye.z,
            i[10] = Je.z,
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , i = e.elements
              , r = this.elements
              , o = n[0]
              , a = n[4]
              , s = n[8]
              , l = n[12]
              , c = n[1]
              , h = n[5]
              , u = n[9]
              , p = n[13]
              , d = n[2]
              , f = n[6]
              , m = n[10]
              , g = n[14]
              , v = n[3]
              , y = n[7]
              , x = n[11]
              , b = n[15]
              , _ = i[0]
              , M = i[4]
              , w = i[8]
              , S = i[12]
              , P = i[1]
              , C = i[5]
              , A = i[9]
              , E = i[13]
              , T = i[2]
              , L = i[6]
              , D = i[10]
              , I = i[14]
              , O = i[3]
              , j = i[7]
              , N = i[11]
              , k = i[15];
            return r[0] = o * _ + a * P + s * T + l * O,
            r[4] = o * M + a * C + s * L + l * j,
            r[8] = o * w + a * A + s * D + l * N,
            r[12] = o * S + a * E + s * I + l * k,
            r[1] = c * _ + h * P + u * T + p * O,
            r[5] = c * M + h * C + u * L + p * j,
            r[9] = c * w + h * A + u * D + p * N,
            r[13] = c * S + h * E + u * I + p * k,
            r[2] = d * _ + f * P + m * T + g * O,
            r[6] = d * M + f * C + m * L + g * j,
            r[10] = d * w + f * A + m * D + g * N,
            r[14] = d * S + f * E + m * I + g * k,
            r[3] = v * _ + y * P + x * T + b * O,
            r[7] = v * M + y * C + x * L + b * j,
            r[11] = v * w + y * A + x * D + b * N,
            r[15] = v * S + y * E + x * I + b * k,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        },
        applyToBufferAttribute: function(t) {
            for (var e = 0, n = t.count; e < n; e++)
                Ge.x = t.getX(e),
                Ge.y = t.getY(e),
                Ge.z = t.getZ(e),
                Ge.applyMatrix4(this),
                t.setXYZ(e, Ge.x, Ge.y, Ge.z);
            return t
        },
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[4]
              , i = t[8]
              , r = t[12]
              , o = t[1]
              , a = t[5]
              , s = t[9]
              , l = t[13]
              , c = t[2]
              , h = t[6]
              , u = t[10]
              , p = t[14];
            return t[3] * (+r * s * h - i * l * h - r * a * u + n * l * u + i * a * p - n * s * p) + t[7] * (+e * s * p - e * l * u + r * o * u - i * o * p + i * l * c - r * s * c) + t[11] * (+e * l * h - e * a * p - r * o * h + n * o * p + r * a * c - n * l * c) + t[15] * (-i * a * c - e * s * h + e * a * u + i * o * h - n * o * u + n * s * c)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1],
            e[1] = e[4],
            e[4] = t,
            t = e[2],
            e[2] = e[8],
            e[8] = t,
            t = e[6],
            e[6] = e[9],
            e[9] = t,
            t = e[3],
            e[3] = e[12],
            e[12] = t,
            t = e[7],
            e[7] = e[13],
            e[13] = t,
            t = e[11],
            e[11] = e[14],
            e[14] = t,
            this
        },
        setPosition: function(t, e, n) {
            var i = this.elements;
            return t.isVector3 ? (i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z) : (i[12] = t,
            i[13] = e,
            i[14] = n),
            this
        },
        getInverse: function(t, e) {
            var n = this.elements
              , i = t.elements
              , r = i[0]
              , o = i[1]
              , a = i[2]
              , s = i[3]
              , l = i[4]
              , c = i[5]
              , h = i[6]
              , u = i[7]
              , p = i[8]
              , d = i[9]
              , f = i[10]
              , m = i[11]
              , g = i[12]
              , v = i[13]
              , y = i[14]
              , x = i[15]
              , b = d * y * u - v * f * u + v * h * m - c * y * m - d * h * x + c * f * x
              , _ = g * f * u - p * y * u - g * h * m + l * y * m + p * h * x - l * f * x
              , M = p * v * u - g * d * u + g * c * m - l * v * m - p * c * x + l * d * x
              , w = g * d * h - p * v * h - g * c * f + l * v * f + p * c * y - l * d * y
              , S = r * b + o * _ + a * M + s * w;
            if (0 === S) {
                if (!0 === e)
                    throw new Error('THREE.Matrix4: .getInverse() can\'t invert matrix, determinant is 0');
                return this.identity()
            }
            var P = 1 / S;
            return n[0] = b * P,
            n[1] = (v * f * s - d * y * s - v * a * m + o * y * m + d * a * x - o * f * x) * P,
            n[2] = (c * y * s - v * h * s + v * a * u - o * y * u - c * a * x + o * h * x) * P,
            n[3] = (d * h * s - c * f * s - d * a * u + o * f * u + c * a * m - o * h * m) * P,
            n[4] = _ * P,
            n[5] = (p * y * s - g * f * s + g * a * m - r * y * m - p * a * x + r * f * x) * P,
            n[6] = (g * h * s - l * y * s - g * a * u + r * y * u + l * a * x - r * h * x) * P,
            n[7] = (l * f * s - p * h * s + p * a * u - r * f * u - l * a * m + r * h * m) * P,
            n[8] = M * P,
            n[9] = (g * d * s - p * v * s - g * o * m + r * v * m + p * o * x - r * d * x) * P,
            n[10] = (l * v * s - g * c * s + g * o * u - r * v * u - l * o * x + r * c * x) * P,
            n[11] = (p * c * s - l * d * s - p * o * u + r * d * u + l * o * m - r * c * m) * P,
            n[12] = w * P,
            n[13] = (p * v * a - g * d * a + g * o * f - r * v * f - p * o * y + r * d * y) * P,
            n[14] = (g * c * a - l * v * a - g * o * h + r * v * h + l * o * y - r * c * y) * P,
            n[15] = (l * d * a - p * c * a + p * o * h - r * d * h - l * o * f + r * c * f) * P,
            this
        },
        scale: function(t) {
            var e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z;
            return e[0] *= n,
            e[4] *= i,
            e[8] *= r,
            e[1] *= n,
            e[5] *= i,
            e[9] *= r,
            e[2] *= n,
            e[6] *= i,
            e[10] *= r,
            e[3] *= n,
            e[7] *= i,
            e[11] *= r,
            this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements
              , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
              , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
              , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(t, e) {
            var n = Math.cos(e)
              , i = Math.sin(e)
              , r = 1 - n
              , o = t.x
              , a = t.y
              , s = t.z
              , l = r * o
              , c = r * a;
            return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(t, e, n) {
            var i = this.elements
              , r = e._x
              , o = e._y
              , a = e._z
              , s = e._w
              , l = r + r
              , c = o + o
              , h = a + a
              , u = r * l
              , p = r * c
              , d = r * h
              , f = o * c
              , m = o * h
              , g = a * h
              , v = s * l
              , y = s * c
              , x = s * h
              , b = n.x
              , _ = n.y
              , M = n.z;
            return i[0] = (1 - (f + g)) * b,
            i[1] = (p + x) * b,
            i[2] = (d - y) * b,
            i[3] = 0,
            i[4] = (p - x) * _,
            i[5] = (1 - (u + g)) * _,
            i[6] = (m + v) * _,
            i[7] = 0,
            i[8] = (d + y) * M,
            i[9] = (m - v) * M,
            i[10] = (1 - (u + f)) * M,
            i[11] = 0,
            i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z,
            i[15] = 1,
            this
        },
        decompose: function(t, e, n) {
            var i = this.elements
              , r = Ge.set(i[0], i[1], i[2]).length()
              , o = Ge.set(i[4], i[5], i[6]).length()
              , a = Ge.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
            t.x = i[12],
            t.y = i[13],
            t.z = i[14],
            He.copy(this);
            var s = 1 / r
              , l = 1 / o
              , c = 1 / a;
            return He.elements[0] *= s,
            He.elements[1] *= s,
            He.elements[2] *= s,
            He.elements[4] *= l,
            He.elements[5] *= l,
            He.elements[6] *= l,
            He.elements[8] *= c,
            He.elements[9] *= c,
            He.elements[10] *= c,
            e.setFromRotationMatrix(He),
            n.x = r,
            n.y = o,
            n.z = a,
            this
        },
        makePerspective: function(t, e, n, i, r, o) {
            var a = this.elements
              , s = 2 * r / (e - t)
              , l = 2 * r / (n - i)
              , c = (e + t) / (e - t)
              , h = (n + i) / (n - i)
              , u = -(o + r) / (o - r)
              , p = -2 * o * r / (o - r);
            return a[0] = s,
            a[4] = 0,
            a[8] = c,
            a[12] = 0,
            a[1] = 0,
            a[5] = l,
            a[9] = h,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = u,
            a[14] = p,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(t, e, n, i, r, o) {
            var a = this.elements
              , s = 1 / (e - t)
              , l = 1 / (n - i)
              , c = 1 / (o - r)
              , h = (e + t) * s
              , u = (n + i) * l
              , p = (o + r) * c;
            return a[0] = 2 * s,
            a[4] = 0,
            a[8] = 0,
            a[12] = -h,
            a[1] = 0,
            a[5] = 2 * l,
            a[9] = 0,
            a[13] = -u,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * c,
            a[14] = -p,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                if (e[i] !== n[i])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t[e + 9] = n[9],
            t[e + 10] = n[10],
            t[e + 11] = n[11],
            t[e + 12] = n[12],
            t[e + 13] = n[13],
            t[e + 14] = n[14],
            t[e + 15] = n[15],
            t
        }
    });
    var Ke = new Ze
      , Qe = new Le;
    function $e(t, e, n, i) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._order = i || $e.DefaultOrder
    }
    function tn() {
        this.mask = 1
    }
    $e.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'],
    $e.DefaultOrder = 'XYZ',
    Object.defineProperties($e.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this._onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t,
                this._onChangeCallback()
            }
        }
    }),
    Object.assign($e.prototype, {
        isEuler: !0,
        set: function(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._order = i || this._order,
            this._onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this._onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t, e, n) {
            var i = Ee.clamp
              , r = t.elements
              , o = r[0]
              , a = r[4]
              , s = r[8]
              , l = r[1]
              , c = r[5]
              , h = r[9]
              , u = r[2]
              , p = r[6]
              , d = r[10];
            return 'XYZ' === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, d),
            this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, c),
            this._z = 0)) : 'YXZ' === e ? (this._x = Math.asin(-i(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, d),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, o),
            this._z = 0)) : 'ZXY' === e ? (this._x = Math.asin(i(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, d),
            this._z = Math.atan2(-a, c)) : (this._y = 0,
            this._z = Math.atan2(l, o))) : 'ZYX' === e ? (this._y = Math.asin(-i(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, d),
            this._z = Math.atan2(l, o)) : (this._x = 0,
            this._z = Math.atan2(-a, c))) : 'YZX' === e ? (this._z = Math.asin(i(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-u, o)) : (this._x = 0,
            this._y = Math.atan2(s, d))) : 'XZY' === e && (this._z = Math.asin(-i(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(p, c),
            this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, d),
            this._y = 0)),
            this._order = e,
            !1 !== n && this._onChangeCallback(),
            this
        },
        setFromQuaternion: function(t, e, n) {
            return Ke.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Ke, e, n)
        },
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function(t) {
            return Qe.setFromEuler(this),
            this.setFromQuaternion(Qe, t)
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new Oe(this._x,this._y,this._z)
        },
        _onChange: function(t) {
            return this._onChangeCallback = t,
            this
        },
        _onChangeCallback: function() {}
    }),
    Object.assign(tn.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        enableAll: function() {
            this.mask = -1
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        disableAll: function() {
            this.mask = 0
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var en = 0
      , nn = new Oe
      , rn = new Le
      , on = new Ze
      , an = new Oe
      , sn = new Oe
      , ln = new Oe
      , cn = new Le
      , hn = new Oe(1,0,0)
      , un = new Oe(0,1,0)
      , pn = new Oe(0,0,1)
      , dn = {
        type: 'added'
    }
      , fn = {
        type: 'removed'
    };
    function mn() {
        Object.defineProperty(this, 'id', {
            value: en++
        }),
        this.uuid = Ee.generateUUID(),
        this.name = '',
        this.type = 'Object3D',
        this.parent = null,
        this.children = [],
        this.up = mn.DefaultUp.clone();
        var t = new Oe
          , e = new $e
          , n = new Le
          , i = new Oe(1,1,1);
        e._onChange((function() {
            n.setFromEuler(e, !1)
        }
        )),
        n._onChange((function() {
            e.setFromQuaternion(n, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Ze
            },
            normalMatrix: {
                value: new ke
            }
        }),
        this.matrix = new Ze,
        this.matrixWorld = new Ze,
        this.matrixAutoUpdate = mn.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new tn,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function gn() {
        mn.call(this),
        this.type = 'Scene',
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{
            detail: this
        }))
    }
    mn.DefaultUp = new Oe(0,1,0),
    mn.DefaultMatrixAutoUpdate = !0,
    mn.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: mn,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t),
            this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function(t, e) {
            return rn.setFromAxisAngle(t, e),
            this.quaternion.multiply(rn),
            this
        },
        rotateOnWorldAxis: function(t, e) {
            return rn.setFromAxisAngle(t, e),
            this.quaternion.premultiply(rn),
            this
        },
        rotateX: function(t) {
            return this.rotateOnAxis(hn, t)
        },
        rotateY: function(t) {
            return this.rotateOnAxis(un, t)
        },
        rotateZ: function(t) {
            return this.rotateOnAxis(pn, t)
        },
        translateOnAxis: function(t, e) {
            return nn.copy(t).applyQuaternion(this.quaternion),
            this.position.add(nn.multiplyScalar(e)),
            this
        },
        translateX: function(t) {
            return this.translateOnAxis(hn, t)
        },
        translateY: function(t) {
            return this.translateOnAxis(un, t)
        },
        translateZ: function(t) {
            return this.translateOnAxis(pn, t)
        },
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(t) {
            return t.applyMatrix4(on.getInverse(this.matrixWorld))
        },
        lookAt: function(t, e, n) {
            t.isVector3 ? an.copy(t) : an.set(t, e, n);
            var i = this.parent;
            this.updateWorldMatrix(!0, !1),
            sn.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? on.lookAt(sn, an, this.up) : on.lookAt(an, sn, this.up),
            this.quaternion.setFromRotationMatrix(on),
            i && (on.extractRotation(i.matrixWorld),
            rn.setFromRotationMatrix(on),
            this.quaternion.premultiply(rn.inverse()))
        },
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++)
                    this.add(arguments[e]);
                return this
            }
            return t === this ? this : (t && t.isObject3D && (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            this.children.push(t),
            t.dispatchEvent(dn)),
            this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++)
                    this.remove(arguments[e]);
                return this
            }
            var n = this.children.indexOf(t);
            return -1 !== n && (t.parent = null,
            this.children.splice(n, 1),
            t.dispatchEvent(fn)),
            this
        },
        attach: function(t) {
            return this.updateWorldMatrix(!0, !1),
            on.getInverse(this.matrixWorld),
            null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
            on.multiply(t.parent.matrixWorld)),
            t.applyMatrix(on),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty('id', t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty('name', t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e)
                return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
                var r = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (t = new Oe),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(t) {
            return void 0 === t && (t = new Le),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(sn, t, ln),
            t
        },
        getWorldScale: function(t) {
            return void 0 === t && (t = new Oe),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(sn, cn, t),
            t
        },
        getWorldDirection: function(t) {
            void 0 === t && (t = new Oe),
            this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
                e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
                e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function(t, e) {
            var n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e)
                for (var i = this.children, r = 0, o = i.length; r < o; r++)
                    i[r].updateWorldMatrix(!1, !0)
        },
        toJSON: function(t) {
            var e = void 0 === t || 'string' == typeof t
              , n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            n.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            });
            var i = {};
            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                n.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            '' !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isMesh && this.drawMode !== se && (i.drawMode = this.drawMode),
            this.isInstancedMesh && (i.type = 'InstancedMesh',
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON()),
            this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, l = a.length; s < l; s++) {
                            var c = a[s];
                            r(t.shapes, c)
                        }
                    else
                        r(t.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var h = [];
                    for (s = 0,
                    l = this.material.length; s < l; s++)
                        h.push(r(t.materials, this.material[s]));
                    i.material = h
                } else
                    i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (s = 0; s < this.children.length; s++)
                    i.children.push(this.children[s].toJSON(t).object)
            }
            if (e) {
                var u = m(t.geometries)
                  , p = m(t.materials)
                  , d = m(t.textures)
                  , f = m(t.images);
                a = m(t.shapes);
                u.length > 0 && (n.geometries = u),
                p.length > 0 && (n.materials = p),
                d.length > 0 && (n.textures = d),
                f.length > 0 && (n.images = f),
                a.length > 0 && (n.shapes = a)
            }
            return n.object = i,
            n;
            function m(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0),
            this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var i = t.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }),
    gn.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: gn,
        isScene: !0,
        copy: function(t, e) {
            return mn.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        },
        toJSON: function(t) {
            var e = mn.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        }
    });
    var vn = [new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe]
      , yn = new Oe
      , xn = new Ln
      , bn = new Oe
      , _n = new Oe
      , Mn = new Oe
      , wn = new Oe
      , Sn = new Oe
      , Pn = new Oe
      , Cn = new Oe
      , An = new Oe
      , En = new Oe
      , Tn = new Oe;
    function Ln(t, e) {
        this.min = void 0 !== t ? t : new Oe(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new Oe(-1 / 0,-1 / 0,-1 / 0)
    }
    function Dn(t, e, n, i, r) {
        var o, a;
        for (o = 0,
        a = t.length - 3; o <= a; o += 3) {
            Tn.fromArray(t, o);
            var s = r.x * Math.abs(Tn.x) + r.y * Math.abs(Tn.y) + r.z * Math.abs(Tn.z)
              , l = e.dot(Tn)
              , c = n.dot(Tn)
              , h = i.dot(Tn);
            if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > s)
                return !1
        }
        return !0
    }
    Object.assign(Ln.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.length; s < l; s += 3) {
                var c = t[s]
                  , h = t[s + 1]
                  , u = t[s + 2];
                c < e && (e = c),
                h < n && (n = h),
                u < i && (i = u),
                c > r && (r = c),
                h > o && (o = h),
                u > a && (a = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, a),
            this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.count; s < l; s++) {
                var c = t.getX(s)
                  , h = t.getY(s)
                  , u = t.getZ(s);
                c < e && (e = c),
                h < n && (n = h),
                u < i && (i = u),
                c > r && (r = c),
                h > o && (o = h),
                u > a && (a = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, a),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function(t, e) {
            var n = yn.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        },
        setFromObject: function(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (t = new Oe),
            this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (t = new Oe),
            this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        expandByObject: function(t) {
            t.updateWorldMatrix(!1, !1);
            var e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
            xn.copy(e.boundingBox),
            xn.applyMatrix4(t.matrixWorld),
            this.expandByPoint(xn.min),
            this.expandByPoint(xn.max));
            for (var n = t.children, i = 0, r = n.length; i < r; i++)
                this.expandByObject(n[i]);
            return this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (e = new Oe),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function(t) {
            return this.clampPoint(t.center, yn),
            yn.distanceToSquared(t.center) <= t.radius * t.radius
        },
        intersectsPlane: function(t) {
            var e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
            n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            n = t.normal.x * this.min.x),
            t.normal.y > 0 ? (e += t.normal.y * this.min.y,
            n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            n += t.normal.y * this.min.y),
            t.normal.z > 0 ? (e += t.normal.z * this.min.z,
            n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            n += t.normal.z * this.min.z),
            e <= -t.constant && n >= -t.constant
        },
        intersectsTriangle: function(t) {
            if (this.isEmpty())
                return !1;
            this.getCenter(Cn),
            An.subVectors(this.max, Cn),
            bn.subVectors(t.a, Cn),
            _n.subVectors(t.b, Cn),
            Mn.subVectors(t.c, Cn),
            wn.subVectors(_n, bn),
            Sn.subVectors(Mn, _n),
            Pn.subVectors(bn, Mn);
            var e = [0, -wn.z, wn.y, 0, -Sn.z, Sn.y, 0, -Pn.z, Pn.y, wn.z, 0, -wn.x, Sn.z, 0, -Sn.x, Pn.z, 0, -Pn.x, -wn.y, wn.x, 0, -Sn.y, Sn.x, 0, -Pn.y, Pn.x, 0];
            return !!Dn(e, bn, _n, Mn, An) && (!!Dn(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], bn, _n, Mn, An) && (En.crossVectors(wn, Sn),
            Dn(e = [En.x, En.y, En.z], bn, _n, Mn, An)))
        },
        clampPoint: function(t, e) {
            return void 0 === e && (e = new Oe),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function(t) {
            return yn.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        getBoundingSphere: function(t) {
            return this.getCenter(t.center),
            t.radius = .5 * this.getSize(yn).length(),
            t
        },
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        applyMatrix4: function(t) {
            return this.isEmpty() ? this : (vn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            vn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            vn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            vn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            vn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            vn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            vn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            vn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(vn),
            this)
        },
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    var In = new Ln;
    function On(t, e) {
        this.center = void 0 !== t ? t : new Oe,
        this.radius = void 0 !== e ? e : 0
    }
    Object.assign(On.prototype, {
        set: function(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        },
        setFromPoints: function(t, e) {
            var n = this.center;
            void 0 !== e ? n.copy(e) : In.setFromPoints(t).getCenter(n);
            for (var i = 0, r = 0, o = t.length; r < o; r++)
                i = Math.max(i, n.distanceToSquared(t[r]));
            return this.radius = Math.sqrt(i),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t);
            return void 0 === e && (e = new Oe),
            e.copy(t),
            n > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (t = new Ln),
            t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        },
        translate: function(t) {
            return this.center.add(t),
            this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    });
    var jn = new Oe
      , Nn = new Oe
      , kn = new Oe
      , Fn = new Oe
      , zn = new Oe
      , Rn = new Oe
      , Un = new Oe;
    function Bn(t, e) {
        this.origin = void 0 !== t ? t : new Oe,
        this.direction = void 0 !== e ? e : new Oe(0,0,-1)
    }
    Object.assign(Bn.prototype, {
        set: function(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        },
        at: function(t, e) {
            return void 0 === e && (e = new Oe),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        },
        recast: function(t) {
            return this.origin.copy(this.at(t, jn)),
            this
        },
        closestPointToPoint: function(t, e) {
            void 0 === e && (e = new Oe),
            e.subVectors(t, this.origin);
            var n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function(t) {
            var e = jn.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (jn.copy(this.direction).multiplyScalar(e).add(this.origin),
            jn.distanceToSquared(t))
        },
        distanceSqToSegment: function(t, e, n, i) {
            Nn.copy(t).add(e).multiplyScalar(.5),
            kn.copy(e).sub(t).normalize(),
            Fn.copy(this.origin).sub(Nn);
            var r, o, a, s, l = .5 * t.distanceTo(e), c = -this.direction.dot(kn), h = Fn.dot(this.direction), u = -Fn.dot(kn), p = Fn.lengthSq(), d = Math.abs(1 - c * c);
            if (d > 0)
                if (o = c * h - u,
                s = l * d,
                (r = c * u - h) >= 0)
                    if (o >= -s)
                        if (o <= s) {
                            var f = 1 / d;
                            a = (r *= f) * (r + c * (o *= f) + 2 * h) + o * (c * r + o + 2 * u) + p
                        } else
                            o = l,
                            a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + p;
                    else
                        o = -l,
                        a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + p;
                else
                    o <= -s ? a = -(r = Math.max(0, -(-c * l + h))) * r + (o = r > 0 ? -l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p : o <= s ? (r = 0,
                    a = (o = Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p) : a = -(r = Math.max(0, -(c * l + h))) * r + (o = r > 0 ? l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p;
            else
                o = c > 0 ? -l : l,
                a = -(r = Math.max(0, -(c * o + h))) * r + o * (o + 2 * u) + p;
            return n && n.copy(this.direction).multiplyScalar(r).add(this.origin),
            i && i.copy(kn).multiplyScalar(o).add(Nn),
            a
        },
        intersectSphere: function(t, e) {
            jn.subVectors(t.center, this.origin);
            var n = jn.dot(this.direction)
              , i = jn.dot(jn) - n * n
              , r = t.radius * t.radius;
            if (i > r)
                return null;
            var o = Math.sqrt(r - i)
              , a = n - o
              , s = n + o;
            return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e)
        },
        intersectsSphere: function(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 === e)
                return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function(t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var n, i, r, o, a, s, l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin;
            return l >= 0 ? (n = (t.min.x - u.x) * l,
            i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l,
            i = (t.min.x - u.x) * l),
            c >= 0 ? (r = (t.min.y - u.y) * c,
            o = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c,
            o = (t.min.y - u.y) * c),
            n > o || r > i ? null : ((r > n || n != n) && (n = r),
            (o < i || i != i) && (i = o),
            h >= 0 ? (a = (t.min.z - u.z) * h,
            s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h,
            s = (t.min.z - u.z) * h),
            n > s || a > i ? null : ((a > n || n != n) && (n = a),
            (s < i || i != i) && (i = s),
            i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        },
        intersectsBox: function(t) {
            return null !== this.intersectBox(t, jn)
        },
        intersectTriangle: function(t, e, n, i, r) {
            zn.subVectors(e, t),
            Rn.subVectors(n, t),
            Un.crossVectors(zn, Rn);
            var o, a = this.direction.dot(Un);
            if (a > 0) {
                if (i)
                    return null;
                o = 1
            } else {
                if (!(a < 0))
                    return null;
                o = -1,
                a = -a
            }
            Fn.subVectors(this.origin, t);
            var s = o * this.direction.dot(Rn.crossVectors(Fn, Rn));
            if (s < 0)
                return null;
            var l = o * this.direction.dot(zn.cross(Fn));
            if (l < 0)
                return null;
            if (s + l > a)
                return null;
            var c = -o * Fn.dot(Un);
            return c < 0 ? null : this.at(c / a, r)
        },
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    });
    var Vn = new Oe
      , Gn = new Oe
      , Hn = new ke;
    function Wn(t, e) {
        this.normal = void 0 !== t ? t : new Oe(1,0,0),
        this.constant = void 0 !== e ? e : 0
    }
    Object.assign(Wn.prototype, {
        isPlane: !0,
        set: function(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        },
        setComponents: function(t, e, n, i) {
            return this.normal.set(t, e, n),
            this.constant = i,
            this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function(t, e, n) {
            var i = Vn.subVectors(n, e).cross(Gn.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (e = new Oe),
            e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function(t, e) {
            void 0 === e && (e = new Oe);
            var n = t.delta(Vn)
              , i = this.normal.dot(n);
            if (0 === i)
                return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
            var r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
        },
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start)
              , n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (t = new Oe),
            t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function(t, e) {
            var n = e || Hn.getNormalMatrix(t)
              , i = this.coplanarPoint(Vn).applyMatrix4(t)
              , r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r),
            this
        },
        translate: function(t) {
            return this.constant -= t.dot(this.normal),
            this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    });
    var Xn = new Oe
      , qn = new Oe
      , Yn = new Oe
      , Jn = new Oe
      , Zn = new Oe
      , Kn = new Oe
      , Qn = new Oe
      , $n = new Oe
      , ti = new Oe
      , ei = new Oe;
    function ni(t, e, n) {
        this.a = void 0 !== t ? t : new Oe,
        this.b = void 0 !== e ? e : new Oe,
        this.c = void 0 !== n ? n : new Oe
    }
    Object.assign(ni, {
        getNormal: function(t, e, n, i) {
            void 0 === i && (i = new Oe),
            i.subVectors(n, e),
            Xn.subVectors(t, e),
            i.cross(Xn);
            var r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        },
        getBarycoord: function(t, e, n, i, r) {
            Xn.subVectors(i, e),
            qn.subVectors(n, e),
            Yn.subVectors(t, e);
            var o = Xn.dot(Xn)
              , a = Xn.dot(qn)
              , s = Xn.dot(Yn)
              , l = qn.dot(qn)
              , c = qn.dot(Yn)
              , h = o * l - a * a;
            if (void 0 === r && (r = new Oe),
            0 === h)
                return r.set(-2, -1, -1);
            var u = 1 / h
              , p = (l * s - a * c) * u
              , d = (o * c - a * s) * u;
            return r.set(1 - p - d, d, p)
        },
        containsPoint: function(t, e, n, i) {
            return ni.getBarycoord(t, e, n, i, Jn),
            Jn.x >= 0 && Jn.y >= 0 && Jn.x + Jn.y <= 1
        },
        getUV: function(t, e, n, i, r, o, a, s) {
            return this.getBarycoord(t, e, n, i, Jn),
            s.set(0, 0),
            s.addScaledVector(r, Jn.x),
            s.addScaledVector(o, Jn.y),
            s.addScaledVector(a, Jn.z),
            s
        },
        isFrontFacing: function(t, e, n, i) {
            return Xn.subVectors(n, e),
            qn.subVectors(t, e),
            Xn.cross(qn).dot(i) < 0
        }
    }),
    Object.assign(ni.prototype, {
        set: function(t, e, n) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(n),
            this
        },
        setFromPointsAndIndices: function(t, e, n, i) {
            return this.a.copy(t[e]),
            this.b.copy(t[n]),
            this.c.copy(t[i]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        },
        getArea: function() {
            return Xn.subVectors(this.c, this.b),
            qn.subVectors(this.a, this.b),
            .5 * Xn.cross(qn).length()
        },
        getMidpoint: function(t) {
            return void 0 === t && (t = new Oe),
            t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return ni.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (t = new Wn),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return ni.getBarycoord(t, this.a, this.b, this.c, e)
        },
        getUV: function(t, e, n, i, r) {
            return ni.getUV(t, this.a, this.b, this.c, e, n, i, r)
        },
        containsPoint: function(t) {
            return ni.containsPoint(t, this.a, this.b, this.c)
        },
        isFrontFacing: function(t) {
            return ni.isFrontFacing(this.a, this.b, this.c, t)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function(t, e) {
            void 0 === e && (e = new Oe);
            var n, i, r = this.a, o = this.b, a = this.c;
            Zn.subVectors(o, r),
            Kn.subVectors(a, r),
            $n.subVectors(t, r);
            var s = Zn.dot($n)
              , l = Kn.dot($n);
            if (s <= 0 && l <= 0)
                return e.copy(r);
            ti.subVectors(t, o);
            var c = Zn.dot(ti)
              , h = Kn.dot(ti);
            if (c >= 0 && h <= c)
                return e.copy(o);
            var u = s * h - c * l;
            if (u <= 0 && s >= 0 && c <= 0)
                return n = s / (s - c),
                e.copy(r).addScaledVector(Zn, n);
            ei.subVectors(t, a);
            var p = Zn.dot(ei)
              , d = Kn.dot(ei);
            if (d >= 0 && p <= d)
                return e.copy(a);
            var f = p * l - s * d;
            if (f <= 0 && l >= 0 && d <= 0)
                return i = l / (l - d),
                e.copy(r).addScaledVector(Kn, i);
            var m = c * d - p * h;
            if (m <= 0 && h - c >= 0 && p - d >= 0)
                return Qn.subVectors(a, o),
                i = (h - c) / (h - c + (p - d)),
                e.copy(o).addScaledVector(Qn, i);
            var g = 1 / (m + f + u);
            return n = f * g,
            i = u * g,
            e.copy(r).addScaledVector(Zn, n).addScaledVector(Kn, i)
        },
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    });
    var ii = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , ri = {
        h: 0,
        s: 0,
        l: 0
    }
      , oi = {
        h: 0,
        s: 0,
        l: 0
    };
    function ai(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }
    function si(t, e, n) {
        return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }
    function li(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }
    function ci(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    function hi(t, e, n, i, r, o) {
        this.a = t,
        this.b = e,
        this.c = n,
        this.normal = i && i.isVector3 ? i : new Oe,
        this.vertexNormals = Array.isArray(i) ? i : [],
        this.color = r && r.isColor ? r : new ai,
        this.vertexColors = Array.isArray(r) ? r : [],
        this.materialIndex = void 0 !== o ? o : 0
    }
    Object.assign(ai.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : 'number' == typeof t ? this.setHex(t) : 'string' == typeof t && this.setStyle(t),
            this
        },
        setScalar: function(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        },
        setHex: function(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        },
        setRGB: function(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        },
        setHSL: function(t, e, n) {
            if (t = Ee.euclideanModulo(t, 1),
            e = Ee.clamp(e, 0, 1),
            n = Ee.clamp(n, 0, 1),
            0 === e)
                this.r = this.g = this.b = n;
            else {
                var i = n <= .5 ? n * (1 + e) : n + e - n * e
                  , r = 2 * n - i;
                this.r = si(r, i, t + 1 / 3),
                this.g = si(r, i, t),
                this.b = si(r, i, t - 1 / 3)
            }
            return this
        },
        setStyle: function(t) {
            function e(t) {
                void 0 !== t && parseFloat(t)
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var i, r = n[1], o = n[2];
                switch (r) {
                case 'rgb':
                case 'rgba':
                    if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                        e(i[5]),
                        this;
                    if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                        e(i[5]),
                        this;
                    break;
                case 'hsl':
                case 'hsla':
                    if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                        var a = parseFloat(i[1]) / 360
                          , s = parseInt(i[2], 10) / 100
                          , l = parseInt(i[3], 10) / 100;
                        return e(i[5]),
                        this.setHSL(a, s, l)
                    }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var c = n[1]
                  , h = c.length;
                if (3 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                    this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                    this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                    this;
                if (6 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                    this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                    this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                    this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        },
        setColorName: function(t) {
            var e = ii[t];
            return void 0 !== e && this.setHex(e),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2),
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n),
            this.g = Math.pow(t.g, n),
            this.b = Math.pow(t.b, n),
            this
        },
        convertGammaToLinear: function(t) {
            return this.copyGammaToLinear(this, t),
            this
        },
        convertLinearToGamma: function(t) {
            return this.copyLinearToGamma(this, t),
            this
        },
        copySRGBToLinear: function(t) {
            return this.r = li(t.r),
            this.g = li(t.g),
            this.b = li(t.b),
            this
        },
        copyLinearToSRGB: function(t) {
            return this.r = ci(t.r),
            this.g = ci(t.g),
            this.b = ci(t.b),
            this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ('000000' + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, n, i = this.r, r = this.g, o = this.b, a = Math.max(i, r, o), s = Math.min(i, r, o), l = (s + a) / 2;
            if (s === a)
                e = 0,
                n = 0;
            else {
                var c = a - s;
                switch (n = l <= .5 ? c / (a + s) : c / (2 - a - s),
                a) {
                case i:
                    e = (r - o) / c + (r < o ? 6 : 0);
                    break;
                case r:
                    e = (o - i) / c + 2;
                    break;
                case o:
                    e = (i - r) / c + 4
                }
                e /= 6
            }
            return t.h = e,
            t.s = n,
            t.l = l,
            t
        },
        getStyle: function() {
            return 'rgb(' + (255 * this.r | 0) + ',' + (255 * this.g | 0) + ',' + (255 * this.b | 0) + ')'
        },
        offsetHSL: function(t, e, n) {
            return this.getHSL(ri),
            ri.h += t,
            ri.s += e,
            ri.l += n,
            this.setHSL(ri.h, ri.s, ri.l),
            this
        },
        add: function(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        },
        addScalar: function(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        },
        multiply: function(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        },
        multiplyScalar: function(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        },
        lerpHSL: function(t, e) {
            this.getHSL(ri),
            t.getHSL(oi);
            var n = Ee.lerp(ri.h, oi.h, e)
              , i = Ee.lerp(ri.s, oi.s, e)
              , r = Ee.lerp(ri.l, oi.l, e);
            return this.setHSL(n, i, r),
            this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        },
        toJSON: function() {
            return this.getHex()
        }
    }),
    ai.NAMES = ii,
    Object.assign(hi.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++)
                this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0,
            n = t.vertexColors.length; e < n; e++)
                this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var ui = 0;
    function pi() {
        Object.defineProperty(this, 'id', {
            value: ui++
        }),
        this.uuid = Ee.generateUUID(),
        this.name = '',
        this.type = 'Material',
        this.fog = !0,
        this.blending = g,
        this.side = c,
        this.flatShading = !1,
        this.vertexTangents = !1,
        this.vertexColors = p,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = L,
        this.blendDst = D,
        this.blendEquation = _,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = U,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = we,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Me,
        this.stencilZFail = Me,
        this.stencilZPass = Me,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0
    }
    function di(t) {
        pi.call(this),
        this.type = 'MeshBasicMaterial',
        this.color = new ai(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = W,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = 'round',
        this.wireframeLinejoin = 'round',
        this.skinning = !1,
        this.morphTargets = !1,
        this.setValues(t)
    }
    function fi(t, e, n) {
        if (Array.isArray(t))
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        this.name = '',
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === n,
        this.usage = Se,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function mi(t, e, n) {
        fi.call(this, new Int8Array(t), e, n)
    }
    function gi(t, e, n) {
        fi.call(this, new Uint8Array(t), e, n)
    }
    function vi(t, e, n) {
        fi.call(this, new Uint8ClampedArray(t), e, n)
    }
    function yi(t, e, n) {
        fi.call(this, new Int16Array(t), e, n)
    }
    function xi(t, e, n) {
        fi.call(this, new Uint16Array(t), e, n)
    }
    function bi(t, e, n) {
        fi.call(this, new Int32Array(t), e, n)
    }
    function _i(t, e, n) {
        fi.call(this, new Uint32Array(t), e, n)
    }
    function Mi(t, e, n) {
        fi.call(this, new Float32Array(t), e, n)
    }
    function wi(t, e, n) {
        fi.call(this, new Float64Array(t), e, n)
    }
    function Si() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function Pi(t) {
        if (0 === t.length)
            return -1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
    pi.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: pi,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                        if ('shading' !== e) {
                            var i = this[e];
                            void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n)
                        } else
                            this.flatShading = 1 === n
                }
        },
        toJSON: function(t) {
            var e = void 0 === t || 'string' == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            function i(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            '' !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
            n.reflectivity = this.reflectivity,
            n.refractionRatio = this.refractionRatio,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== g && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            this.side !== c && (n.side = this.side),
            this.vertexColors !== p && (n.vertexColors = this.vertexColors),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
            e) {
                var r = i(t.textures)
                  , o = i(t.images);
                r.length > 0 && (n.textures = r),
                o.length > 0 && (n.images = o)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.blending = t.blending,
            this.side = t.side,
            this.flatShading = t.flatShading,
            this.vertexTangents = t.vertexTangents,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.stencilWriteMask = t.stencilWriteMask,
            this.stencilFunc = t.stencilFunc,
            this.stencilRef = t.stencilRef,
            this.stencilFuncMask = t.stencilFuncMask,
            this.stencilFail = t.stencilFail,
            this.stencilZFail = t.stencilZFail,
            this.stencilZPass = t.stencilZPass,
            this.stencilWrite = t.stencilWrite;
            var e = t.clippingPlanes
              , n = null;
            if (null !== e) {
                var i = e.length;
                n = new Array(i);
                for (var r = 0; r !== i; ++r)
                    n[r] = e[r].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = t.clipIntersection,
            this.clipShadows = t.clipShadows,
            this.shadowSide = t.shadowSide,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.visible = t.visible,
            this.toneMapped = t.toneMapped,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        }
    }),
    Object.defineProperty(pi.prototype, 'needsUpdate', {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    di.prototype = Object.create(pi.prototype),
    di.prototype.constructor = di,
    di.prototype.isMeshBasicMaterial = !0,
    di.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
    ,
    Object.defineProperty(fi.prototype, 'needsUpdate', {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(fi.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t,
            this
        },
        copy: function(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.usage = t.usage,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (var i = 0, r = this.itemSize; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (o = new ai),
                e[n++] = o.r,
                e[n++] = o.g,
                e[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (o = new Te),
                e[n++] = o.x,
                e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (o = new Oe),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                void 0 === o && (o = new Ue),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z,
                e[n++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this.array[t + 3] = r,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }),
    mi.prototype = Object.create(fi.prototype),
    mi.prototype.constructor = mi,
    gi.prototype = Object.create(fi.prototype),
    gi.prototype.constructor = gi,
    vi.prototype = Object.create(fi.prototype),
    vi.prototype.constructor = vi,
    yi.prototype = Object.create(fi.prototype),
    yi.prototype.constructor = yi,
    xi.prototype = Object.create(fi.prototype),
    xi.prototype.constructor = xi,
    bi.prototype = Object.create(fi.prototype),
    bi.prototype.constructor = bi,
    _i.prototype = Object.create(fi.prototype),
    _i.prototype.constructor = _i,
    Mi.prototype = Object.create(fi.prototype),
    Mi.prototype.constructor = Mi,
    wi.prototype = Object.create(fi.prototype),
    wi.prototype.constructor = wi,
    Object.assign(Si.prototype, {
        computeGroups: function(t) {
            for (var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
                var a = r[o];
                a.materialIndex !== i && (i = a.materialIndex,
                void 0 !== e && (e.count = 3 * o - e.start,
                n.push(e)),
                e = {
                    start: 3 * o,
                    materialIndex: i
                })
            }
            void 0 !== e && (e.count = 3 * o - e.start,
            n.push(e)),
            this.groups = n
        },
        fromGeometry: function(t) {
            var e, n = t.faces, i = t.vertices, r = t.faceVertexUvs, o = r[0] && r[0].length > 0, a = r[1] && r[1].length > 0, s = t.morphTargets, l = s.length;
            if (l > 0) {
                e = [];
                for (var c = 0; c < l; c++)
                    e[c] = {
                        name: s[c].name,
                        data: []
                    };
                this.morphTargets.position = e
            }
            var h, u = t.morphNormals, p = u.length;
            if (p > 0) {
                h = [];
                for (c = 0; c < p; c++)
                    h[c] = {
                        name: u[c].name,
                        data: []
                    };
                this.morphTargets.normal = h
            }
            var d = t.skinIndices
              , f = t.skinWeights
              , m = d.length === i.length
              , g = f.length === i.length;
            i.length > 0 && n.length;
            for (c = 0; c < n.length; c++) {
                var v = n[c];
                this.vertices.push(i[v.a], i[v.b], i[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length)
                    this.normals.push(y[0], y[1], y[2]);
                else {
                    var x = v.normal;
                    this.normals.push(x, x, x)
                }
                var b, _ = v.vertexColors;
                if (3 === _.length)
                    this.colors.push(_[0], _[1], _[2]);
                else {
                    var M = v.color;
                    this.colors.push(M, M, M)
                }
                if (!0 === o)
                    void 0 !== (b = r[0][c]) ? this.uvs.push(b[0], b[1], b[2]) : this.uvs.push(new Te, new Te, new Te);
                if (!0 === a)
                    void 0 !== (b = r[1][c]) ? this.uvs2.push(b[0], b[1], b[2]) : this.uvs2.push(new Te, new Te, new Te);
                for (var w = 0; w < l; w++) {
                    var S = s[w].vertices;
                    e[w].data.push(S[v.a], S[v.b], S[v.c])
                }
                for (w = 0; w < p; w++) {
                    var P = u[w].vertexNormals[c];
                    h[w].data.push(P.a, P.b, P.c)
                }
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(t),
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        }
    });
    var Ci = 1
      , Ai = new Ze
      , Ei = new mn
      , Ti = new Oe
      , Li = new Ln
      , Di = new Ln
      , Ii = new Oe;
    function Oi() {
        Object.defineProperty(this, 'id', {
            value: Ci += 2
        }),
        this.uuid = Ee.generateUUID(),
        this.name = '',
        this.type = 'BufferGeometry',
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    Oi.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: Oi,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new (Pi(t) > 65535 ? _i : xi)(t,1) : this.index = t
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        setAttribute: function(t, e) {
            return this.attributes[t] = e,
            this
        },
        deleteAttribute: function(t) {
            return delete this.attributes[t],
            this
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e),
            e.needsUpdate = !0);
            var n = this.attributes.normal;
            void 0 !== n && ((new ke).getNormalMatrix(t).applyToBufferAttribute(n),
            n.needsUpdate = !0);
            var i = this.attributes.tangent;
            void 0 !== i && ((new ke).getNormalMatrix(t).applyToBufferAttribute(i),
            i.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function(t) {
            return Ai.makeRotationX(t),
            this.applyMatrix(Ai),
            this
        },
        rotateY: function(t) {
            return Ai.makeRotationY(t),
            this.applyMatrix(Ai),
            this
        },
        rotateZ: function(t) {
            return Ai.makeRotationZ(t),
            this.applyMatrix(Ai),
            this
        },
        translate: function(t, e, n) {
            return Ai.makeTranslation(t, e, n),
            this.applyMatrix(Ai),
            this
        },
        scale: function(t, e, n) {
            return Ai.makeScale(t, e, n),
            this.applyMatrix(Ai),
            this
        },
        lookAt: function(t) {
            return Ei.lookAt(t),
            Ei.updateMatrix(),
            this.applyMatrix(Ei.matrix),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Ti).negate(),
            this.translate(Ti.x, Ti.y, Ti.z),
            this
        },
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var n = new Mi(3 * e.vertices.length,3)
                  , i = new Mi(3 * e.colors.length,3);
                if (this.setAttribute('position', n.copyVector3sArray(e.vertices)),
                this.setAttribute('color', i.copyColorsArray(e.colors)),
                e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var r = new Mi(e.lineDistances.length,1);
                    this.setAttribute('lineDistance', r.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else
                t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.setAttribute('position', new Mi(e,3)),
            this
        },
        updateFromObject: function(t) {
            var e, n = t.geometry;
            if (t.isMesh) {
                var i = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (i = void 0,
                n.elementsNeedUpdate = !1),
                void 0 === i)
                    return this.fromGeometry(n);
                i.verticesNeedUpdate = n.verticesNeedUpdate,
                i.normalsNeedUpdate = n.normalsNeedUpdate,
                i.colorsNeedUpdate = n.colorsNeedUpdate,
                i.uvsNeedUpdate = n.uvsNeedUpdate,
                i.groupsNeedUpdate = n.groupsNeedUpdate,
                n.verticesNeedUpdate = !1,
                n.normalsNeedUpdate = !1,
                n.colorsNeedUpdate = !1,
                n.uvsNeedUpdate = !1,
                n.groupsNeedUpdate = !1,
                n = i
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices),
            e.needsUpdate = !0),
            n.verticesNeedUpdate = !1),
            !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals),
            e.needsUpdate = !0),
            n.normalsNeedUpdate = !1),
            !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors),
            e.needsUpdate = !0),
            n.colorsNeedUpdate = !1),
            n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs),
            e.needsUpdate = !0),
            n.uvsNeedUpdate = !1),
            n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances),
            e.needsUpdate = !0),
            n.lineDistancesNeedUpdate = !1),
            n.groupsNeedUpdate && (n.computeGroups(t.geometry),
            this.groups = n.groups,
            n.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new Si).fromGeometry(t),
            this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.setAttribute('position', new fi(e,3).copyVector3sArray(t.vertices)),
            t.normals.length > 0) {
                var n = new Float32Array(3 * t.normals.length);
                this.setAttribute('normal', new fi(n,3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var i = new Float32Array(3 * t.colors.length);
                this.setAttribute('color', new fi(i,3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var r = new Float32Array(2 * t.uvs.length);
                this.setAttribute('uv', new fi(r,2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var o = new Float32Array(2 * t.uvs2.length);
                this.setAttribute('uv2', new fi(o,2).copyVector2sArray(t.uvs2))
            }
            for (var a in this.groups = t.groups,
            t.morphTargets) {
                for (var s = [], l = t.morphTargets[a], c = 0, h = l.length; c < h; c++) {
                    var u = l[c]
                      , p = new Mi(3 * u.data.length,3);
                    p.name = u.name,
                    s.push(p.copyVector3sArray(u.data))
                }
                this.morphAttributes[a] = s
            }
            if (t.skinIndices.length > 0) {
                var d = new Mi(4 * t.skinIndices.length,4);
                this.setAttribute('skinIndex', d.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var f = new Mi(4 * t.skinWeights.length,4);
                this.setAttribute('skinWeight', f.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ln);
            var t = this.attributes.position
              , e = this.morphAttributes.position;
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t),
                e)
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        Li.setFromBufferAttribute(r),
                        this.morphTargetsRelative ? (Ii.addVectors(this.boundingBox.min, Li.min),
                        this.boundingBox.expandByPoint(Ii),
                        Ii.addVectors(this.boundingBox.max, Li.max),
                        this.boundingBox.expandByPoint(Ii)) : (this.boundingBox.expandByPoint(Li.min),
                        this.boundingBox.expandByPoint(Li.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new On);
            var t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t) {
                var n = this.boundingSphere.center;
                if (Li.setFromBufferAttribute(t),
                e)
                    for (var i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        Di.setFromBufferAttribute(o),
                        this.morphTargetsRelative ? (Ii.addVectors(Li.min, Di.min),
                        Li.expandByPoint(Ii),
                        Ii.addVectors(Li.max, Di.max),
                        Li.expandByPoint(Ii)) : (Li.expandByPoint(Di.min),
                        Li.expandByPoint(Di.max))
                    }
                Li.getCenter(n);
                var a = 0;
                for (i = 0,
                r = t.count; i < r; i++)
                    Ii.fromBufferAttribute(t, i),
                    a = Math.max(a, n.distanceToSquared(Ii));
                if (e)
                    for (i = 0,
                    r = e.length; i < r; i++) {
                        o = e[i];
                        for (var s = this.morphTargetsRelative, l = 0, c = o.count; l < c; l++)
                            Ii.fromBufferAttribute(o, l),
                            s && (Ti.fromBufferAttribute(t, l),
                            Ii.add(Ti)),
                            a = Math.max(a, n.distanceToSquared(Ii))
                    }
                this.boundingSphere.radius = Math.sqrt(a),
                isNaN(this.boundingSphere.radius)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index
              , e = this.attributes;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal)
                    this.setAttribute('normal', new fi(new Float32Array(n.length),3));
                else
                    for (var i = e.normal.array, r = 0, o = i.length; r < o; r++)
                        i[r] = 0;
                var a, s, l, c = e.normal.array, h = new Oe, u = new Oe, p = new Oe, d = new Oe, f = new Oe;
                if (t) {
                    var m = t.array;
                    for (r = 0,
                    o = t.count; r < o; r += 3)
                        a = 3 * m[r + 0],
                        s = 3 * m[r + 1],
                        l = 3 * m[r + 2],
                        h.fromArray(n, a),
                        u.fromArray(n, s),
                        p.fromArray(n, l),
                        d.subVectors(p, u),
                        f.subVectors(h, u),
                        d.cross(f),
                        c[a] += d.x,
                        c[a + 1] += d.y,
                        c[a + 2] += d.z,
                        c[s] += d.x,
                        c[s + 1] += d.y,
                        c[s + 2] += d.z,
                        c[l] += d.x,
                        c[l + 1] += d.y,
                        c[l + 2] += d.z
                } else
                    for (r = 0,
                    o = n.length; r < o; r += 9)
                        h.fromArray(n, r),
                        u.fromArray(n, r + 3),
                        p.fromArray(n, r + 6),
                        d.subVectors(p, u),
                        f.subVectors(h, u),
                        d.cross(f),
                        c[r] = d.x,
                        c[r + 1] = d.y,
                        c[r + 2] = d.z,
                        c[r + 3] = d.x,
                        c[r + 4] = d.y,
                        c[r + 5] = d.z,
                        c[r + 6] = d.x,
                        c[r + 7] = d.y,
                        c[r + 8] = d.z;
                this.normalizeNormals(),
                e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0);
                var n = this.attributes;
                for (var i in n)
                    if (void 0 !== t.attributes[i])
                        for (var r = n[i].array, o = t.attributes[i], a = o.array, s = o.itemSize * e, l = Math.min(a.length, r.length - s), c = 0, h = s; c < l; c++,
                        h++)
                            r[h] = a[c];
                return this
            }
        },
        normalizeNormals: function() {
            for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
                Ii.x = t.getX(e),
                Ii.y = t.getY(e),
                Ii.z = t.getZ(e),
                Ii.normalize(),
                t.setXYZ(e, Ii.x, Ii.y, Ii.z)
        },
        toNonIndexed: function() {
            function t(t, e) {
                for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), o = 0, a = 0, s = 0, l = e.length; s < l; s++) {
                    o = e[s] * i;
                    for (var c = 0; c < i; c++)
                        r[a++] = n[o++]
                }
                return new fi(r,i)
            }
            if (null === this.index)
                return this;
            var e = new Oi
              , n = this.index.array
              , i = this.attributes;
            for (var r in i) {
                var o = t(i[r], n);
                e.setAttribute(r, o)
            }
            var a = this.morphAttributes;
            for (r in a) {
                for (var s = [], l = a[r], c = 0, h = l.length; c < h; c++) {
                    o = t(l[c], n);
                    s.push(o)
                }
                e.morphAttributes[r] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            for (var u = this.groups, p = (c = 0,
            u.length); c < p; c++) {
                var d = u[c];
                e.addGroup(d.start, d.count, d.materialIndex)
            }
            return e
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            '' !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 && (t.userData = this.userData),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (t.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var r = this.attributes;
            for (var n in r) {
                var o = (p = r[n]).toJSON();
                '' !== p.name && (o.name = p.name),
                t.data.attributes[n] = o
            }
            var a = {}
              , s = !1;
            for (var n in this.morphAttributes) {
                for (var l = this.morphAttributes[n], c = [], h = 0, u = l.length; h < u; h++) {
                    var p;
                    o = (p = l[h]).toJSON();
                    '' !== p.name && (o.name = p.name),
                    c.push(o)
                }
                c.length > 0 && (a[n] = c,
                s = !0)
            }
            s && (t.data.morphAttributes = a,
            t.data.morphTargetsRelative = this.morphTargetsRelative);
            var d = this.groups;
            d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d)));
            var f = this.boundingSphere;
            return null !== f && (t.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }),
            t
        },
        clone: function() {
            return (new Oi).copy(this)
        },
        copy: function(t) {
            var e, n, i;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = t.name;
            var r = t.index;
            null !== r && this.setIndex(r.clone());
            var o = t.attributes;
            for (e in o) {
                var a = o[e];
                this.setAttribute(e, a.clone())
            }
            var s = t.morphAttributes;
            for (e in s) {
                var l = []
                  , c = s[e];
                for (n = 0,
                i = c.length; n < i; n++)
                    l.push(c[n].clone());
                this.morphAttributes[e] = l
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            var h = t.groups;
            for (n = 0,
            i = h.length; n < i; n++) {
                var u = h[n];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = t.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = t.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this.userData = t.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        }
    });
    var ji = new Ze
      , Ni = new Bn
      , ki = new On
      , Fi = new Oe
      , zi = new Oe
      , Ri = new Oe
      , Ui = new Oe
      , Bi = new Oe
      , Vi = new Oe
      , Gi = new Oe
      , Hi = new Oe
      , Wi = new Oe
      , Xi = new Te
      , qi = new Te
      , Yi = new Te
      , Ji = new Oe
      , Zi = new Oe;
    function Ki(t, e) {
        mn.call(this),
        this.type = 'Mesh',
        this.geometry = void 0 !== t ? t : new Oi,
        this.material = void 0 !== e ? e : new di({
            color: 16777215 * Math.random()
        }),
        this.drawMode = se,
        this.updateMorphTargets()
    }
    function Qi(t, e, n, i, r, o, a, s) {
        if (null === (e.side === h ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, e.side !== u, s)))
            return null;
        Zi.copy(s),
        Zi.applyMatrix4(t.matrixWorld);
        var l = n.ray.origin.distanceTo(Zi);
        return l < n.near || l > n.far ? null : {
            distance: l,
            point: Zi.clone(),
            object: t
        }
    }
    function $i(t, e, n, i, r, o, a, s, l, c, h, u) {
        Fi.fromBufferAttribute(r, c),
        zi.fromBufferAttribute(r, h),
        Ri.fromBufferAttribute(r, u);
        var p = t.morphTargetInfluences;
        if (e.morphTargets && o && p) {
            Gi.set(0, 0, 0),
            Hi.set(0, 0, 0),
            Wi.set(0, 0, 0);
            for (var d = 0, f = o.length; d < f; d++) {
                var m = p[d]
                  , g = o[d];
                0 !== m && (Ui.fromBufferAttribute(g, c),
                Bi.fromBufferAttribute(g, h),
                Vi.fromBufferAttribute(g, u),
                a ? (Gi.addScaledVector(Ui, m),
                Hi.addScaledVector(Bi, m),
                Wi.addScaledVector(Vi, m)) : (Gi.addScaledVector(Ui.sub(Fi), m),
                Hi.addScaledVector(Bi.sub(zi), m),
                Wi.addScaledVector(Vi.sub(Ri), m)))
            }
            Fi.add(Gi),
            zi.add(Hi),
            Ri.add(Wi)
        }
        var v = Qi(t, e, n, i, Fi, zi, Ri, Ji);
        if (v) {
            s && (Xi.fromBufferAttribute(s, c),
            qi.fromBufferAttribute(s, h),
            Yi.fromBufferAttribute(s, u),
            v.uv = ni.getUV(Ji, Fi, zi, Ri, Xi, qi, Yi, new Te)),
            l && (Xi.fromBufferAttribute(l, c),
            qi.fromBufferAttribute(l, h),
            Yi.fromBufferAttribute(l, u),
            v.uv2 = ni.getUV(Ji, Fi, zi, Ri, Xi, qi, Yi, new Te));
            var y = new hi(c,h,u);
            ni.getNormal(Fi, zi, Ri, y.normal),
            v.face = y
        }
        return v
    }
    Ki.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Ki,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return mn.prototype.copy.call(this, t),
            this.drawMode = t.drawMode,
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes
                  , o = Object.keys(r);
                if (o.length > 0) {
                    var a = r[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        t = 0,
                        e = a.length; t < e; t++)
                            n = a[t].name || String(t),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length
            }
        },
        raycast: function(t, e) {
            var n, i = this.geometry, r = this.material, o = this.matrixWorld;
            if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(),
            ki.copy(i.boundingSphere),
            ki.applyMatrix4(o),
            !1 !== t.ray.intersectsSphere(ki) && (ji.getInverse(o),
            Ni.copy(t.ray).applyMatrix4(ji),
            (null === i.boundingBox || !1 !== Ni.intersectsBox(i.boundingBox)) && this.drawMode === se)))
                if (i.isBufferGeometry) {
                    var a, s, l, c, h, u, p, d, f, m = i.index, g = i.attributes.position, v = i.morphAttributes.position, y = i.morphTargetsRelative, x = i.attributes.uv, b = i.attributes.uv2, _ = i.groups, M = i.drawRange;
                    if (null !== m)
                        if (Array.isArray(r))
                            for (c = 0,
                            u = _.length; c < u; c++)
                                for (f = r[(d = _[c]).materialIndex],
                                h = Math.max(d.start, M.start),
                                p = Math.min(d.start + d.count, M.start + M.count); h < p; h += 3)
                                    a = m.getX(h),
                                    s = m.getX(h + 1),
                                    l = m.getX(h + 2),
                                    (n = $i(this, f, t, Ni, g, v, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(h / 3),
                                    n.face.materialIndex = d.materialIndex,
                                    e.push(n));
                        else
                            for (c = Math.max(0, M.start),
                            u = Math.min(m.count, M.start + M.count); c < u; c += 3)
                                a = m.getX(c),
                                s = m.getX(c + 1),
                                l = m.getX(c + 2),
                                (n = $i(this, r, t, Ni, g, v, y, x, b, a, s, l)) && (n.faceIndex = Math.floor(c / 3),
                                e.push(n));
                    else if (void 0 !== g)
                        if (Array.isArray(r))
                            for (c = 0,
                            u = _.length; c < u; c++)
                                for (f = r[(d = _[c]).materialIndex],
                                h = Math.max(d.start, M.start),
                                p = Math.min(d.start + d.count, M.start + M.count); h < p; h += 3)
                                    (n = $i(this, f, t, Ni, g, v, y, x, b, a = h, s = h + 1, l = h + 2)) && (n.faceIndex = Math.floor(h / 3),
                                    n.face.materialIndex = d.materialIndex,
                                    e.push(n));
                        else
                            for (c = Math.max(0, M.start),
                            u = Math.min(g.count, M.start + M.count); c < u; c += 3)
                                (n = $i(this, r, t, Ni, g, v, y, x, b, a = c, s = c + 1, l = c + 2)) && (n.faceIndex = Math.floor(c / 3),
                                e.push(n))
                } else if (i.isGeometry) {
                    var w, S, P, C, A = Array.isArray(r), E = i.vertices, T = i.faces, L = i.faceVertexUvs[0];
                    L.length > 0 && (C = L);
                    for (var D = 0, I = T.length; D < I; D++) {
                        var O = T[D]
                          , j = A ? r[O.materialIndex] : r;
                        if (void 0 !== j && (w = E[O.a],
                        S = E[O.b],
                        P = E[O.c],
                        n = Qi(this, j, t, Ni, w, S, P, Ji))) {
                            if (C && C[D]) {
                                var N = C[D];
                                Xi.copy(N[0]),
                                qi.copy(N[1]),
                                Yi.copy(N[2]),
                                n.uv = ni.getUV(Ji, w, S, P, Xi, qi, Yi, new Te)
                            }
                            n.face = O,
                            n.faceIndex = D,
                            e.push(n)
                        }
                    }
                }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var tr = 0
      , er = new Ze
      , nr = new mn
      , ir = new Oe;
    function rr() {
        Object.defineProperty(this, 'id', {
            value: tr += 2
        }),
        this.uuid = Ee.generateUUID(),
        this.name = '',
        this.type = 'Geometry',
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    rr.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: rr,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new ke).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                this.vertices[n].applyMatrix4(t)
            }
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                var r = this.faces[n];
                r.normal.applyMatrix3(e).normalize();
                for (var o = 0, a = r.vertexNormals.length; o < a; o++)
                    r.vertexNormals[o].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function(t) {
            return er.makeRotationX(t),
            this.applyMatrix(er),
            this
        },
        rotateY: function(t) {
            return er.makeRotationY(t),
            this.applyMatrix(er),
            this
        },
        rotateZ: function(t) {
            return er.makeRotationZ(t),
            this.applyMatrix(er),
            this
        },
        translate: function(t, e, n) {
            return er.makeTranslation(t, e, n),
            this.applyMatrix(er),
            this
        },
        scale: function(t, e, n) {
            return er.makeScale(t, e, n),
            this.applyMatrix(er),
            this
        },
        lookAt: function(t) {
            return nr.lookAt(t),
            nr.updateMatrix(),
            this.applyMatrix(nr.matrix),
            this
        },
        fromBufferGeometry: function(t) {
            var e = this
              , n = null !== t.index ? t.index.array : void 0
              , i = t.attributes;
            if (void 0 === i.position)
                return this;
            var r = i.position.array
              , o = void 0 !== i.normal ? i.normal.array : void 0
              , a = void 0 !== i.color ? i.color.array : void 0
              , s = void 0 !== i.uv ? i.uv.array : void 0
              , l = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var c = 0; c < r.length; c += 3)
                e.vertices.push((new Oe).fromArray(r, c)),
                void 0 !== a && e.colors.push((new ai).fromArray(a, c));
            function h(t, n, i, r) {
                var c = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()]
                  , h = new hi(t,n,i,void 0 === o ? [] : [(new Oe).fromArray(o, 3 * t), (new Oe).fromArray(o, 3 * n), (new Oe).fromArray(o, 3 * i)],c,r);
                e.faces.push(h),
                void 0 !== s && e.faceVertexUvs[0].push([(new Te).fromArray(s, 2 * t), (new Te).fromArray(s, 2 * n), (new Te).fromArray(s, 2 * i)]),
                void 0 !== l && e.faceVertexUvs[1].push([(new Te).fromArray(l, 2 * t), (new Te).fromArray(l, 2 * n), (new Te).fromArray(l, 2 * i)])
            }
            var u = t.groups;
            if (u.length > 0)
                for (c = 0; c < u.length; c++)
                    for (var p = u[c], d = p.start, f = d, m = d + p.count; f < m; f += 3)
                        void 0 !== n ? h(n[f], n[f + 1], n[f + 2], p.materialIndex) : h(f, f + 1, f + 2, p.materialIndex);
            else if (void 0 !== n)
                for (c = 0; c < n.length; c += 3)
                    h(n[c], n[c + 1], n[c + 2]);
            else
                for (c = 0; c < r.length / 3; c += 3)
                    h(c, c + 1, c + 2);
            return this.computeFaceNormals(),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(ir).negate(),
            this.translate(ir.x, ir.y, ir.z),
            this
        },
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center
              , e = this.boundingSphere.radius
              , n = 0 === e ? 1 : 1 / e
              , i = new Ze;
            return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1),
            this.applyMatrix(i),
            this
        },
        computeFaceNormals: function() {
            for (var t = new Oe, e = new Oe, n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n]
                  , o = this.vertices[r.a]
                  , a = this.vertices[r.b]
                  , s = this.vertices[r.c];
                t.subVectors(s, a),
                e.subVectors(o, a),
                t.cross(e),
                t.normalize(),
                r.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, n, i, r, o, a;
            for (void 0 === t && (t = !0),
            a = new Array(this.vertices.length),
            e = 0,
            n = this.vertices.length; e < n; e++)
                a[e] = new Oe;
            if (t) {
                var s, l, c, h = new Oe, u = new Oe;
                for (i = 0,
                r = this.faces.length; i < r; i++)
                    o = this.faces[i],
                    s = this.vertices[o.a],
                    l = this.vertices[o.b],
                    c = this.vertices[o.c],
                    h.subVectors(c, l),
                    u.subVectors(s, l),
                    h.cross(u),
                    a[o.a].add(h),
                    a[o.b].add(h),
                    a[o.c].add(h)
            } else
                for (this.computeFaceNormals(),
                i = 0,
                r = this.faces.length; i < r; i++)
                    a[(o = this.faces[i]).a].add(o.normal),
                    a[o.b].add(o.normal),
                    a[o.c].add(o.normal);
            for (e = 0,
            n = this.vertices.length; e < n; e++)
                a[e].normalize();
            for (i = 0,
            r = this.faces.length; i < r; i++) {
                var p = (o = this.faces[i]).vertexNormals;
                3 === p.length ? (p[0].copy(a[o.a]),
                p[1].copy(a[o.b]),
                p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(),
                p[1] = a[o.b].clone(),
                p[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t, e, n;
            for (this.computeFaceNormals(),
            t = 0,
            e = this.faces.length; t < e; t++) {
                var i = (n = this.faces[t]).vertexNormals;
                3 === i.length ? (i[0].copy(n.normal),
                i[1].copy(n.normal),
                i[2].copy(n.normal)) : (i[0] = n.normal.clone(),
                i[1] = n.normal.clone(),
                i[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, n, i, r;
            for (n = 0,
            i = this.faces.length; n < i; n++)
                for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
                r.__originalVertexNormals || (r.__originalVertexNormals = []),
                t = 0,
                e = r.vertexNormals.length; t < e; t++)
                    r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
            var o = new rr;
            for (o.faces = this.faces,
            t = 0,
            e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {},
                    this.morphNormals[t].faceNormals = [],
                    this.morphNormals[t].vertexNormals = [];
                    var a = this.morphNormals[t].faceNormals
                      , s = this.morphNormals[t].vertexNormals;
                    for (n = 0,
                    i = this.faces.length; n < i; n++)
                        l = new Oe,
                        c = {
                            a: new Oe,
                            b: new Oe,
                            c: new Oe
                        },
                        a.push(l),
                        s.push(c)
                }
                var l, c, h = this.morphNormals[t];
                for (o.vertices = this.morphTargets[t].vertices,
                o.computeFaceNormals(),
                o.computeVertexNormals(),
                n = 0,
                i = this.faces.length; n < i; n++)
                    r = this.faces[n],
                    l = h.faceNormals[n],
                    c = h.vertexNormals[n],
                    l.copy(r.normal),
                    c.a.copy(r.vertexNormals[0]),
                    c.b.copy(r.vertexNormals[1]),
                    c.c.copy(r.vertexNormals[2])
            }
            for (n = 0,
            i = this.faces.length; n < i; n++)
                (r = this.faces[n]).normal = r.__originalFaceNormal,
                r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ln),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new On),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (t && t.isGeometry) {
                var i, r = this.vertices.length, o = this.vertices, a = t.vertices, s = this.faces, l = t.faces, c = this.colors, h = t.colors;
                void 0 === n && (n = 0),
                void 0 !== e && (i = (new ke).getNormalMatrix(e));
                for (var u = 0, p = a.length; u < p; u++) {
                    var d = a[u].clone();
                    void 0 !== e && d.applyMatrix4(e),
                    o.push(d)
                }
                for (u = 0,
                p = h.length; u < p; u++)
                    c.push(h[u].clone());
                for (u = 0,
                p = l.length; u < p; u++) {
                    var f, m, g, v = l[u], y = v.vertexNormals, x = v.vertexColors;
                    (f = new hi(v.a + r,v.b + r,v.c + r)).normal.copy(v.normal),
                    void 0 !== i && f.normal.applyMatrix3(i).normalize();
                    for (var b = 0, _ = y.length; b < _; b++)
                        m = y[b].clone(),
                        void 0 !== i && m.applyMatrix3(i).normalize(),
                        f.vertexNormals.push(m);
                    f.color.copy(v.color);
                    for (b = 0,
                    _ = x.length; b < _; b++)
                        g = x[b],
                        f.vertexColors.push(g.clone());
                    f.materialIndex = v.materialIndex + n,
                    s.push(f)
                }
                for (u = 0,
                p = t.faceVertexUvs.length; u < p; u++) {
                    var M = t.faceVertexUvs[u];
                    void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                    for (b = 0,
                    _ = M.length; b < _; b++) {
                        for (var w = M[b], S = [], P = 0, C = w.length; P < C; P++)
                            S.push(w[P].clone());
                        this.faceVertexUvs[u].push(S)
                    }
                }
            }
        },
        mergeMesh: function(t) {
            t && t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
        },
        mergeVertices: function() {
            var t, e, n, i, r, o, a, s, l = {}, c = [], h = [], u = Math.pow(10, 4);
            for (n = 0,
            i = this.vertices.length; n < i; n++)
                t = this.vertices[n],
                void 0 === l[e = Math.round(t.x * u) + '_' + Math.round(t.y * u) + '_' + Math.round(t.z * u)] ? (l[e] = n,
                c.push(this.vertices[n]),
                h[n] = c.length - 1) : h[n] = h[l[e]];
            var p = [];
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                (r = this.faces[n]).a = h[r.a],
                r.b = h[r.b],
                r.c = h[r.c],
                o = [r.a, r.b, r.c];
                for (var d = 0; d < 3; d++)
                    if (o[d] === o[(d + 1) % 3]) {
                        p.push(n);
                        break
                    }
            }
            for (n = p.length - 1; n >= 0; n--) {
                var f = p[n];
                for (this.faces.splice(f, 1),
                a = 0,
                s = this.faceVertexUvs.length; a < s; a++)
                    this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - c.length;
            return this.vertices = c,
            m
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var i = t[e];
                this.vertices.push(new Oe(i.x,i.y,i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++)
                t[n]._id = n;
            t.sort((function(t, e) {
                return t.materialIndex - e.materialIndex
            }
            ));
            var i, r, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            o && o.length === e && (i = []),
            a && a.length === e && (r = []);
            for (n = 0; n < e; n++) {
                var s = t[n]._id;
                i && i.push(o[s]),
                r && r.push(a[s])
            }
            i && (this.faceVertexUvs[0] = i),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            '' !== this.name && (t.name = this.name),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            for (var i = [], r = 0; r < this.vertices.length; r++) {
                var o = this.vertices[r];
                i.push(o.x, o.y, o.z)
            }
            var a = []
              , s = []
              , l = {}
              , c = []
              , h = {}
              , u = []
              , p = {};
            for (r = 0; r < this.faces.length; r++) {
                var d = this.faces[r]
                  , f = void 0 !== this.faceVertexUvs[0][r]
                  , m = d.normal.length() > 0
                  , g = d.vertexNormals.length > 0
                  , v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , x = 0;
                if (x = w(x, 0, 0),
                x = w(x, 1, !0),
                x = w(x, 2, !1),
                x = w(x, 3, f),
                x = w(x, 4, m),
                x = w(x, 5, g),
                x = w(x, 6, v),
                x = w(x, 7, y),
                a.push(x),
                a.push(d.a, d.b, d.c),
                a.push(d.materialIndex),
                f) {
                    var b = this.faceVertexUvs[0][r];
                    a.push(C(b[0]), C(b[1]), C(b[2]))
                }
                if (m && a.push(S(d.normal)),
                g) {
                    var _ = d.vertexNormals;
                    a.push(S(_[0]), S(_[1]), S(_[2]))
                }
                if (v && a.push(P(d.color)),
                y) {
                    var M = d.vertexColors;
                    a.push(P(M[0]), P(M[1]), P(M[2]))
                }
            }
            function w(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }
            function S(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== l[e] ? l[e] : (l[e] = s.length / 3,
                s.push(t.x, t.y, t.z),
                l[e])
            }
            function P(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== h[e] ? h[e] : (h[e] = c.length,
                c.push(t.getHex()),
                h[e])
            }
            function C(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2,
                u.push(t.x, t.y),
                p[e])
            }
            return t.data = {},
            t.data.vertices = i,
            t.data.normals = s,
            c.length > 0 && (t.data.colors = c),
            u.length > 0 && (t.data.uvs = [u]),
            t.data.faces = a,
            t
        },
        clone: function() {
            return (new rr).copy(this)
        },
        copy: function(t) {
            var e, n, i, r, o, a;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = t.name;
            var s = t.vertices;
            for (e = 0,
            n = s.length; e < n; e++)
                this.vertices.push(s[e].clone());
            var l = t.colors;
            for (e = 0,
            n = l.length; e < n; e++)
                this.colors.push(l[e].clone());
            var c = t.faces;
            for (e = 0,
            n = c.length; e < n; e++)
                this.faces.push(c[e].clone());
            for (e = 0,
            n = t.faceVertexUvs.length; e < n; e++) {
                var h = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
                i = 0,
                r = h.length; i < r; i++) {
                    var u = h[i]
                      , p = [];
                    for (o = 0,
                    a = u.length; o < a; o++) {
                        var d = u[o];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[e].push(p)
                }
            }
            var f = t.morphTargets;
            for (e = 0,
            n = f.length; e < n; e++) {
                var m = {};
                if (m.name = f[e].name,
                void 0 !== f[e].vertices)
                    for (m.vertices = [],
                    i = 0,
                    r = f[e].vertices.length; i < r; i++)
                        m.vertices.push(f[e].vertices[i].clone());
                if (void 0 !== f[e].normals)
                    for (m.normals = [],
                    i = 0,
                    r = f[e].normals.length; i < r; i++)
                        m.normals.push(f[e].normals[i].clone());
                this.morphTargets.push(m)
            }
            var g = t.morphNormals;
            for (e = 0,
            n = g.length; e < n; e++) {
                var v = {};
                if (void 0 !== g[e].vertexNormals)
                    for (v.vertexNormals = [],
                    i = 0,
                    r = g[e].vertexNormals.length; i < r; i++) {
                        var y = g[e].vertexNormals[i]
                          , x = {};
                        x.a = y.a.clone(),
                        x.b = y.b.clone(),
                        x.c = y.c.clone(),
                        v.vertexNormals.push(x)
                    }
                if (void 0 !== g[e].faceNormals)
                    for (v.faceNormals = [],
                    i = 0,
                    r = g[e].faceNormals.length; i < r; i++)
                        v.faceNormals.push(g[e].faceNormals[i].clone());
                this.morphNormals.push(v)
            }
            var b = t.skinWeights;
            for (e = 0,
            n = b.length; e < n; e++)
                this.skinWeights.push(b[e].clone());
            var _ = t.skinIndices;
            for (e = 0,
            n = _.length; e < n; e++)
                this.skinIndices.push(_[e].clone());
            var M = t.lineDistances;
            for (e = 0,
            n = M.length; e < n; e++)
                this.lineDistances.push(M[e]);
            var w = t.boundingBox;
            null !== w && (this.boundingBox = w.clone());
            var S = t.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()),
            this.elementsNeedUpdate = t.elementsNeedUpdate,
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            })
        }
    });
    class or extends rr {
        constructor(t, e, n, i, r, o) {
            super(),
            this.type = 'BoxGeometry',
            this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            },
            this.fromBufferGeometry(new ar(t,e,n,i,r,o)),
            this.mergeVertices()
        }
    }
    class ar extends Oi {
        constructor(t, e, n, i, r, o) {
            super(),
            this.type = 'BoxBufferGeometry',
            this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            };
            var a = this;
            t = t || 1,
            e = e || 1,
            n = n || 1,
            i = Math.floor(i) || 1,
            r = Math.floor(r) || 1,
            o = Math.floor(o) || 1;
            var s = []
              , l = []
              , c = []
              , h = []
              , u = 0
              , p = 0;
            function d(t, e, n, i, r, o, d, f, m, g, v) {
                var y, x, b = o / m, _ = d / g, M = o / 2, w = d / 2, S = f / 2, P = m + 1, C = g + 1, A = 0, E = 0, T = new Oe;
                for (x = 0; x < C; x++) {
                    var L = x * _ - w;
                    for (y = 0; y < P; y++) {
                        var D = y * b - M;
                        T[t] = D * i,
                        T[e] = L * r,
                        T[n] = S,
                        l.push(T.x, T.y, T.z),
                        T[t] = 0,
                        T[e] = 0,
                        T[n] = f > 0 ? 1 : -1,
                        c.push(T.x, T.y, T.z),
                        h.push(y / m),
                        h.push(1 - x / g),
                        A += 1
                    }
                }
                for (x = 0; x < g; x++)
                    for (y = 0; y < m; y++) {
                        var I = u + y + P * x
                          , O = u + y + P * (x + 1)
                          , j = u + (y + 1) + P * (x + 1)
                          , N = u + (y + 1) + P * x;
                        s.push(I, O, N),
                        s.push(O, j, N),
                        E += 6
                    }
                a.addGroup(p, E, v),
                p += E,
                u += A
            }
            d('z', 'y', 'x', -1, -1, n, e, t, o, r, 0),
            d('z', 'y', 'x', 1, -1, n, e, -t, o, r, 1),
            d('x', 'z', 'y', 1, 1, t, n, e, i, o, 2),
            d('x', 'z', 'y', 1, -1, t, n, -e, i, o, 3),
            d('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
            d('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
            this.setIndex(s),
            this.setAttribute('position', new Mi(l,3)),
            this.setAttribute('normal', new Mi(c,3)),
            this.setAttribute('uv', new Mi(h,2))
        }
    }
    function sr(t) {
        var e = {};
        for (var n in t)
            for (var i in e[n] = {},
            t[n]) {
                var r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        return e
    }
    function lr(t) {
        for (var e = {}, n = 0; n < t.length; n++) {
            var i = sr(t[n]);
            for (var r in i)
                e[r] = i[r]
        }
        return e
    }
    var cr = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'
      , hr = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
    function ur(t) {
        pi.call(this),
        this.type = 'ShaderMaterial',
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = cr,
        this.fragmentShader = hr,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== t && (t.attributes,
        this.setValues(t))
    }
    function pr() {
        mn.call(this),
        this.type = 'Camera',
        this.matrixWorldInverse = new Ze,
        this.projectionMatrix = new Ze,
        this.projectionMatrixInverse = new Ze
    }
    function dr(t, e, n, i) {
        pr.call(this),
        this.type = 'PerspectiveCamera',
        this.fov = void 0 !== t ? t : 50,
        this.zoom = 1,
        this.near = void 0 !== n ? n : .1,
        this.far = void 0 !== i ? i : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== e ? e : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    ur.prototype = Object.create(pi.prototype),
    ur.prototype.constructor = ur,
    ur.prototype.isShaderMaterial = !0,
    ur.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = sr(t.uniforms),
        this.defines = Object.assign({}, t.defines),
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = t.extensions,
        this
    }
    ,
    ur.prototype.toJSON = function(t) {
        var e = pi.prototype.toJSON.call(this, t);
        for (var n in e.uniforms = {},
        this.uniforms) {
            var i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: 't',
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: 'c',
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: 'v2',
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: 'v3',
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: 'v4',
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: 'm3',
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: 'm4',
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader;
        var r = {};
        for (var o in this.extensions)
            !0 === this.extensions[o] && (r[o] = !0);
        return Object.keys(r).length > 0 && (e.extensions = r),
        e
    }
    ,
    pr.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: pr,
        isCamera: !0,
        copy: function(t, e) {
            return mn.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(t) {
            void 0 === t && (t = new Oe),
            this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function(t) {
            mn.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    dr.prototype = Object.assign(Object.create(pr.prototype), {
        constructor: dr,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return pr.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * Ee.RAD2DEG * Math.atan(e),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * Ee.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * Ee.RAD2DEG * Math.atan(Math.tan(.5 * Ee.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, i, r, o) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near
              , e = t * Math.tan(.5 * Ee.DEG2RAD * this.fov) / this.zoom
              , n = 2 * e
              , i = this.aspect * n
              , r = -.5 * i
              , o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth
                  , s = o.fullHeight;
                r += o.offsetX * i / a,
                e -= o.offsetY * n / s,
                i *= o.width / a,
                n *= o.height / s
            }
            var l = this.filmOffset;
            0 !== l && (r += t * l / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            var e = mn.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    });
    var fr = 90
      , mr = 1;
    function gr(t, e, n, i) {
        mn.call(this),
        this.type = 'CubeCamera';
        var r = new dr(fr,mr,t,e);
        r.up.set(0, -1, 0),
        r.lookAt(new Oe(1,0,0)),
        this.add(r);
        var o = new dr(fr,mr,t,e);
        o.up.set(0, -1, 0),
        o.lookAt(new Oe(-1,0,0)),
        this.add(o);
        var a = new dr(fr,mr,t,e);
        a.up.set(0, 0, 1),
        a.lookAt(new Oe(0,1,0)),
        this.add(a);
        var s = new dr(fr,mr,t,e);
        s.up.set(0, 0, -1),
        s.lookAt(new Oe(0,-1,0)),
        this.add(s);
        var l = new dr(fr,mr,t,e);
        l.up.set(0, -1, 0),
        l.lookAt(new Oe(0,0,1)),
        this.add(l);
        var c = new dr(fr,mr,t,e);
        c.up.set(0, -1, 0),
        c.lookAt(new Oe(0,0,-1)),
        this.add(c),
        i = i || {
            format: Tt,
            magFilter: dt,
            minFilter: dt
        },
        this.renderTarget = new vr(n,n,i),
        this.renderTarget.texture.name = 'CubeCamera',
        this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = t.getRenderTarget()
              , i = this.renderTarget
              , h = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1,
            t.setRenderTarget(i, 0),
            t.render(e, r),
            t.setRenderTarget(i, 1),
            t.render(e, o),
            t.setRenderTarget(i, 2),
            t.render(e, a),
            t.setRenderTarget(i, 3),
            t.render(e, s),
            t.setRenderTarget(i, 4),
            t.render(e, l),
            i.texture.generateMipmaps = h,
            t.setRenderTarget(i, 5),
            t.render(e, c),
            t.setRenderTarget(n)
        }
        ,
        this.clear = function(t, e, n, i) {
            for (var r = t.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++)
                t.setRenderTarget(o, a),
                t.clear(e, n, i);
            t.setRenderTarget(r)
        }
    }
    function vr(t, e, n) {
        Be.call(this, t, e, n)
    }
    function yr(t, e, n, i, r, o, a, s, l, c, h, u) {
        Re.call(this, null, o, a, s, l, c, i, r, h, u),
        this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1
        },
        this.magFilter = void 0 !== l ? l : ht,
        this.minFilter = void 0 !== c ? c : ht,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.needsUpdate = !0
    }
    gr.prototype = Object.create(mn.prototype),
    gr.prototype.constructor = gr,
    vr.prototype = Object.create(Be.prototype),
    vr.prototype.constructor = vr,
    vr.prototype.isWebGLRenderTargetCube = !0,
    vr.prototype.fromEquirectangularTexture = function(t, e) {
        this.texture.type = e.type,
        this.texture.format = e.format,
        this.texture.encoding = e.encoding;
        var n = new gn
          , i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ['varying vec3 vWorldDirection;', 'vec3 transformDirection( in vec3 dir, in mat4 matrix ) {', '\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );', '}', 'void main() {', '\tvWorldDirection = transformDirection( position, modelMatrix );', '\t#include <begin_vertex>', '\t#include <project_vertex>', '}'].join('\n'),
            fragmentShader: ['uniform sampler2D tEquirect;', 'varying vec3 vWorldDirection;', '#define RECIPROCAL_PI 0.31830988618', '#define RECIPROCAL_PI2 0.15915494', 'void main() {', '\tvec3 direction = normalize( vWorldDirection );', '\tvec2 sampleUV;', '\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;', '\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;', '\tgl_FragColor = texture2D( tEquirect, sampleUV );', '}'].join('\n')
        }
          , r = new ur({
            type: 'CubemapFromEquirect',
            uniforms: sr(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: h,
            blending: m
        });
        r.uniforms.tEquirect.value = e;
        var o = new Ki(new ar(5,5,5),r);
        n.add(o);
        var a = new gr(1,10,1);
        return a.renderTarget = this,
        a.renderTarget.texture.name = 'CubeCameraTexture',
        a.update(t, n),
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    ,
    yr.prototype = Object.create(Re.prototype),
    yr.prototype.constructor = yr,
    yr.prototype.isDataTexture = !0;
    var xr = new On
      , br = new Oe;
    function _r(t, e, n, i, r, o) {
        this.planes = [void 0 !== t ? t : new Wn, void 0 !== e ? e : new Wn, void 0 !== n ? n : new Wn, void 0 !== i ? i : new Wn, void 0 !== r ? r : new Wn, void 0 !== o ? o : new Wn]
    }
    Object.assign(_r.prototype, {
        set: function(t, e, n, i, r, o) {
            var a = this.planes;
            return a[0].copy(t),
            a[1].copy(e),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes
              , n = t.elements
              , i = n[0]
              , r = n[1]
              , o = n[2]
              , a = n[3]
              , s = n[4]
              , l = n[5]
              , c = n[6]
              , h = n[7]
              , u = n[8]
              , p = n[9]
              , d = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = n[15];
            return e[0].setComponents(a - i, h - s, f - u, y - m).normalize(),
            e[1].setComponents(a + i, h + s, f + u, y + m).normalize(),
            e[2].setComponents(a + r, h + l, f + p, y + g).normalize(),
            e[3].setComponents(a - r, h - l, f - p, y - g).normalize(),
            e[4].setComponents(a - o, h - c, f - d, y - v).normalize(),
            e[5].setComponents(a + o, h + c, f + d, y + v).normalize(),
            this
        },
        intersectsObject: function(t) {
            var e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(),
            xr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(xr)
        },
        intersectsSprite: function(t) {
            return xr.center.set(0, 0, 0),
            xr.radius = .7071067811865476,
            xr.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(xr)
        },
        intersectsSphere: function(t) {
            for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                if (e[r].distanceToPoint(n) < i)
                    return !1
            }
            return !0
        },
        intersectsBox: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++) {
                var i = e[n];
                if (br.x = i.normal.x > 0 ? t.max.x : t.min.x,
                br.y = i.normal.y > 0 ? t.max.y : t.min.y,
                br.z = i.normal.z > 0 ? t.max.z : t.min.z,
                i.distanceToPoint(br) < 0)
                    return !1
            }
            return !0
        },
        containsPoint: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
    });
    var Mr = {
        alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
        alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
        alphatest_fragment: '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
        aomap_fragment: '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
        aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
        begin_vertex: 'vec3 transformed = vec3( position );',
        beginnormal_vertex: 'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
        bsdfs: 'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
        bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
        clipping_planes_fragment: '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
        clipping_planes_pars_fragment: '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
        clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif',
        clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif',
        color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
        color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
        color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
        color_vertex: '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
        common: '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}',
        cube_uv_reflection_fragment: '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif',
        defaultnormal_vertex: 'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
        displacementmap_pars_vertex: '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
        displacementmap_vertex: '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
        emissivemap_fragment: '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
        emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
        encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
        encodings_pars_fragment: '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
        envmap_fragment: '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
        envmap_common_pars_fragment: '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
        envmap_pars_fragment: '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
        envmap_pars_vertex: '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
        envmap_physical_pars_fragment: '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
        envmap_vertex: '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
        fog_vertex: '#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif',
        fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
        fog_fragment: '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
        fog_pars_fragment: '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
        gradientmap_pars_fragment: '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif',
        lightmap_fragment: '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif',
        lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
        lights_lambert_vertex: 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif',
        lights_pars_begin: 'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
        lights_phong_fragment: 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
        lights_phong_pars_fragment: 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
        lights_physical_fragment: 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
        lights_physical_pars_fragment: 'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
        lights_fragment_begin: '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
        lights_fragment_maps: '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
        lights_fragment_end: '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
        logdepthbuf_fragment: '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
        logdepthbuf_pars_fragment: '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
        logdepthbuf_pars_vertex: '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
        logdepthbuf_vertex: '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
        map_fragment: '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
        map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
        map_particle_fragment: '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
        map_particle_pars_fragment: '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
        metalnessmap_fragment: 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
        metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
        morphnormal_vertex: '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
        morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
        morphtarget_vertex: '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
        normal_fragment_begin: '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
        normal_fragment_maps: '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif',
        normalmap_pars_fragment: '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif',
        clearcoat_normal_fragment_begin: '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
        clearcoat_normal_fragment_maps: '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif',
        clearcoat_normalmap_pars_fragment: '#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
        packing: 'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpack2HalfToRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
        premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
        project_vertex: 'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
        dithering_fragment: '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
        dithering_pars_fragment: '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
        roughnessmap_fragment: 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
        roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
        shadowmap_pars_fragment: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpack2HalfToRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
        shadowmap_pars_vertex: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
        shadowmap_vertex: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif',
        shadowmask_pars_fragment: 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}',
        skinbase_vertex: '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
        skinning_pars_vertex: '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
        skinning_vertex: '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
        skinnormal_vertex: '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
        specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
        specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
        tonemapping_fragment: '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
        tonemapping_pars_fragment: '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}',
        uv_pars_fragment: '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
        uv_pars_vertex: '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
        uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
        uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
        uv2_pars_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',
        uv2_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',
        worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
        background_frag: 'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        background_vert: 'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
        cube_frag: 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        cube_vert: 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
        depth_frag: '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}',
        depth_vert: '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}',
        distanceRGBA_frag: '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
        distanceRGBA_vert: '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
        equirect_frag: 'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
        equirect_vert: 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
        linedashed_frag: 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        linedashed_vert: 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
        meshbasic_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        meshbasic_vert: '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
        meshlambert_frag: 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshlambert_vert: '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshmatcap_frag: '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        meshmatcap_vert: '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
        meshphong_frag: '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshphong_vert: '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        meshphysical_frag: '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
        meshphysical_vert: '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        normal_frag: '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
        normal_vert: '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
        points_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        points_vert: 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
        shadow_frag: 'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}',
        shadow_vert: '#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
        sprite_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        sprite_vert: 'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}'
    }
      , wr = {
        common: {
            diffuse: {
                value: new ai(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new ke
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Te(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new ai(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new ai(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new ke
            }
        },
        sprite: {
            diffuse: {
                value: new ai(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Te(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new ke
            }
        }
    }
      , Sr = {
        basic: {
            uniforms: lr([wr.common, wr.specularmap, wr.envmap, wr.aomap, wr.lightmap, wr.fog]),
            vertexShader: Mr.meshbasic_vert,
            fragmentShader: Mr.meshbasic_frag
        },
        lambert: {
            uniforms: lr([wr.common, wr.specularmap, wr.envmap, wr.aomap, wr.lightmap, wr.emissivemap, wr.fog, wr.lights, {
                emissive: {
                    value: new ai(0)
                }
            }]),
            vertexShader: Mr.meshlambert_vert,
            fragmentShader: Mr.meshlambert_frag
        },
        phong: {
            uniforms: lr([wr.common, wr.specularmap, wr.envmap, wr.aomap, wr.lightmap, wr.emissivemap, wr.bumpmap, wr.normalmap, wr.displacementmap, wr.gradientmap, wr.fog, wr.lights, {
                emissive: {
                    value: new ai(0)
                },
                specular: {
                    value: new ai(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Mr.meshphong_vert,
            fragmentShader: Mr.meshphong_frag
        },
        standard: {
            uniforms: lr([wr.common, wr.envmap, wr.aomap, wr.lightmap, wr.emissivemap, wr.bumpmap, wr.normalmap, wr.displacementmap, wr.roughnessmap, wr.metalnessmap, wr.fog, wr.lights, {
                emissive: {
                    value: new ai(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Mr.meshphysical_vert,
            fragmentShader: Mr.meshphysical_frag
        },
        matcap: {
            uniforms: lr([wr.common, wr.bumpmap, wr.normalmap, wr.displacementmap, wr.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Mr.meshmatcap_vert,
            fragmentShader: Mr.meshmatcap_frag
        },
        points: {
            uniforms: lr([wr.points, wr.fog]),
            vertexShader: Mr.points_vert,
            fragmentShader: Mr.points_frag
        },
        dashed: {
            uniforms: lr([wr.common, wr.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Mr.linedashed_vert,
            fragmentShader: Mr.linedashed_frag
        },
        depth: {
            uniforms: lr([wr.common, wr.displacementmap]),
            vertexShader: Mr.depth_vert,
            fragmentShader: Mr.depth_frag
        },
        normal: {
            uniforms: lr([wr.common, wr.bumpmap, wr.normalmap, wr.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Mr.normal_vert,
            fragmentShader: Mr.normal_frag
        },
        sprite: {
            uniforms: lr([wr.sprite, wr.fog]),
            vertexShader: Mr.sprite_vert,
            fragmentShader: Mr.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new ke
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Mr.background_vert,
            fragmentShader: Mr.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Mr.cube_vert,
            fragmentShader: Mr.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Mr.equirect_vert,
            fragmentShader: Mr.equirect_frag
        },
        distanceRGBA: {
            uniforms: lr([wr.common, wr.displacementmap, {
                referencePosition: {
                    value: new Oe
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Mr.distanceRGBA_vert,
            fragmentShader: Mr.distanceRGBA_frag
        },
        shadow: {
            uniforms: lr([wr.lights, wr.fog, {
                color: {
                    value: new ai(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Mr.shadow_vert,
            fragmentShader: Mr.shadow_frag
        }
    };
    function Pr() {
        var t = null
          , e = !1
          , n = null;
        function i(r, o) {
            !1 !== e && (n(r, o),
            t.requestAnimationFrame(i))
        }
        return {
            start: function() {
                !0 !== e && null !== n && (t.requestAnimationFrame(i),
                e = !0)
            },
            stop: function() {
                e = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }
    function Cr(t) {
        var e = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                e.get(t)
            },
            remove: function(n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var i = e.get(n);
                i && (t.deleteBuffer(i.buffer),
                e.delete(n))
            },
            update: function(n, i) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var r = e.get(n);
                void 0 === r ? e.set(n, function(e, n) {
                    var i = e.array
                      , r = e.usage
                      , o = t.createBuffer();
                    t.bindBuffer(n, o),
                    t.bufferData(n, i, r),
                    e.onUploadCallback();
                    var a = 5126;
                    return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array || (i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121)),
                    {
                        buffer: o,
                        type: a,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(n, i)) : r.version < n.version && (!function(e, n, i) {
                    var r = n.array
                      , o = n.updateRange;
                    t.bindBuffer(i, e),
                    -1 === o.count ? t.bufferSubData(i, 0, r) : (t.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)),
                    o.count = -1)
                }(r.buffer, n, i),
                r.version = n.version)
            }
        }
    }
    function Ar(t, e, n, i) {
        rr.call(this),
        this.type = 'PlaneGeometry',
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        },
        this.fromBufferGeometry(new Er(t,e,n,i)),
        this.mergeVertices()
    }
    function Er(t, e, n, i) {
        Oi.call(this),
        this.type = 'PlaneBufferGeometry',
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        var r, o, a = (t = t || 1) / 2, s = (e = e || 1) / 2, l = Math.floor(n) || 1, c = Math.floor(i) || 1, h = l + 1, u = c + 1, p = t / l, d = e / c, f = [], m = [], g = [], v = [];
        for (o = 0; o < u; o++) {
            var y = o * d - s;
            for (r = 0; r < h; r++) {
                var x = r * p - a;
                m.push(x, -y, 0),
                g.push(0, 0, 1),
                v.push(r / l),
                v.push(1 - o / c)
            }
        }
        for (o = 0; o < c; o++)
            for (r = 0; r < l; r++) {
                var b = r + h * o
                  , _ = r + h * (o + 1)
                  , M = r + 1 + h * (o + 1)
                  , w = r + 1 + h * o;
                f.push(b, _, w),
                f.push(_, M, w)
            }
        this.setIndex(f),
        this.setAttribute('position', new Mi(m,3)),
        this.setAttribute('normal', new Mi(g,3)),
        this.setAttribute('uv', new Mi(v,2))
    }
    function Tr(t, e, n, i) {
        var r, o, a = new ai(0), s = 0, l = null, u = 0;
        function p(t, n) {
            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(t, e) {
                a.set(t),
                p(a, s = void 0 !== e ? e : 1)
            },
            getClearAlpha: function() {
                return s
            },
            setClearAlpha: function(t) {
                p(a, s = t)
            },
            render: function(e, i, d, f) {
                var m = i.background
                  , g = t.vr
                  , v = g.getSession && g.getSession();
                if (v && 'additive' === v.environmentBlendMode && (m = null),
                null === m ? (p(a, s),
                l = null,
                u = 0) : m && m.isColor && (p(m, 1),
                f = !0,
                l = null,
                u = 0),
                (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                m && (m.isCubeTexture || m.isWebGLRenderTargetCube)) {
                    void 0 === o && ((o = new Ki(new ar(1,1,1),new ur({
                        type: 'BackgroundCubeMaterial',
                        uniforms: sr(Sr.cube.uniforms),
                        vertexShader: Sr.cube.vertexShader,
                        fragmentShader: Sr.cube.fragmentShader,
                        side: h,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute('normal'),
                    o.geometry.deleteAttribute('uv'),
                    o.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(o.material, 'map', {
                        get: function() {
                            return this.uniforms.tCube.value
                        }
                    }),
                    n.update(o));
                    var y = m.isWebGLRenderTargetCube ? m.texture : m;
                    o.material.uniforms.tCube.value = y,
                    o.material.uniforms.tFlip.value = m.isWebGLRenderTargetCube ? 1 : -1,
                    l === m && u === y.version || (o.material.needsUpdate = !0,
                    l = m,
                    u = y.version),
                    e.unshift(o, o.geometry, o.material, 0, 0, null)
                } else
                    m && m.isTexture && (void 0 === r && ((r = new Ki(new Er(2,2),new ur({
                        type: 'BackgroundMaterial',
                        uniforms: sr(Sr.background.uniforms),
                        vertexShader: Sr.background.vertexShader,
                        fragmentShader: Sr.background.fragmentShader,
                        side: c,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute('normal'),
                    Object.defineProperty(r.material, 'map', {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    n.update(r)),
                    r.material.uniforms.t2D.value = m,
                    !0 === m.matrixAutoUpdate && m.updateMatrix(),
                    r.material.uniforms.uvTransform.value.copy(m.matrix),
                    l === m && u === m.version || (r.material.needsUpdate = !0,
                    l = m,
                    u = m.version),
                    e.unshift(r, r.geometry, r.material, 0, 0, null))
            }
        }
    }
    function Lr(t, e, n, i) {
        var r, o = i.isWebGL2;
        this.setMode = function(t) {
            r = t
        }
        ,
        this.render = function(e, i) {
            t.drawArrays(r, e, i),
            n.update(i, r)
        }
        ,
        this.renderInstances = function(i, a, s, l) {
            if (0 !== l) {
                var c, h;
                if (o)
                    c = t,
                    h = 'drawArraysInstanced';
                else if (h = 'drawArraysInstancedANGLE',
                null === (c = e.get('ANGLE_instanced_arrays')))
                    return;
                c[h](r, a, s, l),
                n.update(s, r, l)
            }
        }
    }
    function Dr(t, e, n) {
        var i;
        function r(e) {
            if ('highp' === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return 'highp';
                e = 'mediump'
            }
            return 'mediump' === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? 'mediump' : 'lowp'
        }
        var o = 'undefined' != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || 'undefined' != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext
          , a = void 0 !== n.precision ? n.precision : 'highp'
          , s = r(a);
        s !== a && (a = s);
        var l = !0 === n.logarithmicDepthBuffer
          , c = t.getParameter(34930)
          , h = t.getParameter(35660)
          , u = t.getParameter(3379)
          , p = t.getParameter(34076)
          , d = t.getParameter(34921)
          , f = t.getParameter(36347)
          , m = t.getParameter(36348)
          , g = t.getParameter(36349)
          , v = h > 0
          , y = o || !!e.get('OES_texture_float');
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== i)
                    return i;
                var n = e.get('EXT_texture_filter_anisotropic');
                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: p,
            maxAttributes: d,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: o ? t.getParameter(36183) : 0
        }
    }
    function Ir() {
        var t = this
          , e = null
          , n = 0
          , i = !1
          , r = !1
          , o = new Wn
          , a = new ke
          , s = {
            value: null,
            needsUpdate: !1
        };
        function l() {
            s.value !== e && (s.value = e,
            s.needsUpdate = n > 0),
            t.numPlanes = n,
            t.numIntersection = 0
        }
        function c(e, n, i, r) {
            var l = null !== e ? e.length : 0
              , c = null;
            if (0 !== l) {
                if (c = s.value,
                !0 !== r || null === c) {
                    var h = i + 4 * l
                      , u = n.matrixWorldInverse;
                    a.getNormalMatrix(u),
                    (null === c || c.length < h) && (c = new Float32Array(h));
                    for (var p = 0, d = i; p !== l; ++p,
                    d += 4)
                        o.copy(e[p]).applyMatrix4(u, a),
                        o.normal.toArray(c, d),
                        c[d + 3] = o.constant
                }
                s.value = c,
                s.needsUpdate = !0
            }
            return t.numPlanes = l,
            c
        }
        this.uniform = s,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(t, r, o) {
            var a = 0 !== t.length || r || 0 !== n || i;
            return i = r,
            e = c(t, o, 0),
            n = t.length,
            a
        }
        ,
        this.beginShadows = function() {
            r = !0,
            c(null)
        }
        ,
        this.endShadows = function() {
            r = !1,
            l()
        }
        ,
        this.setState = function(t, o, a, h, u, p) {
            if (!i || null === t || 0 === t.length || r && !a)
                r ? c(null) : l();
            else {
                var d = r ? 0 : n
                  , f = 4 * d
                  , m = u.clippingState || null;
                s.value = m,
                m = c(t, h, f, p);
                for (var g = 0; g !== f; ++g)
                    m[g] = e[g];
                u.clippingState = m,
                this.numIntersection = o ? this.numPlanes : 0,
                this.numPlanes += d
            }
        }
    }
    function Or(t) {
        var e = {};
        return {
            get: function(n) {
                if (void 0 !== e[n])
                    return e[n];
                var i;
                switch (n) {
                case 'WEBGL_depth_texture':
                    i = t.getExtension('WEBGL_depth_texture') || t.getExtension('MOZ_WEBGL_depth_texture') || t.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    i = t.getExtension('EXT_texture_filter_anisotropic') || t.getExtension('MOZ_EXT_texture_filter_anisotropic') || t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    i = t.getExtension('WEBGL_compressed_texture_s3tc') || t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    i = t.getExtension('WEBGL_compressed_texture_pvrtc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                i
            }
        }
    }
    function jr(t, e, n) {
        var i = new WeakMap
          , r = new WeakMap;
        function o(t) {
            var a = t.target
              , s = i.get(a);
            for (var l in null !== s.index && e.remove(s.index),
            s.attributes)
                e.remove(s.attributes[l]);
            a.removeEventListener('dispose', o),
            i.delete(a);
            var c = r.get(s);
            c && (e.remove(c),
            r.delete(s)),
            n.memory.geometries--
        }
        function a(t) {
            var n = []
              , i = t.index
              , o = t.attributes.position
              , a = 0;
            if (null !== i) {
                var s = i.array;
                a = i.version;
                for (var l = 0, c = s.length; l < c; l += 3) {
                    var h = s[l + 0]
                      , u = s[l + 1]
                      , p = s[l + 2];
                    n.push(h, u, u, p, p, h)
                }
            } else {
                s = o.array;
                a = o.version;
                for (l = 0,
                c = s.length / 3 - 1; l < c; l += 3) {
                    h = l + 0,
                    u = l + 1,
                    p = l + 2;
                    n.push(h, u, u, p, p, h)
                }
            }
            var d = new (Pi(n) > 65535 ? _i : xi)(n,1);
            d.version = a,
            e.update(d, 34963);
            var f = r.get(t);
            f && e.remove(f),
            r.set(t, d)
        }
        return {
            get: function(t, e) {
                var r = i.get(e);
                return r || (e.addEventListener('dispose', o),
                e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Oi).setFromObject(t)),
                r = e._bufferGeometry),
                i.set(e, r),
                n.memory.geometries++,
                r)
            },
            update: function(t) {
                var n = t.index
                  , i = t.attributes;
                for (var r in null !== n && e.update(n, 34963),
                i)
                    e.update(i[r], 34962);
                var o = t.morphAttributes;
                for (var r in o)
                    for (var a = o[r], s = 0, l = a.length; s < l; s++)
                        e.update(a[s], 34962)
            },
            getWireframeAttribute: function(t) {
                var e = r.get(t);
                if (e) {
                    var n = t.index;
                    null !== n && e.version < n.version && a(t)
                } else
                    a(t);
                return r.get(t)
            }
        }
    }
    function Nr(t, e, n, i) {
        var r, o, a, s = i.isWebGL2;
        this.setMode = function(t) {
            r = t
        }
        ,
        this.setIndex = function(t) {
            o = t.type,
            a = t.bytesPerElement
        }
        ,
        this.render = function(e, i) {
            t.drawElements(r, i, o, e * a),
            n.update(i, r)
        }
        ,
        this.renderInstances = function(i, l, c, h) {
            if (0 !== h) {
                var u, p;
                if (s)
                    u = t,
                    p = 'drawElementsInstanced';
                else if (p = 'drawElementsInstancedANGLE',
                null === (u = e.get('ANGLE_instanced_arrays')))
                    return;
                u[p](r, c, o, l * a, h),
                n.update(c, r, h)
            }
        }
    }
    function kr(t) {
        var e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function() {
                e.frame++,
                e.calls = 0,
                e.triangles = 0,
                e.points = 0,
                e.lines = 0
            },
            update: function(t, n, i) {
                switch (i = i || 1,
                e.calls++,
                n) {
                case 4:
                    e.triangles += i * (t / 3);
                    break;
                case 5:
                case 6:
                    e.triangles += i * (t - 2);
                    break;
                case 1:
                    e.lines += i * (t / 2);
                    break;
                case 3:
                    e.lines += i * (t - 1);
                    break;
                case 2:
                    e.lines += i * t;
                    break;
                case 0:
                    e.points += i * t
                }
            }
        }
    }
    function Fr(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function zr(t) {
        var e = {}
          , n = new Float32Array(8);
        return {
            update: function(i, r, o, a) {
                var s = i.morphTargetInfluences
                  , l = s.length
                  , c = e[r.id];
                if (void 0 === c) {
                    c = [];
                    for (var h = 0; h < l; h++)
                        c[h] = [h, 0];
                    e[r.id] = c
                }
                var u = o.morphTargets && r.morphAttributes.position
                  , p = o.morphNormals && r.morphAttributes.normal;
                for (h = 0; h < l; h++) {
                    0 !== (f = c[h])[1] && (u && r.deleteAttribute('morphTarget' + h),
                    p && r.deleteAttribute('morphNormal' + h))
                }
                for (h = 0; h < l; h++) {
                    (f = c[h])[0] = h,
                    f[1] = s[h]
                }
                c.sort(Fr);
                var d = 0;
                for (h = 0; h < 8; h++) {
                    var f;
                    if (f = c[h]) {
                        var m = f[0]
                          , g = f[1];
                        if (g) {
                            u && r.setAttribute('morphTarget' + h, u[m]),
                            p && r.setAttribute('morphNormal' + h, p[m]),
                            n[h] = g,
                            d += g;
                            continue
                        }
                    }
                    n[h] = 0
                }
                var v = r.morphTargetsRelative ? 1 : 1 - d;
                a.getUniforms().setValue(t, 'morphTargetBaseInfluence', v),
                a.getUniforms().setValue(t, 'morphTargetInfluences', n)
            }
        }
    }
    function Rr(t, e, n, i) {
        var r = {};
        return {
            update: function(t) {
                var o = i.render.frame
                  , a = t.geometry
                  , s = e.get(t, a);
                return r[s.id] !== o && (a.isGeometry && s.updateFromObject(t),
                e.update(s),
                r[s.id] = o),
                t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
                s
            },
            dispose: function() {
                r = {}
            }
        }
    }
    function Ur(t, e, n, i, r, o, a, s, l, c) {
        t = void 0 !== t ? t : [],
        e = void 0 !== e ? e : tt,
        a = void 0 !== a ? a : Tt,
        Re.call(this, t, e, n, i, r, o, a, s, l, c),
        this.flipY = !1
    }
    function Br(t, e, n, i) {
        Re.call(this, null),
        this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        },
        this.magFilter = ht,
        this.minFilter = ht,
        this.wrapR = lt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    function Vr(t, e, n, i) {
        Re.call(this, null),
        this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        },
        this.magFilter = ht,
        this.minFilter = ht,
        this.wrapR = lt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    Sr.physical = {
        uniforms: lr([Sr.standard.uniforms, {
            transparency: {
                value: 0
            },
            clearcoat: {
                value: 0
            },
            clearcoatRoughness: {
                value: 0
            },
            sheen: {
                value: new ai(0)
            },
            clearcoatNormalScale: {
                value: new Te(1,1)
            },
            clearcoatNormalMap: {
                value: null
            }
        }]),
        vertexShader: Mr.meshphysical_vert,
        fragmentShader: Mr.meshphysical_frag
    },
    Ar.prototype = Object.create(rr.prototype),
    Ar.prototype.constructor = Ar,
    Er.prototype = Object.create(Oi.prototype),
    Er.prototype.constructor = Er,
    Ur.prototype = Object.create(Re.prototype),
    Ur.prototype.constructor = Ur,
    Ur.prototype.isCubeTexture = !0,
    Object.defineProperty(Ur.prototype, 'images', {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    }),
    Br.prototype = Object.create(Re.prototype),
    Br.prototype.constructor = Br,
    Br.prototype.isDataTexture2DArray = !0,
    Vr.prototype = Object.create(Re.prototype),
    Vr.prototype.constructor = Vr,
    Vr.prototype.isDataTexture3D = !0;
    var Gr = new Re
      , Hr = new Br
      , Wr = new Vr
      , Xr = new Ur
      , qr = []
      , Yr = []
      , Jr = new Float32Array(16)
      , Zr = new Float32Array(9)
      , Kr = new Float32Array(4);
    function Qr(t, e, n) {
        var i = t[0];
        if (i <= 0 || i > 0)
            return t;
        var r = e * n
          , o = qr[r];
        if (void 0 === o && (o = new Float32Array(r),
        qr[r] = o),
        0 !== e) {
            i.toArray(o, 0);
            for (var a = 1, s = 0; a !== e; ++a)
                s += n,
                t[a].toArray(o, s)
        }
        return o
    }
    function $r(t, e) {
        if (t.length !== e.length)
            return !1;
        for (var n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n])
                return !1;
        return !0
    }
    function to(t, e) {
        for (var n = 0, i = e.length; n < i; n++)
            t[n] = e[n]
    }
    function eo(t, e) {
        var n = Yr[e];
        void 0 === n && (n = new Int32Array(e),
        Yr[e] = n);
        for (var i = 0; i !== e; ++i)
            n[i] = t.allocateTextureUnit();
        return n
    }
    function no(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e),
        n[0] = e)
    }
    function io(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
            n[0] = e.x,
            n[1] = e.y);
        else {
            if ($r(n, e))
                return;
            t.uniform2fv(this.addr, e),
            to(n, e)
        }
    }
    function ro(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z);
        else if (void 0 !== e.r)
            n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
            n[0] = e.r,
            n[1] = e.g,
            n[2] = e.b);
        else {
            if ($r(n, e))
                return;
            t.uniform3fv(this.addr, e),
            to(n, e)
        }
    }
    function oo(t, e) {
        var n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z,
            n[3] = e.w);
        else {
            if ($r(n, e))
                return;
            t.uniform4fv(this.addr, e),
            to(n, e)
        }
    }
    function ao(t, e) {
        var n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if ($r(n, e))
                return;
            t.uniformMatrix2fv(this.addr, !1, e),
            to(n, e)
        } else {
            if ($r(n, i))
                return;
            Kr.set(i),
            t.uniformMatrix2fv(this.addr, !1, Kr),
            to(n, i)
        }
    }
    function so(t, e) {
        var n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if ($r(n, e))
                return;
            t.uniformMatrix3fv(this.addr, !1, e),
            to(n, e)
        } else {
            if ($r(n, i))
                return;
            Zr.set(i),
            t.uniformMatrix3fv(this.addr, !1, Zr),
            to(n, i)
        }
    }
    function lo(t, e) {
        var n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if ($r(n, e))
                return;
            t.uniformMatrix4fv(this.addr, !1, e),
            to(n, e)
        } else {
            if ($r(n, i))
                return;
            Jr.set(i),
            t.uniformMatrix4fv(this.addr, !1, Jr),
            to(n, i)
        }
    }
    function co(t, e, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTexture2D(e || Gr, r)
    }
    function ho(t, e, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture2DArray(e || Hr, r)
    }
    function uo(t, e, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture3D(e || Wr, r)
    }
    function po(t, e, n) {
        var i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTextureCube(e || Xr, r)
    }
    function fo(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e),
        n[0] = e)
    }
    function mo(t, e) {
        var n = this.cache;
        $r(n, e) || (t.uniform2iv(this.addr, e),
        to(n, e))
    }
    function go(t, e) {
        var n = this.cache;
        $r(n, e) || (t.uniform3iv(this.addr, e),
        to(n, e))
    }
    function vo(t, e) {
        var n = this.cache;
        $r(n, e) || (t.uniform4iv(this.addr, e),
        to(n, e))
    }
    function yo(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function xo(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function bo(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function _o(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function Mo(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function wo(t, e) {
        var n = Qr(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }
    function So(t, e) {
        var n = Qr(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }
    function Po(t, e) {
        var n = Qr(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }
    function Co(t, e) {
        var n = Qr(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }
    function Ao(t, e) {
        var n = Qr(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }
    function Eo(t, e) {
        var n = Qr(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }
    function To(t, e, n) {
        var i = e.length
          , r = eo(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o)
            n.safeSetTexture2D(e[o] || Gr, r[o])
    }
    function Lo(t, e, n) {
        var i = e.length
          , r = eo(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o)
            n.safeSetTextureCube(e[o] || Xr, r[o])
    }
    function Do(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return no;
            case 35664:
                return io;
            case 35665:
                return ro;
            case 35666:
                return oo;
            case 35674:
                return ao;
            case 35675:
                return so;
            case 35676:
                return lo;
            case 35678:
            case 36198:
                return co;
            case 35679:
                return uo;
            case 35680:
                return po;
            case 36289:
                return ho;
            case 5124:
            case 35670:
                return fo;
            case 35667:
            case 35671:
                return mo;
            case 35668:
            case 35672:
                return go;
            case 35669:
            case 35673:
                return vo
            }
        }(e.type)
    }
    function Io(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return yo;
            case 35664:
                return wo;
            case 35665:
                return So;
            case 35666:
                return Po;
            case 35674:
                return Co;
            case 35675:
                return Ao;
            case 35676:
                return Eo;
            case 35678:
                return To;
            case 35680:
                return Lo;
            case 5124:
            case 35670:
                return xo;
            case 35667:
            case 35671:
                return bo;
            case 35668:
            case 35672:
                return _o;
            case 35669:
            case 35673:
                return Mo
            }
        }(e.type)
    }
    function Oo(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    Io.prototype.updateCache = function(t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
        to(e, t)
    }
    ,
    Oo.prototype.setValue = function(t, e, n) {
        for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
            var a = i[r];
            a.setValue(t, e[a.id], n)
        }
    }
    ;
    var jo = /([\w\d_]+)(\])?(\[|\.)?/g;
    function No(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }
    function ko(t, e, n) {
        var i = t.name
          , r = i.length;
        for (jo.lastIndex = 0; ; ) {
            var o = jo.exec(i)
              , a = jo.lastIndex
              , s = o[1]
              , l = ']' === o[2]
              , c = o[3];
            if (l && (s |= 0),
            void 0 === c || '[' === c && a + 2 === r) {
                No(n, void 0 === c ? new Do(s,t,e) : new Io(s,t,e));
                break
            }
            var h = n.map[s];
            void 0 === h && No(n, h = new Oo(s)),
            n = h
        }
    }
    function Fo(t, e) {
        this.seq = [],
        this.map = {};
        for (var n = t.getProgramParameter(e, 35718), i = 0; i < n; ++i) {
            var r = t.getActiveUniform(e, i);
            ko(r, t.getUniformLocation(e, r.name), this)
        }
    }
    function zo(t, e, n) {
        var i = t.createShader(e);
        return t.shaderSource(i, n),
        t.compileShader(i),
        i
    }
    Fo.prototype.setValue = function(t, e, n, i) {
        var r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }
    ,
    Fo.prototype.setOptional = function(t, e, n) {
        var i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }
    ,
    Fo.upload = function(t, e, n, i) {
        for (var r = 0, o = e.length; r !== o; ++r) {
            var a = e[r]
              , s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, i)
        }
    }
    ,
    Fo.seqWithValue = function(t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var o = t[i];
            o.id in e && n.push(o)
        }
        return n
    }
    ;
    var Ro = 0;
    function Uo(t) {
        switch (t) {
        case he:
            return ['Linear', '( value )'];
        case ue:
            return ['sRGB', '( value )'];
        case de:
            return ['RGBE', '( value )'];
        case me:
            return ['RGBM', '( value, 7.0 )'];
        case ge:
            return ['RGBM', '( value, 16.0 )'];
        case ve:
            return ['RGBD', '( value, 256.0 )'];
        case pe:
            return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
        case fe:
            return ['LogLuv', '( value )'];
        default:
            throw new Error('unsupported encoding: ' + t)
        }
    }
    function Bo(t, e, n) {
        var i = t.getShaderParameter(e, 35713)
          , r = t.getShaderInfoLog(e).trim();
        return i && '' === r ? '' : 'THREE.WebGLShader: gl.getShaderInfoLog() ' + n + '\n' + r + function(t) {
            for (var e = t.split('\n'), n = 0; n < e.length; n++)
                e[n] = n + 1 + ': ' + e[n];
            return e.join('\n')
        }(t.getShaderSource(e))
    }
    function Vo(t, e) {
        var n = Uo(e);
        return 'vec4 ' + t + '( vec4 value ) { return ' + n[0] + 'ToLinear' + n[1] + '; }'
    }
    function Go(t, e) {
        var n;
        switch (e) {
        case J:
            n = 'Linear';
            break;
        case Z:
            n = 'Reinhard';
            break;
        case K:
            n = 'Uncharted2';
            break;
        case Q:
            n = 'OptimizedCineon';
            break;
        case $:
            n = 'ACESFilmic';
            break;
        default:
            throw new Error('unsupported toneMapping: ' + e)
        }
        return 'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
    }
    function Ho(t) {
        return '' !== t
    }
    function Wo(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }
    function Xo(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    var qo = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Yo(t) {
        return t.replace(qo, Jo)
    }
    function Jo(t, e) {
        var n = Mr[e];
        if (void 0 === n)
            throw new Error('Can not resolve #include <' + e + '>');
        return Yo(n)
    }
    var Zo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function Ko(t) {
        return t.replace(Zo, Qo)
    }
    function Qo(t, e, n, i) {
        for (var r = '', o = parseInt(e); o < parseInt(n); o++)
            r += i.replace(/\[ i \]/g, '[ ' + o + ' ]').replace(/UNROLLED_LOOP_INDEX/g, o);
        return r
    }
    function $o(t) {
        var e = 'precision ' + t.precision + ' float;\nprecision ' + t.precision + ' int;';
        return 'highp' === t.precision ? e += '\n#define HIGH_PRECISION' : 'mediump' === t.precision ? e += '\n#define MEDIUM_PRECISION' : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
        e
    }
    function ta(t, e, n, i, r, o) {
        var c, h, u, p, d, f = t.getContext(), m = i.defines, g = r.vertexShader, v = r.fragmentShader, y = function(t) {
            var e = 'SHADOWMAP_TYPE_BASIC';
            return t.shadowMapType === a ? e = 'SHADOWMAP_TYPE_PCF' : t.shadowMapType === s ? e = 'SHADOWMAP_TYPE_PCF_SOFT' : t.shadowMapType === l && (e = 'SHADOWMAP_TYPE_VSM'),
            e
        }(o), x = function(t) {
            var e = 'ENVMAP_TYPE_CUBE';
            if (t.envMap)
                switch (t.envMapMode) {
                case tt:
                case et:
                    e = 'ENVMAP_TYPE_CUBE';
                    break;
                case ot:
                case at:
                    e = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case nt:
                case it:
                    e = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case rt:
                    e = 'ENVMAP_TYPE_SPHERE'
                }
            return e
        }(o), b = function(t) {
            var e = 'ENVMAP_MODE_REFLECTION';
            if (t.envMap)
                switch (t.envMapMode) {
                case et:
                case it:
                    e = 'ENVMAP_MODE_REFRACTION'
                }
            return e
        }(o), _ = function(t) {
            var e = 'ENVMAP_BLENDING_MULTIPLY';
            if (t.envMap)
                switch (t.combine) {
                case W:
                    e = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case X:
                    e = 'ENVMAP_BLENDING_MIX';
                    break;
                case q:
                    e = 'ENVMAP_BLENDING_ADD'
                }
            return e
        }(o), M = t.gammaFactor > 0 ? t.gammaFactor : 1, w = o.isWebGL2 ? '' : function(t, e, n) {
            return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (t.fragDepth || e.logarithmicDepthBuffer) && n.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', t.drawBuffers && n.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (t.shaderTextureLOD || e.envMap) && n.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''].filter(Ho).join('\n')
        }(i.extensions, o, e), S = function(t) {
            var e = [];
            for (var n in t) {
                var i = t[n];
                !1 !== i && e.push('#define ' + n + ' ' + i)
            }
            return e.join('\n')
        }(m), P = f.createProgram(), C = o.numMultiviewViews;
        if (i.isRawShaderMaterial ? ((c = [S].filter(Ho).join('\n')).length > 0 && (c += '\n'),
        (h = [w, S].filter(Ho).join('\n')).length > 0 && (h += '\n')) : (c = [$o(o), '#define SHADER_NAME ' + r.name, S, o.instancing ? '#define USE_INSTANCING' : '', o.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + M, '#define MAX_BONES ' + o.maxBones, o.useFog && o.fog ? '#define USE_FOG' : '', o.useFog && o.fogExp2 ? '#define FOG_EXP2' : '', o.map ? '#define USE_MAP' : '', o.envMap ? '#define USE_ENVMAP' : '', o.envMap ? '#define ' + b : '', o.lightMap ? '#define USE_LIGHTMAP' : '', o.aoMap ? '#define USE_AOMAP' : '', o.emissiveMap ? '#define USE_EMISSIVEMAP' : '', o.bumpMap ? '#define USE_BUMPMAP' : '', o.normalMap ? '#define USE_NORMALMAP' : '', o.normalMap && o.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', o.normalMap && o.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', o.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', o.displacementMap && o.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', o.specularMap ? '#define USE_SPECULARMAP' : '', o.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', o.metalnessMap ? '#define USE_METALNESSMAP' : '', o.alphaMap ? '#define USE_ALPHAMAP' : '', o.vertexTangents ? '#define USE_TANGENT' : '', o.vertexColors ? '#define USE_COLOR' : '', o.vertexUvs ? '#define USE_UV' : '', o.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', o.flatShading ? '#define FLAT_SHADED' : '', o.skinning ? '#define USE_SKINNING' : '', o.useVertexTexture ? '#define BONE_TEXTURE' : '', o.morphTargets ? '#define USE_MORPHTARGETS' : '', o.morphNormals && !1 === o.flatShading ? '#define USE_MORPHNORMALS' : '', o.doubleSided ? '#define DOUBLE_SIDED' : '', o.flipSided ? '#define FLIP_SIDED' : '', o.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', o.shadowMapEnabled ? '#define ' + y : '', o.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', o.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', o.logarithmicDepthBuffer && (o.isWebGL2 || e.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', ' attribute mat4 instanceMatrix;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\n'].filter(Ho).join('\n'),
        h = [w, $o(o), '#define SHADER_NAME ' + r.name, S, o.alphaTest ? '#define ALPHATEST ' + o.alphaTest + (o.alphaTest % 1 ? '' : '.0') : '', '#define GAMMA_FACTOR ' + M, o.useFog && o.fog ? '#define USE_FOG' : '', o.useFog && o.fogExp2 ? '#define FOG_EXP2' : '', o.map ? '#define USE_MAP' : '', o.matcap ? '#define USE_MATCAP' : '', o.envMap ? '#define USE_ENVMAP' : '', o.envMap ? '#define ' + x : '', o.envMap ? '#define ' + b : '', o.envMap ? '#define ' + _ : '', o.lightMap ? '#define USE_LIGHTMAP' : '', o.aoMap ? '#define USE_AOMAP' : '', o.emissiveMap ? '#define USE_EMISSIVEMAP' : '', o.bumpMap ? '#define USE_BUMPMAP' : '', o.normalMap ? '#define USE_NORMALMAP' : '', o.normalMap && o.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', o.normalMap && o.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', o.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', o.specularMap ? '#define USE_SPECULARMAP' : '', o.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', o.metalnessMap ? '#define USE_METALNESSMAP' : '', o.alphaMap ? '#define USE_ALPHAMAP' : '', o.sheen ? '#define USE_SHEEN' : '', o.vertexTangents ? '#define USE_TANGENT' : '', o.vertexColors ? '#define USE_COLOR' : '', o.vertexUvs ? '#define USE_UV' : '', o.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', o.gradientMap ? '#define USE_GRADIENTMAP' : '', o.flatShading ? '#define FLAT_SHADED' : '', o.doubleSided ? '#define DOUBLE_SIDED' : '', o.flipSided ? '#define FLIP_SIDED' : '', o.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', o.shadowMapEnabled ? '#define ' + y : '', o.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', o.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', o.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', o.logarithmicDepthBuffer && (o.isWebGL2 || e.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '', (i.extensions && i.extensions.shaderTextureLOD || o.envMap) && (o.isWebGL2 || e.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', o.toneMapping !== Y ? '#define TONE_MAPPING' : '', o.toneMapping !== Y ? Mr.tonemapping_pars_fragment : '', o.toneMapping !== Y ? Go('toneMapping', o.toneMapping) : '', o.dithering ? '#define DITHERING' : '', o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? Mr.encodings_pars_fragment : '', o.mapEncoding ? Vo('mapTexelToLinear', o.mapEncoding) : '', o.matcapEncoding ? Vo('matcapTexelToLinear', o.matcapEncoding) : '', o.envMapEncoding ? Vo('envMapTexelToLinear', o.envMapEncoding) : '', o.emissiveMapEncoding ? Vo('emissiveMapTexelToLinear', o.emissiveMapEncoding) : '', o.outputEncoding ? (u = 'linearToOutputTexel',
        p = o.outputEncoding,
        d = Uo(p),
        'vec4 ' + u + '( vec4 value ) { return LinearTo' + d[0] + d[1] + '; }') : '', o.depthPacking ? '#define DEPTH_PACKING ' + i.depthPacking : '', '\n'].filter(Ho).join('\n')),
        g = Xo(g = Wo(g = Yo(g), o), o),
        v = Xo(v = Wo(v = Yo(v), o), o),
        g = Ko(g),
        v = Ko(v),
        o.isWebGL2 && !i.isRawShaderMaterial) {
            var A = !1
              , E = /^\s*#version\s+300\s+es\s*\n/;
            i.isShaderMaterial && null !== g.match(E) && null !== v.match(E) && (A = !0,
            g = g.replace(E, ''),
            v = v.replace(E, '')),
            c = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + c,
            h = ['#version 300 es\n', '#define varying in', A ? '' : 'out highp vec4 pc_fragColor;', A ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + h,
            C > 0 && (c = (c = c.replace('#version 300 es\n', ['#version 300 es\n', '#extension GL_OVR_multiview2 : require', 'layout(num_views = ' + C + ') in;', '#define VIEW_ID gl_ViewID_OVR'].join('\n'))).replace(['uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;'].join('\n'), ['uniform mat4 modelViewMatrices[' + C + '];', 'uniform mat4 projectionMatrices[' + C + '];', 'uniform mat4 viewMatrices[' + C + '];', 'uniform mat3 normalMatrices[' + C + '];', '#define modelViewMatrix modelViewMatrices[VIEW_ID]', '#define projectionMatrix projectionMatrices[VIEW_ID]', '#define viewMatrix viewMatrices[VIEW_ID]', '#define normalMatrix normalMatrices[VIEW_ID]'].join('\n')),
            h = (h = h.replace('#version 300 es\n', ['#version 300 es\n', '#extension GL_OVR_multiview2 : require', '#define VIEW_ID gl_ViewID_OVR'].join('\n'))).replace('uniform mat4 viewMatrix;', ['uniform mat4 viewMatrices[' + C + '];', '#define viewMatrix viewMatrices[VIEW_ID]'].join('\n')))
        }
        var T, L, D = h + v, I = zo(f, 35633, c + g), O = zo(f, 35632, D);
        if (f.attachShader(P, I),
        f.attachShader(P, O),
        void 0 !== i.index0AttributeName ? f.bindAttribLocation(P, 0, i.index0AttributeName) : !0 === o.morphTargets && f.bindAttribLocation(P, 0, 'position'),
        f.linkProgram(P),
        t.debug.checkShaderErrors) {
            var j = f.getProgramInfoLog(P).trim()
              , N = f.getShaderInfoLog(I).trim()
              , k = f.getShaderInfoLog(O).trim()
              , F = !0
              , z = !0;
            if (!1 === f.getProgramParameter(P, 35714)) {
                F = !1;
                Bo(f, I, 'vertex'),
                Bo(f, O, 'fragment')
            } else
                '' !== j || '' !== N && '' !== k || (z = !1);
            z && (this.diagnostics = {
                runnable: F,
                material: i,
                programLog: j,
                vertexShader: {
                    log: N,
                    prefix: c
                },
                fragmentShader: {
                    log: k,
                    prefix: h
                }
            })
        }
        return f.deleteShader(I),
        f.deleteShader(O),
        this.getUniforms = function() {
            return void 0 === T && (T = new Fo(f,P)),
            T
        }
        ,
        this.getAttributes = function() {
            return void 0 === L && (L = function(t, e) {
                for (var n = {}, i = t.getProgramParameter(e, 35721), r = 0; r < i; r++) {
                    var o = t.getActiveAttrib(e, r).name;
                    n[o] = t.getAttribLocation(e, o)
                }
                return n
            }(f, P)),
            L
        }
        ,
        this.destroy = function() {
            f.deleteProgram(P),
            this.program = void 0
        }
        ,
        this.name = r.name,
        this.id = Ro++,
        this.cacheKey = n,
        this.usedTimes = 1,
        this.program = P,
        this.vertexShader = I,
        this.fragmentShader = O,
        this.numMultiviewViews = C,
        this
    }
    function ea(t, e, n) {
        var i = []
          , r = n.isWebGL2
          , o = n.logarithmicDepthBuffer
          , a = n.floatVertexTextures
          , s = n.precision
          , l = n.maxVertexUniforms
          , c = n.vertexTextures
          , p = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
        }
          , d = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'numMultiviewViews', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen'];
        function f(t, e) {
            var n;
            return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (n = t.texture.encoding) : n = he,
            n === he && e && (n = pe),
            n
        }
        this.getParameters = function(e, i, d, m, g, v, y) {
            var x = p[e.type]
              , b = y.isSkinnedMesh ? function(t) {
                var e = t.skeleton.bones;
                if (a)
                    return 1024;
                var n = l
                  , i = Math.floor((n - 20) / 4)
                  , r = Math.min(i, e.length);
                return r < e.length ? 0 : r
            }(y) : 0;
            null !== e.precision && (s = n.getMaxPrecision(e.precision),
            e.precision);
            var _ = t.getRenderTarget()
              , M = _ && _.isWebGLMultiviewRenderTarget ? _.numViews : 0;
            return {
                isWebGL2: r,
                shaderID: x,
                precision: s,
                instancing: !0 === y.isInstancedMesh,
                supportsVertexTextures: c,
                numMultiviewViews: M,
                outputEncoding: f(_ ? _.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: f(e.map, t.gammaInput),
                matcap: !!e.matcap,
                matcapEncoding: f(e.matcap, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: f(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === ot || e.envMap.mapping === at),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: f(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: e.normalMapType === _e,
                tangentSpaceNormalMap: e.normalMapType === be,
                clearcoatNormalMap: !!e.clearcoatNormalMap,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                sheen: !!e.sheen,
                combine: e.combine,
                vertexTangents: e.normalMap && e.vertexTangents,
                vertexColors: e.vertexColors,
                vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.displacementMap),
                uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap),
                fog: !!m,
                useFog: e.fog,
                fogExp2: m && m.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: o,
                skinning: e.skinning && b > 0,
                maxBones: b,
                useVertexTexture: a,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: i.directional.length,
                numPointLights: i.point.length,
                numSpotLights: i.spot.length,
                numRectAreaLights: i.rectArea.length,
                numHemiLights: i.hemi.length,
                numDirLightShadows: i.directionalShadowMap.length,
                numPointLightShadows: i.pointShadowMap.length,
                numSpotLightShadows: i.spotShadowMap.length,
                numClippingPlanes: g,
                numClipIntersection: v,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && d.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: e.toneMapped ? t.toneMapping : Y,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === u,
                flipSided: e.side === h,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }
        ,
        this.getProgramCacheKey = function(e, n) {
            var i = [];
            if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader),
            i.push(e.vertexShader)),
            void 0 !== e.defines)
                for (var r in e.defines)
                    i.push(r),
                    i.push(e.defines[r]);
            for (var o = 0; o < d.length; o++)
                i.push(n[d[o]]);
            return i.push(e.onBeforeCompile.toString()),
            i.push(t.gammaOutput),
            i.push(t.gammaFactor),
            i.join()
        }
        ,
        this.acquireProgram = function(n, r, o, a) {
            for (var s, l = 0, c = i.length; l < c; l++) {
                var h = i[l];
                if (h.cacheKey === a) {
                    ++(s = h).usedTimes;
                    break
                }
            }
            return void 0 === s && (s = new ta(t,e,a,n,r,o),
            i.push(s)),
            s
        }
        ,
        this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = i.indexOf(t);
                i[e] = i[i.length - 1],
                i.pop(),
                t.destroy()
            }
        }
        ,
        this.programs = i
    }
    function na() {
        var t = new WeakMap;
        return {
            get: function(e) {
                var n = t.get(e);
                return void 0 === n && (n = {},
                t.set(e, n)),
                n
            },
            remove: function(e) {
                t.delete(e)
            },
            update: function(e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function ia(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function ra(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function oa() {
        var t = []
          , e = 0
          , n = []
          , i = []
          , r = {
            id: -1
        };
        function o(n, i, o, a, s, l) {
            var c = t[e];
            return void 0 === c ? (c = {
                id: n.id,
                object: n,
                geometry: i,
                material: o,
                program: o.program || r,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: l
            },
            t[e] = c) : (c.id = n.id,
            c.object = n,
            c.geometry = i,
            c.material = o,
            c.program = o.program || r,
            c.groupOrder = a,
            c.renderOrder = n.renderOrder,
            c.z = s,
            c.group = l),
            e++,
            c
        }
        return {
            opaque: n,
            transparent: i,
            init: function() {
                e = 0,
                n.length = 0,
                i.length = 0
            },
            push: function(t, e, r, a, s, l) {
                var c = o(t, e, r, a, s, l);
                (!0 === r.transparent ? i : n).push(c)
            },
            unshift: function(t, e, r, a, s, l) {
                var c = o(t, e, r, a, s, l);
                (!0 === r.transparent ? i : n).unshift(c)
            },
            sort: function() {
                n.length > 1 && n.sort(ia),
                i.length > 1 && i.sort(ra)
            }
        }
    }
    function aa() {
        var t = new WeakMap;
        function e(n) {
            var i = n.target;
            i.removeEventListener('dispose', e),
            t.delete(i)
        }
        return {
            get: function(n, i) {
                var r, o = t.get(n);
                return void 0 === o ? (r = new oa,
                t.set(n, new WeakMap),
                t.get(n).set(i, r),
                n.addEventListener('dispose', e)) : void 0 === (r = o.get(i)) && (r = new oa,
                o.set(i, r)),
                r
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function sa() {
        var t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id])
                    return t[e.id];
                var n;
                switch (e.type) {
                case 'DirectionalLight':
                    n = {
                        direction: new Oe,
                        color: new ai,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Te
                    };
                    break;
                case 'SpotLight':
                    n = {
                        position: new Oe,
                        direction: new Oe,
                        color: new ai,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Te
                    };
                    break;
                case 'PointLight':
                    n = {
                        position: new Oe,
                        color: new ai,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Te,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case 'HemisphereLight':
                    n = {
                        direction: new Oe,
                        skyColor: new ai,
                        groundColor: new ai
                    };
                    break;
                case 'RectAreaLight':
                    n = {
                        color: new ai,
                        position: new Oe,
                        halfWidth: new Oe,
                        halfHeight: new Oe
                    }
                }
                return t[e.id] = n,
                n
            }
        }
    }
    var la = 0;
    function ca(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }
    function ha() {
        for (var t = new sa, e = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        }, n = 0; n < 9; n++)
            e.probe.push(new Oe);
        var i = new Oe
          , r = new Ze
          , o = new Ze;
        return {
            setup: function(n, a, s) {
                for (var l = 0, c = 0, h = 0, u = 0; u < 9; u++)
                    e.probe[u].set(0, 0, 0);
                var p = 0
                  , d = 0
                  , f = 0
                  , m = 0
                  , g = 0
                  , v = 0
                  , y = 0
                  , x = 0
                  , b = s.matrixWorldInverse;
                n.sort(ca),
                u = 0;
                for (var _ = n.length; u < _; u++) {
                    var M = n[u]
                      , w = M.color
                      , S = M.intensity
                      , P = M.distance
                      , C = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                    if (M.isAmbientLight)
                        l += w.r * S,
                        c += w.g * S,
                        h += w.b * S;
                    else if (M.isLightProbe)
                        for (var A = 0; A < 9; A++)
                            e.probe[A].addScaledVector(M.sh.coefficients[A], S);
                    else if (M.isDirectionalLight) {
                        if ((T = t.get(M)).color.copy(M.color).multiplyScalar(M.intensity),
                        T.direction.setFromMatrixPosition(M.matrixWorld),
                        i.setFromMatrixPosition(M.target.matrixWorld),
                        T.direction.sub(i),
                        T.direction.transformDirection(b),
                        T.shadow = M.castShadow,
                        M.castShadow) {
                            var E = M.shadow;
                            T.shadowBias = E.bias,
                            T.shadowRadius = E.radius,
                            T.shadowMapSize = E.mapSize,
                            e.directionalShadowMap[p] = C,
                            e.directionalShadowMatrix[p] = M.shadow.matrix,
                            v++
                        }
                        e.directional[p] = T,
                        p++
                    } else if (M.isSpotLight) {
                        if ((T = t.get(M)).position.setFromMatrixPosition(M.matrixWorld),
                        T.position.applyMatrix4(b),
                        T.color.copy(w).multiplyScalar(S),
                        T.distance = P,
                        T.direction.setFromMatrixPosition(M.matrixWorld),
                        i.setFromMatrixPosition(M.target.matrixWorld),
                        T.direction.sub(i),
                        T.direction.transformDirection(b),
                        T.coneCos = Math.cos(M.angle),
                        T.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)),
                        T.decay = M.decay,
                        T.shadow = M.castShadow,
                        M.castShadow) {
                            E = M.shadow;
                            T.shadowBias = E.bias,
                            T.shadowRadius = E.radius,
                            T.shadowMapSize = E.mapSize,
                            e.spotShadowMap[f] = C,
                            e.spotShadowMatrix[f] = M.shadow.matrix,
                            x++
                        }
                        e.spot[f] = T,
                        f++
                    } else if (M.isRectAreaLight) {
                        (T = t.get(M)).color.copy(w).multiplyScalar(S),
                        T.position.setFromMatrixPosition(M.matrixWorld),
                        T.position.applyMatrix4(b),
                        o.identity(),
                        r.copy(M.matrixWorld),
                        r.premultiply(b),
                        o.extractRotation(r),
                        T.halfWidth.set(.5 * M.width, 0, 0),
                        T.halfHeight.set(0, .5 * M.height, 0),
                        T.halfWidth.applyMatrix4(o),
                        T.halfHeight.applyMatrix4(o),
                        e.rectArea[m] = T,
                        m++
                    } else if (M.isPointLight) {
                        if ((T = t.get(M)).position.setFromMatrixPosition(M.matrixWorld),
                        T.position.applyMatrix4(b),
                        T.color.copy(M.color).multiplyScalar(M.intensity),
                        T.distance = M.distance,
                        T.decay = M.decay,
                        T.shadow = M.castShadow,
                        M.castShadow) {
                            E = M.shadow;
                            T.shadowBias = E.bias,
                            T.shadowRadius = E.radius,
                            T.shadowMapSize = E.mapSize,
                            T.shadowCameraNear = E.camera.near,
                            T.shadowCameraFar = E.camera.far,
                            e.pointShadowMap[d] = C,
                            e.pointShadowMatrix[d] = M.shadow.matrix,
                            y++
                        }
                        e.point[d] = T,
                        d++
                    } else if (M.isHemisphereLight) {
                        var T;
                        (T = t.get(M)).direction.setFromMatrixPosition(M.matrixWorld),
                        T.direction.transformDirection(b),
                        T.direction.normalize(),
                        T.skyColor.copy(M.color).multiplyScalar(S),
                        T.groundColor.copy(M.groundColor).multiplyScalar(S),
                        e.hemi[g] = T,
                        g++
                    }
                }
                e.ambient[0] = l,
                e.ambient[1] = c,
                e.ambient[2] = h;
                var L = e.hash;
                L.directionalLength === p && L.pointLength === d && L.spotLength === f && L.rectAreaLength === m && L.hemiLength === g && L.numDirectionalShadows === v && L.numPointShadows === y && L.numSpotShadows === x || (e.directional.length = p,
                e.spot.length = f,
                e.rectArea.length = m,
                e.point.length = d,
                e.hemi.length = g,
                e.directionalShadowMap.length = v,
                e.pointShadowMap.length = y,
                e.spotShadowMap.length = x,
                e.directionalShadowMatrix.length = v,
                e.pointShadowMatrix.length = y,
                e.spotShadowMatrix.length = x,
                L.directionalLength = p,
                L.pointLength = d,
                L.spotLength = f,
                L.rectAreaLength = m,
                L.hemiLength = g,
                L.numDirectionalShadows = v,
                L.numPointShadows = y,
                L.numSpotShadows = x,
                e.version = la++)
            },
            state: e
        }
    }
    function ua() {
        var t = new ha
          , e = []
          , n = [];
        return {
            init: function() {
                e.length = 0,
                n.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: n,
                lights: t
            },
            setupLights: function(i) {
                t.setup(e, n, i)
            },
            pushLight: function(t) {
                e.push(t)
            },
            pushShadow: function(t) {
                n.push(t)
            }
        }
    }
    function pa() {
        var t = new WeakMap;
        function e(n) {
            var i = n.target;
            i.removeEventListener('dispose', e),
            t.delete(i)
        }
        return {
            get: function(n, i) {
                var r;
                return !1 === t.has(n) ? (r = new ua,
                t.set(n, new WeakMap),
                t.get(n).set(i, r),
                n.addEventListener('dispose', e)) : !1 === t.get(n).has(i) ? (r = new ua,
                t.get(n).set(i, r)) : r = t.get(n).get(i),
                r
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function da(t) {
        pi.call(this),
        this.type = 'MeshDepthMaterial',
        this.depthPacking = ye,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues(t)
    }
    function fa(t) {
        pi.call(this),
        this.type = 'MeshDistanceMaterial',
        this.referencePosition = new Oe,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues(t)
    }
    da.prototype = Object.create(pi.prototype),
    da.prototype.constructor = da,
    da.prototype.isMeshDepthMaterial = !0,
    da.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.depthPacking = t.depthPacking,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
    ,
    fa.prototype = Object.create(pi.prototype),
    fa.prototype.constructor = fa,
    fa.prototype.isMeshDistanceMaterial = !0,
    fa.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
    ;
    var ma = 'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpack2HalfToRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
      , ga = 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}';
    function va(t, e, n) {
        var i = new _r
          , r = new Te
          , o = new Te
          , s = new Ue
          , p = []
          , d = []
          , f = {}
          , g = {
            0: h,
            1: c,
            2: u
        }
          , v = new ur({
            defines: {
                SAMPLE_RATE: .25,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Te
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: ga,
            fragmentShader: ma
        })
          , y = v.clone();
        y.defines.HORIZONAL_PASS = 1;
        var x = new Oi;
        x.setAttribute('position', new fi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        var b = new Ki(x,v)
          , _ = this;
        function M(n, i) {
            var r = e.update(b);
            v.uniforms.shadow_pass.value = n.map.texture,
            v.uniforms.resolution.value = n.mapSize,
            v.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, v, b, null),
            y.uniforms.shadow_pass.value = n.mapPass.texture,
            y.uniforms.resolution.value = n.mapSize,
            y.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, y, b, null)
        }
        function w(t, e, n) {
            var i = t << 0 | e << 1 | n << 2
              , r = p[i];
            return void 0 === r && (r = new da({
                depthPacking: xe,
                morphTargets: t,
                skinning: e
            }),
            p[i] = r),
            r
        }
        function S(t, e, n) {
            var i = t << 0 | e << 1 | n << 2
              , r = d[i];
            return void 0 === r && (r = new fa({
                morphTargets: t,
                skinning: e
            }),
            d[i] = r),
            r
        }
        function P(e, n, i, r, o, a) {
            var s = e.geometry
              , c = null
              , h = w
              , u = e.customDepthMaterial;
            if (!0 === i.isPointLight && (h = S,
            u = e.customDistanceMaterial),
            void 0 === u) {
                var p = !1;
                !0 === n.morphTargets && (!0 === s.isBufferGeometry ? p = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : !0 === s.isGeometry && (p = s.morphTargets && s.morphTargets.length > 0));
                var d = !1;
                !0 === e.isSkinnedMesh && !0 === n.skinning && (d = !0),
                c = h(p, d, !0 === e.isInstancedMesh)
            } else
                c = u;
            if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                var m = c.uuid
                  , v = n.uuid
                  , y = f[m];
                void 0 === y && (y = {},
                f[m] = y);
                var x = y[v];
                void 0 === x && (x = c.clone(),
                y[v] = x),
                c = x
            }
            return c.visible = n.visible,
            c.wireframe = n.wireframe,
            c.side = a === l ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : g[n.side],
            c.clipShadows = n.clipShadows,
            c.clippingPlanes = n.clippingPlanes,
            c.clipIntersection = n.clipIntersection,
            c.wireframeLinewidth = n.wireframeLinewidth,
            c.linewidth = n.linewidth,
            !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
            c.nearDistance = r,
            c.farDistance = o),
            c
        }
        function C(n, r, o, a, s) {
            if (!1 !== n.visible) {
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === l) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    var c = e.update(n)
                      , h = n.material;
                    if (Array.isArray(h))
                        for (var u = c.groups, p = 0, d = u.length; p < d; p++) {
                            var f = u[p]
                              , m = h[f.materialIndex];
                            if (m && m.visible) {
                                var g = P(n, m, a, o.near, o.far, s);
                                t.renderBufferDirect(o, null, c, g, n, f)
                            }
                        }
                    else if (h.visible) {
                        g = P(n, h, a, o.near, o.far, s);
                        t.renderBufferDirect(o, null, c, g, n, null)
                    }
                }
                for (var v = n.children, y = 0, x = v.length; y < x; y++)
                    C(v[y], r, o, a, s)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = a,
        this.render = function(e, a, c) {
            if (!1 !== _.enabled && (!1 !== _.autoUpdate || !1 !== _.needsUpdate) && 0 !== e.length) {
                var h = t.getRenderTarget()
                  , u = t.getActiveCubeFace()
                  , p = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(m),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                for (var f = 0, g = e.length; f < g; f++) {
                    var v = e[f]
                      , y = v.shadow;
                    if (void 0 !== y) {
                        r.copy(y.mapSize);
                        var x = y.getFrameExtents();
                        if (r.multiply(x),
                        o.copy(y.mapSize),
                        (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / x.x),
                        r.x = o.x * x.x,
                        y.mapSize.x = o.x),
                        r.y > n && (o.y = Math.floor(n / x.y),
                        r.y = o.y * x.y,
                        y.mapSize.y = o.y)),
                        null === y.map && !y.isPointLightShadow && this.type === l) {
                            var b = {
                                minFilter: dt,
                                magFilter: dt,
                                format: Lt
                            };
                            y.map = new Be(r.x,r.y,b),
                            y.map.texture.name = v.name + '.shadowMap',
                            y.mapPass = new Be(r.x,r.y,b),
                            y.camera.updateProjectionMatrix()
                        }
                        if (null === y.map) {
                            b = {
                                minFilter: ht,
                                magFilter: ht,
                                format: Lt
                            };
                            y.map = new Be(r.x,r.y,b),
                            y.map.texture.name = v.name + '.shadowMap',
                            y.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(y.map),
                        t.clear();
                        for (var w = y.getViewportCount(), S = 0; S < w; S++) {
                            var P = y.getViewport(S);
                            s.set(o.x * P.x, o.y * P.y, o.x * P.z, o.y * P.w),
                            d.viewport(s),
                            y.updateMatrices(v, S),
                            i = y.getFrustum(),
                            C(a, c, y.camera, v, this.type)
                        }
                        y.isPointLightShadow || this.type !== l || M(y, c)
                    }
                }
                _.needsUpdate = !1,
                t.setRenderTarget(h, u, p)
            }
        }
    }
    function ya(t, e, n) {
        var a = n.isWebGL2;
        var s = new function() {
            var e = !1
              , n = new Ue
              , i = null
              , r = new Ue(0,0,0,0);
            return {
                setMask: function(n) {
                    i === n || e || (t.colorMask(n, n, n, n),
                    i = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, i, o, a, s) {
                    !0 === s && (e *= a,
                    i *= a,
                    o *= a),
                    n.set(e, i, o, a),
                    !1 === r.equals(n) && (t.clearColor(e, i, o, a),
                    r.copy(n))
                },
                reset: function() {
                    e = !1,
                    i = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , l = new function() {
            var e = !1
              , n = null
              , i = null
              , r = null;
            return {
                setTest: function(t) {
                    t ? xt(2929) : bt(2929)
                },
                setMask: function(i) {
                    n === i || e || (t.depthMask(i),
                    n = i)
                },
                setFunc: function(e) {
                    if (i !== e) {
                        if (e)
                            switch (e) {
                            case F:
                                t.depthFunc(512);
                                break;
                            case z:
                                t.depthFunc(519);
                                break;
                            case R:
                                t.depthFunc(513);
                                break;
                            case U:
                                t.depthFunc(515);
                                break;
                            case B:
                                t.depthFunc(514);
                                break;
                            case V:
                                t.depthFunc(518);
                                break;
                            case G:
                                t.depthFunc(516);
                                break;
                            case H:
                                t.depthFunc(517);
                                break;
                            default:
                                t.depthFunc(515)
                            }
                        else
                            t.depthFunc(515);
                        i = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    r !== e && (t.clearDepth(e),
                    r = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null
                }
            }
        }
          , c = new function() {
            var e = !1
              , n = null
              , i = null
              , r = null
              , o = null
              , a = null
              , s = null
              , l = null
              , c = null;
            return {
                setTest: function(t) {
                    e || (t ? xt(2960) : bt(2960))
                },
                setMask: function(i) {
                    n === i || e || (t.stencilMask(i),
                    n = i)
                },
                setFunc: function(e, n, a) {
                    i === e && r === n && o === a || (t.stencilFunc(e, n, a),
                    i = e,
                    r = n,
                    o = a)
                },
                setOp: function(e, n, i) {
                    a === e && s === n && l === i || (t.stencilOp(e, n, i),
                    a = e,
                    s = n,
                    l = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e),
                    c = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null,
                    o = null,
                    a = null,
                    s = null,
                    l = null,
                    c = null
                }
            }
        }
          , p = t.getParameter(34921)
          , d = new Uint8Array(p)
          , f = new Uint8Array(p)
          , W = new Uint8Array(p)
          , X = {}
          , q = null
          , Y = null
          , J = null
          , Z = null
          , K = null
          , Q = null
          , $ = null
          , tt = null
          , et = null
          , nt = !1
          , it = null
          , rt = null
          , ot = null
          , at = null
          , st = null
          , lt = t.getParameter(35661)
          , ct = !1
          , ht = 0
          , ut = t.getParameter(7938);
        -1 !== ut.indexOf('WebGL') ? (ht = parseFloat(/^WebGL\ ([0-9])/.exec(ut)[1]),
        ct = ht >= 1) : -1 !== ut.indexOf('OpenGL ES') && (ht = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ut)[1]),
        ct = ht >= 2);
        var pt = null
          , dt = {}
          , ft = new Ue
          , mt = new Ue;
        function gt(e, n, i) {
            var r = new Uint8Array(4)
              , o = t.createTexture();
            t.bindTexture(e, o),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
            for (var a = 0; a < i; a++)
                t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }
        var vt = {};
        function yt(n, i) {
            (d[n] = 1,
            0 === f[n] && (t.enableVertexAttribArray(n),
            f[n] = 1),
            W[n] !== i) && ((a ? t : e.get('ANGLE_instanced_arrays'))[a ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](n, i),
            W[n] = i)
        }
        function xt(e) {
            !0 !== X[e] && (t.enable(e),
            X[e] = !0)
        }
        function bt(e) {
            !1 !== X[e] && (t.disable(e),
            X[e] = !1)
        }
        vt[3553] = gt(3553, 3553, 1),
        vt[34067] = gt(34067, 34069, 6),
        s.setClear(0, 0, 0, 1),
        l.setClear(1),
        c.setClear(0),
        xt(2929),
        l.setFunc(U),
        Pt(!1),
        Ct(r),
        xt(2884),
        St(m);
        var _t = {
            [_]: 32774,
            [M]: 32778,
            [w]: 32779
        };
        if (a)
            _t[S] = 32775,
            _t[P] = 32776;
        else {
            var Mt = e.get('EXT_blend_minmax');
            null !== Mt && (_t[S] = Mt.MIN_EXT,
            _t[P] = Mt.MAX_EXT)
        }
        var wt = {
            [C]: 0,
            [A]: 1,
            [E]: 768,
            [L]: 770,
            [k]: 776,
            [j]: 774,
            [I]: 772,
            [T]: 769,
            [D]: 771,
            [N]: 775,
            [O]: 773
        };
        function St(e, n, i, r, o, a, s, l) {
            if (e !== m) {
                if (Y || (xt(3042),
                Y = !0),
                e === b)
                    o = o || n,
                    a = a || i,
                    s = s || r,
                    n === Z && o === $ || (t.blendEquationSeparate(_t[n], _t[o]),
                    Z = n,
                    $ = o),
                    i === K && r === Q && a === tt && s === et || (t.blendFuncSeparate(wt[i], wt[r], wt[a], wt[s]),
                    K = i,
                    Q = r,
                    tt = a,
                    et = s),
                    J = e,
                    nt = null;
                else if (e !== J || l !== nt) {
                    if (Z === _ && $ === _ || (t.blendEquation(32774),
                    Z = _,
                    $ = _),
                    l)
                        switch (e) {
                        case g:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case v:
                            t.blendFunc(1, 1);
                            break;
                        case y:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case x:
                            t.blendFuncSeparate(0, 768, 0, 770)
                        }
                    else
                        switch (e) {
                        case g:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case v:
                            t.blendFunc(770, 1);
                            break;
                        case y:
                            t.blendFunc(0, 769);
                            break;
                        case x:
                            t.blendFunc(0, 768)
                        }
                    K = null,
                    Q = null,
                    tt = null,
                    et = null,
                    J = e,
                    nt = l
                }
            } else
                Y && (bt(3042),
                Y = !1)
        }
        function Pt(e) {
            it !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
            it = e)
        }
        function Ct(e) {
            e !== i ? (xt(2884),
            e !== rt && (e === r ? t.cullFace(1029) : e === o ? t.cullFace(1028) : t.cullFace(1032))) : bt(2884),
            rt = e
        }
        function At(e, n, i) {
            e ? (xt(32823),
            at === n && st === i || (t.polygonOffset(n, i),
            at = n,
            st = i)) : bt(32823)
        }
        function Et(e) {
            void 0 === e && (e = 33984 + lt - 1),
            pt !== e && (t.activeTexture(e),
            pt = e)
        }
        return {
            buffers: {
                color: s,
                depth: l,
                stencil: c
            },
            initAttributes: function() {
                for (var t = 0, e = d.length; t < e; t++)
                    d[t] = 0
            },
            enableAttribute: function(t) {
                yt(t, 0)
            },
            enableAttributeAndDivisor: yt,
            disableUnusedAttributes: function() {
                for (var e = 0, n = f.length; e !== n; ++e)
                    f[e] !== d[e] && (t.disableVertexAttribArray(e),
                    f[e] = 0)
            },
            enable: xt,
            disable: bt,
            useProgram: function(e) {
                return q !== e && (t.useProgram(e),
                q = e,
                !0)
            },
            setBlending: St,
            setMaterial: function(t, e) {
                t.side === u ? bt(2884) : xt(2884);
                var n = t.side === h;
                e && (n = !n),
                Pt(n),
                t.blending === g && !1 === t.transparent ? St(m) : St(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                l.setFunc(t.depthFunc),
                l.setTest(t.depthTest),
                l.setMask(t.depthWrite),
                s.setMask(t.colorWrite);
                var i = t.stencilWrite;
                c.setTest(i),
                i && (c.setMask(t.stencilWriteMask),
                c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                At(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: Pt,
            setCullFace: Ct,
            setLineWidth: function(e) {
                e !== ot && (ct && t.lineWidth(e),
                ot = e)
            },
            setPolygonOffset: At,
            setScissorTest: function(t) {
                t ? xt(3089) : bt(3089)
            },
            activeTexture: Et,
            bindTexture: function(e, n) {
                null === pt && Et();
                var i = dt[pt];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                dt[pt] = i),
                i.type === e && i.texture === n || (t.bindTexture(e, n || vt[e]),
                i.type = e,
                i.texture = n)
            },
            unbindTexture: function() {
                var e = dt[pt];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                e.type = void 0,
                e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {}
            },
            texImage2D: function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {}
            },
            texImage3D: function() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {}
            },
            scissor: function(e) {
                !1 === ft.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                ft.copy(e))
            },
            viewport: function(e) {
                !1 === mt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                mt.copy(e))
            },
            reset: function() {
                for (var e = 0; e < f.length; e++)
                    1 === f[e] && (t.disableVertexAttribArray(e),
                    f[e] = 0);
                X = {},
                pt = null,
                dt = {},
                q = null,
                J = null,
                it = null,
                rt = null,
                s.reset(),
                l.reset(),
                c.reset()
            }
        }
    }
    function xa(t, e, n, i, r, o, a) {
        var s, l = r.isWebGL2, c = (r.maxTextures,
        r.maxCubemapSize), h = r.maxTextureSize, u = r.maxSamples, p = new WeakMap, d = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext('2d');
        function f(t, e) {
            return d ? new OffscreenCanvas(t,e) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
        }
        function m(t, e, n, i) {
            var r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e) {
                if ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement || 'undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || 'undefined' != typeof ImageBitmap && t instanceof ImageBitmap) {
                    var o = e ? Ee.floorPowerOfTwo : Math.floor
                      , a = o(r * t.width)
                      , l = o(r * t.height);
                    void 0 === s && (s = f(a, l));
                    var c = n ? f(a, l) : s;
                    return c.width = a,
                    c.height = l,
                    c.getContext('2d').drawImage(t, 0, 0, a, l),
                    c
                }
                return t
            }
            return t
        }
        function g(t) {
            return Ee.isPowerOfTwo(t.width) && Ee.isPowerOfTwo(t.height)
        }
        function v(t, e) {
            return t.generateMipmaps && e && t.minFilter !== ht && t.minFilter !== dt
        }
        function y(e, n, r, o) {
            t.generateMipmap(e),
            i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }
        function x(t, n) {
            if (!1 === l)
                return t;
            var i = t;
            return 6403 === t && (5126 === n && (i = 33326),
            5131 === n && (i = 33325),
            5121 === n && (i = 33321)),
            6407 === t && (5126 === n && (i = 34837),
            5131 === n && (i = 34843),
            5121 === n && (i = 32849)),
            6408 === t && (5126 === n && (i = 34836),
            5131 === n && (i = 34842),
            5121 === n && (i = 32856)),
            33325 !== i && 33326 !== i && 34842 !== i && 34836 !== i || e.get('EXT_color_buffer_float'),
            i
        }
        function b(t) {
            return t === ht || t === ut || t === pt ? 9728 : 9729
        }
        function _(e) {
            var n = e.target;
            n.removeEventListener('dispose', _),
            function(e) {
                var n = i.get(e);
                if (void 0 === n.__webglInit)
                    return;
                t.deleteTexture(n.__webglTexture),
                i.remove(e)
            }(n),
            n.isVideoTexture && p.delete(n),
            a.memory.textures--
        }
        function M(e) {
            var n = e.target;
            n.removeEventListener('dispose', M),
            function(e) {
                var n = i.get(e)
                  , r = i.get(e.texture);
                if (!e)
                    return;
                void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLRenderTargetCube)
                    for (var o = 0; o < 6; o++)
                        t.deleteFramebuffer(n.__webglFramebuffer[o]),
                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                else
                    t.deleteFramebuffer(n.__webglFramebuffer),
                    n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                if (e.isWebGLMultiviewRenderTarget) {
                    t.deleteTexture(n.__webglColorTexture),
                    t.deleteTexture(n.__webglDepthStencilTexture),
                    a.memory.textures -= 2;
                    o = 0;
                    for (var s = n.__webglViewFramebuffers.length; o < s; o++)
                        t.deleteFramebuffer(n.__webglViewFramebuffers[o])
                }
                i.remove(e.texture),
                i.remove(e)
            }(n),
            a.memory.textures--
        }
        var w = 0;
        function S(t, e) {
            var r = i.get(t);
            if (t.isVideoTexture && function(t) {
                var e = a.render.frame;
                p.get(t) !== e && (p.set(t, e),
                t.update())
            }(t),
            t.version > 0 && r.__version !== t.version) {
                var o = t.image;
                if (void 0 === o)
                    ;
                else if (!1 !== o.complete)
                    return void D(r, t, e)
            }
            n.activeTexture(33984 + e),
            n.bindTexture(3553, r.__webglTexture)
        }
        function P(e, r) {
            if (6 === e.image.length) {
                var a = i.get(e);
                if (e.version > 0 && a.__version !== e.version) {
                    L(a, e),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, a.__webglTexture),
                    t.pixelStorei(37440, e.flipY);
                    for (var s = e && e.isCompressedTexture, h = e.image[0] && e.image[0].isDataTexture, u = [], p = 0; p < 6; p++)
                        u[p] = s || h ? h ? e.image[p].image : e.image[p] : m(e.image[p], !1, !0, c);
                    var d, f = u[0], b = g(f) || l, _ = o.convert(e.format), M = o.convert(e.type), w = x(_, M);
                    if (T(34067, e, b),
                    s) {
                        for (p = 0; p < 6; p++) {
                            d = u[p].mipmaps;
                            for (var S = 0; S < d.length; S++) {
                                var P = d[S];
                                e.format !== Lt && e.format !== Tt ? null !== _ && n.compressedTexImage2D(34069 + p, S, w, P.width, P.height, 0, P.data) : n.texImage2D(34069 + p, S, w, P.width, P.height, 0, _, M, P.data)
                            }
                        }
                        a.__maxMipLevel = d.length - 1
                    } else {
                        d = e.mipmaps;
                        for (p = 0; p < 6; p++)
                            if (h) {
                                n.texImage2D(34069 + p, 0, w, u[p].width, u[p].height, 0, _, M, u[p].data);
                                for (S = 0; S < d.length; S++) {
                                    var C = (P = d[S]).image[p].image;
                                    n.texImage2D(34069 + p, S + 1, w, C.width, C.height, 0, _, M, C.data)
                                }
                            } else {
                                n.texImage2D(34069 + p, 0, w, _, M, u[p]);
                                for (S = 0; S < d.length; S++) {
                                    P = d[S];
                                    n.texImage2D(34069 + p, S + 1, w, _, M, P.image[p])
                                }
                            }
                        a.__maxMipLevel = d.length
                    }
                    v(e, b) && y(34067, e, f.width, f.height),
                    a.__version = e.version,
                    e.onUpdate && e.onUpdate(e)
                } else
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, a.__webglTexture)
            }
        }
        function C(t, e) {
            n.activeTexture(33984 + e),
            n.bindTexture(34067, i.get(t).__webglTexture)
        }
        var A = {
            [st]: 10497,
            [lt]: 33071,
            [ct]: 33648
        }
          , E = {
            [ht]: 9728,
            [ut]: 9984,
            [pt]: 9986,
            [dt]: 9729,
            [ft]: 9985,
            [mt]: 9987
        };
        function T(n, o, a) {
            a ? (t.texParameteri(n, 10242, A[o.wrapS]),
            t.texParameteri(n, 10243, A[o.wrapT]),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[o.wrapR]),
            t.texParameteri(n, 10240, E[o.magFilter]),
            t.texParameteri(n, 10241, E[o.minFilter])) : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
            o.wrapS !== lt || o.wrapT,
            t.texParameteri(n, 10240, b(o.magFilter)),
            t.texParameteri(n, 10241, b(o.minFilter)),
            o.minFilter !== ht && o.minFilter);
            var s = e.get('EXT_texture_filter_anisotropic');
            if (s) {
                if (o.type === Mt && null === e.get('OES_texture_float_linear'))
                    return;
                if (o.type === wt && null === (l || e.get('OES_texture_half_float_linear')))
                    return;
                (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
                i.get(o).__currentAnisotropy = o.anisotropy)
            }
        }
        function L(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0,
            n.addEventListener('dispose', _),
            e.__webglTexture = t.createTexture(),
            a.memory.textures++)
        }
        function D(e, i, r) {
            var a = 3553;
            i.isDataTexture2DArray && (a = 35866),
            i.isDataTexture3D && (a = 32879),
            L(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(a, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment);
            var s = function(t) {
                return !l && (t.wrapS !== lt || t.wrapT !== lt || t.minFilter !== ht && t.minFilter !== dt)
            }(i) && !1 === g(i.image)
              , c = m(i.image, s, !1, h)
              , u = g(c) || l
              , p = o.convert(i.format)
              , d = o.convert(i.type)
              , f = x(p, d);
            T(a, i, u);
            var b, _ = i.mipmaps;
            if (i.isDepthTexture) {
                if (f = 6402,
                i.type === Mt) {
                    if (!1 === l)
                        throw new Error('Float Depth Texture only supported in WebGL2.0');
                    f = 36012
                } else
                    l && (f = 33189);
                i.format === Ot && 6402 === f && i.type !== xt && i.type !== _t && (i.type = xt,
                d = o.convert(i.type)),
                i.format === jt && (f = 34041,
                i.type !== At && (i.type = At,
                d = o.convert(i.type))),
                n.texImage2D(3553, 0, f, c.width, c.height, 0, p, d, null)
            } else if (i.isDataTexture)
                if (_.length > 0 && u) {
                    for (var M = 0, w = _.length; M < w; M++)
                        b = _[M],
                        n.texImage2D(3553, M, f, b.width, b.height, 0, p, d, b.data);
                    i.generateMipmaps = !1,
                    e.__maxMipLevel = _.length - 1
                } else
                    n.texImage2D(3553, 0, f, c.width, c.height, 0, p, d, c.data),
                    e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (M = 0,
                w = _.length; M < w; M++)
                    b = _[M],
                    i.format !== Lt && i.format !== Tt ? null !== p && n.compressedTexImage2D(3553, M, f, b.width, b.height, 0, b.data) : n.texImage2D(3553, M, f, b.width, b.height, 0, p, d, b.data);
                e.__maxMipLevel = _.length - 1
            } else if (i.isDataTexture2DArray)
                n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, p, d, c.data),
                e.__maxMipLevel = 0;
            else if (i.isDataTexture3D)
                n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, p, d, c.data),
                e.__maxMipLevel = 0;
            else if (_.length > 0 && u) {
                for (M = 0,
                w = _.length; M < w; M++)
                    b = _[M],
                    n.texImage2D(3553, M, f, p, d, b);
                i.generateMipmaps = !1,
                e.__maxMipLevel = _.length - 1
            } else
                n.texImage2D(3553, 0, f, p, d, c),
                e.__maxMipLevel = 0;
            v(i, u) && y(3553, i, c.width, c.height),
            e.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function I(e, r, a, s) {
            var l = o.convert(r.texture.format)
              , c = o.convert(r.texture.type)
              , h = x(l, c);
            n.texImage2D(s, 0, h, r.width, r.height, 0, l, c, null),
            t.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, a, s, i.get(r.texture).__webglTexture, 0),
            t.bindFramebuffer(36160, null)
        }
        function O(e, n, i) {
            if (t.bindRenderbuffer(36161, e),
            n.depthBuffer && !n.stencilBuffer) {
                if (i) {
                    var r = N(n);
                    t.renderbufferStorageMultisample(36161, r, 33189, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, 33189, n.width, n.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    r = N(n);
                    t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, 34041, n.width, n.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                var a = x(o.convert(n.texture.format), o.convert(n.texture.type));
                if (i) {
                    r = N(n);
                    t.renderbufferStorageMultisample(36161, r, a, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, a, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
        }
        function j(e) {
            var n = i.get(e)
              , r = !0 === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (r)
                    throw new Error('target.depthTexture not supported in Cube render targets');
                !function(e, n) {
                    if (n && n.isWebGLRenderTargetCube)
                        throw new Error('Depth Texture with cube render targets is not supported');
                    if (t.bindFramebuffer(36160, e),
                    !n.depthTexture || !n.depthTexture.isDepthTexture)
                        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                    n.depthTexture.image.height = n.height,
                    n.depthTexture.needsUpdate = !0),
                    S(n.depthTexture, 0);
                    var r = i.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === Ot)
                        t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (n.depthTexture.format !== jt)
                            throw new Error('Unknown depthTexture format');
                        t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++)
                    t.bindFramebuffer(36160, n.__webglFramebuffer[o]),
                    n.__webglDepthbuffer[o] = t.createRenderbuffer(),
                    O(n.__webglDepthbuffer[o], e)
            } else
                t.bindFramebuffer(36160, n.__webglFramebuffer),
                n.__webglDepthbuffer = t.createRenderbuffer(),
                O(n.__webglDepthbuffer, e);
            t.bindFramebuffer(36160, null)
        }
        function N(t) {
            return l && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
        }
        var k = !1
          , F = !1;
        this.allocateTextureUnit = function() {
            var t = w;
            return w += 1,
            t
        }
        ,
        this.resetTextureUnits = function() {
            w = 0
        }
        ,
        this.setTexture2D = S,
        this.setTexture2DArray = function(t, e) {
            var r = i.get(t);
            t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(t, e) {
            var r = i.get(t);
            t.version > 0 && r.__version !== t.version ? D(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = P,
        this.setTextureCubeDynamic = C,
        this.setupRenderTarget = function(r) {
            var s = i.get(r)
              , c = i.get(r.texture);
            r.addEventListener('dispose', M),
            c.__webglTexture = t.createTexture(),
            a.memory.textures++;
            var h = !0 === r.isWebGLRenderTargetCube
              , u = !0 === r.isWebGLMultisampleRenderTarget
              , p = !0 === r.isWebGLMultiviewRenderTarget
              , d = g(r) || l;
            if (h) {
                s.__webglFramebuffer = [];
                for (var f = 0; f < 6; f++)
                    s.__webglFramebuffer[f] = t.createFramebuffer()
            } else if (s.__webglFramebuffer = t.createFramebuffer(),
            u) {
                if (l) {
                    s.__webglMultisampledFramebuffer = t.createFramebuffer(),
                    s.__webglColorRenderbuffer = t.createRenderbuffer(),
                    t.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                    var m = x(o.convert(r.texture.format), o.convert(r.texture.type))
                      , b = N(r);
                    t.renderbufferStorageMultisample(36161, b, m, r.width, r.height),
                    t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer),
                    t.bindRenderbuffer(36161, null),
                    r.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(),
                    O(s.__webglDepthRenderbuffer, r, !0)),
                    t.bindFramebuffer(36160, null)
                }
            } else if (p) {
                var _ = r.width
                  , w = r.height
                  , S = r.numViews;
                t.bindFramebuffer(36160, s.__webglFramebuffer);
                var P = e.get('OVR_multiview2');
                a.memory.textures += 2;
                var C = t.createTexture();
                t.bindTexture(35866, C),
                t.texParameteri(35866, 10240, 9728),
                t.texParameteri(35866, 10241, 9728),
                t.texImage3D(35866, 0, 32856, _, w, S, 0, 6408, 5121, null),
                P.framebufferTextureMultiviewOVR(36160, 36064, C, 0, 0, S);
                var A = t.createTexture();
                t.bindTexture(35866, A),
                t.texParameteri(35866, 10240, 9728),
                t.texParameteri(35866, 10241, 9728),
                t.texImage3D(35866, 0, 35056, _, w, S, 0, 34041, 34042, null),
                P.framebufferTextureMultiviewOVR(36160, 33306, A, 0, 0, S);
                var E = new Array(S);
                for (f = 0; f < S; ++f)
                    E[f] = t.createFramebuffer(),
                    t.bindFramebuffer(36160, E[f]),
                    t.framebufferTextureLayer(36160, 36064, C, 0, f);
                s.__webglColorTexture = C,
                s.__webglDepthStencilTexture = A,
                s.__webglViewFramebuffers = E,
                t.bindFramebuffer(36160, null),
                t.bindTexture(35866, null)
            }
            if (h) {
                n.bindTexture(34067, c.__webglTexture),
                T(34067, r.texture, d);
                for (f = 0; f < 6; f++)
                    I(s.__webglFramebuffer[f], r, 36064, 34069 + f);
                v(r.texture, d) && y(34067, r.texture, r.width, r.height),
                n.bindTexture(34067, null)
            } else
                p || (n.bindTexture(3553, c.__webglTexture),
                T(3553, r.texture, d),
                I(s.__webglFramebuffer, r, 36064, 3553),
                v(r.texture, d) && y(3553, r.texture, r.width, r.height),
                n.bindTexture(3553, null));
            r.depthBuffer && j(r)
        }
        ,
        this.updateRenderTargetMipmap = function(t) {
            var e = t.texture;
            if (v(e, g(t) || l)) {
                var r = t.isWebGLRenderTargetCube ? 34067 : 3553
                  , o = i.get(e).__webglTexture;
                n.bindTexture(r, o),
                y(r, e, t.width, t.height),
                n.bindTexture(r, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(e) {
            if (e.isWebGLMultisampleRenderTarget && l) {
                var n = i.get(e);
                t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, n.__webglFramebuffer);
                var r = e.width
                  , o = e.height
                  , a = 16384;
                e.depthBuffer && (a |= 256),
                e.stencilBuffer && (a |= 1024),
                t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, 9728)
            }
        }
        ,
        this.safeSetTexture2D = function(t, e) {
            t && t.isWebGLRenderTarget && (!1 === k && (k = !0),
            t = t.texture),
            S(t, e)
        }
        ,
        this.safeSetTextureCube = function(t, e) {
            t && t.isWebGLRenderTargetCube && (!1 === F && (F = !0),
            t = t.texture),
            t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? P(t, e) : C(t, e)
        }
    }
    function ba(t, e, n) {
        var i = n.isWebGL2;
        return {
            convert: function(t) {
                var n;
                if (t === gt)
                    return 5121;
                if (t === St)
                    return 32819;
                if (t === Pt)
                    return 32820;
                if (t === Ct)
                    return 33635;
                if (t === vt)
                    return 5120;
                if (t === yt)
                    return 5122;
                if (t === xt)
                    return 5123;
                if (t === bt)
                    return 5124;
                if (t === _t)
                    return 5125;
                if (t === Mt)
                    return 5126;
                if (t === wt)
                    return i ? 5131 : null !== (n = e.get('OES_texture_half_float')) ? n.HALF_FLOAT_OES : null;
                if (t === Et)
                    return 6406;
                if (t === Tt)
                    return 6407;
                if (t === Lt)
                    return 6408;
                if (t === Dt)
                    return 6409;
                if (t === It)
                    return 6410;
                if (t === Ot)
                    return 6402;
                if (t === jt)
                    return 34041;
                if (t === Nt)
                    return 6403;
                if (t === kt || t === Ft || t === zt || t === Rt) {
                    if (null === (n = e.get('WEBGL_compressed_texture_s3tc')))
                        return null;
                    if (t === kt)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (t === Ft)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (t === zt)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (t === Rt)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (t === Ut || t === Bt || t === Vt || t === Gt) {
                    if (null === (n = e.get('WEBGL_compressed_texture_pvrtc')))
                        return null;
                    if (t === Ut)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (t === Bt)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (t === Vt)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (t === Gt)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                return t === Ht ? null !== (n = e.get('WEBGL_compressed_texture_etc1')) ? n.COMPRESSED_RGB_ETC1_WEBGL : null : t === Wt || t === Xt || t === qt || t === Yt || t === Jt || t === Zt || t === Kt || t === Qt || t === $t || t === te || t === ee || t === ne || t === ie || t === re ? null !== (n = e.get('WEBGL_compressed_texture_astc')) ? t : null : t === At ? i ? 34042 : null !== (n = e.get('WEBGL_depth_texture')) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }
    function _a(t, e, n, i) {
        Be.call(this, t, e, i),
        this.depthBuffer = !1,
        this.stencilBuffer = !1,
        this.numViews = n
    }
    function Ma(t, e) {
        var n, i, r, o, a, s, l, c = 2, h = t.extensions, u = t.properties, p = 0;
        function d(t) {
            return t.isArrayCamera ? t.cameras : (a[0] = t,
            a)
        }
        this.isAvailable = function() {
            if (void 0 === l) {
                var t = h.get('OVR_multiview2');
                if (l = null !== t && !1 === e.getContextAttributes().antialias) {
                    p = e.getParameter(t.MAX_VIEWS_OVR),
                    n = new _a(0,0,c),
                    s = new Te,
                    o = [],
                    r = [],
                    a = [];
                    for (var i = 0; i < p; i++)
                        o[i] = new Ze,
                        r[i] = new ke
                }
            }
            return l
        }
        ,
        this.attachCamera = function(e) {
            !1 !== function(t) {
                if (void 0 === t.isArrayCamera)
                    return !0;
                var e = t.cameras;
                if (e.length > p)
                    return !1;
                for (var n = 1, i = e.length; n < i; n++)
                    if (e[0].viewport.z !== e[n].viewport.z || e[0].viewport.w !== e[n].viewport.w)
                        return !1;
                return !0
            }(e) && (i = t.getRenderTarget(),
            function(e) {
                if (i ? s.set(i.width, i.height) : t.getDrawingBufferSize(s),
                e.isArrayCamera) {
                    var r = e.cameras[0].viewport;
                    n.setSize(r.z, r.w),
                    n.setNumViews(e.cameras.length)
                } else
                    n.setSize(s.x, s.y),
                    n.setNumViews(c)
            }(e),
            t.setRenderTarget(n))
        }
        ,
        this.detachCamera = function(r) {
            n === t.getRenderTarget() && (t.setRenderTarget(i),
            function(t) {
                var i = n
                  , r = i.numViews
                  , o = u.get(i).__webglViewFramebuffers
                  , a = i.width
                  , l = i.height;
                if (t.isArrayCamera)
                    for (var c = 0; c < r; c++) {
                        var h = t.cameras[c].viewport
                          , p = h.x
                          , d = h.y
                          , f = p + h.z
                          , m = d + h.w;
                        e.bindFramebuffer(36008, o[c]),
                        e.blitFramebuffer(0, 0, a, l, p, d, f, m, 16384, 9728)
                    }
                else
                    e.bindFramebuffer(36008, o[0]),
                    e.blitFramebuffer(0, 0, a, l, 0, 0, s.x, s.y, 16384, 9728)
            }(r))
        }
        ,
        this.updateCameraProjectionMatricesUniform = function(t, n) {
            for (var i = d(t), r = 0; r < i.length; r++)
                o[r].copy(i[r].projectionMatrix);
            n.setValue(e, 'projectionMatrices', o)
        }
        ,
        this.updateCameraViewMatricesUniform = function(t, n) {
            for (var i = d(t), r = 0; r < i.length; r++)
                o[r].copy(i[r].matrixWorldInverse);
            n.setValue(e, 'viewMatrices', o)
        }
        ,
        this.updateObjectMatricesUniforms = function(t, n, i) {
            for (var a = d(n), s = 0; s < a.length; s++)
                o[s].multiplyMatrices(a[s].matrixWorldInverse, t.matrixWorld),
                r[s].getNormalMatrix(o[s]);
            i.setValue(e, 'modelViewMatrices', o),
            i.setValue(e, 'normalMatrices', r)
        }
    }
    function wa() {
        mn.call(this),
        this.type = 'Group'
    }
    function Sa(t) {
        dr.call(this),
        this.cameras = t || []
    }
    _a.prototype = Object.assign(Object.create(Be.prototype), {
        constructor: _a,
        isWebGLMultiviewRenderTarget: !0,
        copy: function(t) {
            return Be.prototype.copy.call(this, t),
            this.numViews = t.numViews,
            this
        },
        setNumViews: function(t) {
            return this.numViews !== t && (this.numViews = t,
            this.dispose()),
            this
        }
    }),
    wa.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: wa,
        isGroup: !0
    }),
    Sa.prototype = Object.assign(Object.create(dr.prototype), {
        constructor: Sa,
        isArrayCamera: !0
    });
    var Pa, Ca = new Oe, Aa = new Oe;
    function Ea(t, e, n) {
        Ca.setFromMatrixPosition(e.matrixWorld),
        Aa.setFromMatrixPosition(n.matrixWorld);
        var i = Ca.distanceTo(Aa)
          , r = e.projectionMatrix.elements
          , o = n.projectionMatrix.elements
          , a = r[14] / (r[10] - 1)
          , s = r[14] / (r[10] + 1)
          , l = (r[9] + 1) / r[5]
          , c = (r[9] - 1) / r[5]
          , h = (r[8] - 1) / r[0]
          , u = (o[8] + 1) / o[0]
          , p = a * h
          , d = a * u
          , f = i / (-h + u)
          , m = f * -h;
        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
        t.translateX(m),
        t.translateZ(f),
        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
        t.matrixWorldInverse.getInverse(t.matrixWorld);
        var g = a + f
          , v = s + f
          , y = p - m
          , x = d + (i - m)
          , b = l * s / v * g
          , _ = c * s / v * g;
        t.projectionMatrix.makePerspective(y, x, b, _, g, v)
    }
    function Ta(t) {
        var e, n, i = this, r = null, o = null, a = [], s = new Ze, l = new Ze, c = 1, h = 'local-floor';
        'undefined' != typeof window && 'VRFrameData'in window && (o = new window.VRFrameData,
        window.addEventListener('vrdisplaypresentchange', _, !1));
        var u = new Ze
          , p = new Le
          , d = new Oe
          , f = new dr
          , m = new dr;
        m.viewport = new Ue,
        m.layers.enable(1);
        var g = new dr;
        g.viewport = new Ue,
        g.layers.enable(2);
        var v = new Sa([m, g]);
        function y() {
            return null !== r && !0 === r.isPresenting
        }
        v.layers.enable(1),
        v.layers.enable(2);
        var x, b = new Te;
        function _() {
            if (y()) {
                var o = r.getEyeParameters('left');
                e = 2 * o.renderWidth * c,
                n = o.renderHeight * c,
                x = t.getPixelRatio(),
                t.getSize(b),
                t.setDrawingBufferSize(e, n, 1),
                m.viewport.set(0, 0, e / 2, n),
                g.viewport.set(e / 2, 0, e / 2, n),
                C.start(),
                i.dispatchEvent({
                    type: 'sessionstart'
                })
            } else
                i.enabled && t.setDrawingBufferSize(b.width, b.height, x),
                C.stop(),
                i.dispatchEvent({
                    type: 'sessionend'
                })
        }
        var M = []
          , w = [];
        function S(t) {
            for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                if (r && ('Daydream Controller' === r.id || 'Gear VR Controller' === r.id || 'Oculus Go Controller' === r.id || 'OpenVR Gamepad' === r.id || r.id.startsWith('Oculus Touch') || r.id.startsWith('HTC Vive Focus') || r.id.startsWith('Spatial Controller'))) {
                    var o = r.hand;
                    if (0 === t && ('' === o || 'right' === o))
                        return r;
                    if (1 === t && 'left' === o)
                        return r
                }
            }
        }
        function P(t, i) {
            null !== i && 4 === i.length && t.set(i[0] * e, i[1] * n, i[2] * e, i[3] * n)
        }
        this.enabled = !1,
        this.getController = function(t) {
            var e = a[t];
            return void 0 === e && ((e = new wa).matrixAutoUpdate = !1,
            e.visible = !1,
            a[t] = e),
            e
        }
        ,
        this.getDevice = function() {
            return r
        }
        ,
        this.setDevice = function(t) {
            void 0 !== t && (r = t),
            C.setContext(t)
        }
        ,
        this.setFramebufferScaleFactor = function(t) {
            c = t
        }
        ,
        this.setReferenceSpaceType = function(t) {
            h = t
        }
        ,
        this.getCamera = function(t) {
            var e = 'local-floor' === h ? 1.6 : 0;
            if (r.depthNear = t.near,
            r.depthFar = t.far,
            r.getFrameData(o),
            'local-floor' === h) {
                var n = r.stageParameters;
                n ? s.fromArray(n.sittingToStandingTransform) : s.makeTranslation(0, e, 0)
            }
            var i = o.pose;
            f.matrix.copy(s),
            f.matrix.decompose(f.position, f.quaternion, f.scale),
            null !== i.orientation && (p.fromArray(i.orientation),
            f.quaternion.multiply(p)),
            null !== i.position && (p.setFromRotationMatrix(s),
            d.fromArray(i.position),
            d.applyQuaternion(p),
            f.position.add(d)),
            f.updateMatrixWorld(),
            t.matrixWorld.copy(f.matrixWorld);
            for (var c = t.children, y = 0, x = c.length; y < x; y++)
                c[y].updateMatrixWorld(!0);
            m.near = t.near,
            g.near = t.near,
            m.far = t.far,
            g.far = t.far,
            m.matrixWorldInverse.fromArray(o.leftViewMatrix),
            g.matrixWorldInverse.fromArray(o.rightViewMatrix),
            l.getInverse(s),
            'local-floor' === h && (m.matrixWorldInverse.multiply(l),
            g.matrixWorldInverse.multiply(l));
            var b = t.parent;
            null !== b && (u.getInverse(b.matrixWorld),
            m.matrixWorldInverse.multiply(u),
            g.matrixWorldInverse.multiply(u)),
            m.matrixWorld.getInverse(m.matrixWorldInverse),
            g.matrixWorld.getInverse(g.matrixWorldInverse),
            m.projectionMatrix.fromArray(o.leftProjectionMatrix),
            g.projectionMatrix.fromArray(o.rightProjectionMatrix),
            Ea(v, m, g);
            var _ = r.getLayers();
            if (_.length) {
                var C = _[0];
                P(m.viewport, C.leftBounds),
                P(g.viewport, C.rightBounds)
            }
            return function() {
                for (var t = 0; t < a.length; t++) {
                    var e = a[t]
                      , n = S(t);
                    if (void 0 !== n && void 0 !== n.pose) {
                        if (null === n.pose)
                            return;
                        var i = n.pose;
                        !1 === i.hasPosition && e.position.set(.2, -.6, -.05),
                        null !== i.position && e.position.fromArray(i.position),
                        null !== i.orientation && e.quaternion.fromArray(i.orientation),
                        e.matrix.compose(e.position, e.quaternion, e.scale),
                        e.matrix.premultiply(s),
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        e.matrixWorldNeedsUpdate = !0,
                        e.visible = !0;
                        var r = 'Daydream Controller' === n.id ? 0 : 1;
                        void 0 === M[t] && (M[t] = !1),
                        M[t] !== n.buttons[r].pressed && (M[t] = n.buttons[r].pressed,
                        !0 === M[t] ? e.dispatchEvent({
                            type: 'selectstart'
                        }) : (e.dispatchEvent({
                            type: 'selectend'
                        }),
                        e.dispatchEvent({
                            type: 'select'
                        }))),
                        r = 2,
                        void 0 === w[t] && (w[t] = !1),
                        void 0 !== n.buttons[r] && w[t] !== n.buttons[r].pressed && (w[t] = n.buttons[r].pressed,
                        !0 === w[t] ? e.dispatchEvent({
                            type: 'squeezestart'
                        }) : (e.dispatchEvent({
                            type: 'squeezeend'
                        }),
                        e.dispatchEvent({
                            type: 'squeeze'
                        })))
                    } else
                        e.visible = !1
                }
            }(),
            v
        }
        ,
        this.getStandingMatrix = function() {
            return s
        }
        ,
        this.isPresenting = y;
        var C = new Pr;
        this.setAnimationLoop = function(t) {
            C.setAnimationLoop(t),
            y() && C.start()
        }
        ,
        this.submitFrame = function() {
            y() && r.submitFrame()
        }
        ,
        this.dispose = function() {
            'undefined' != typeof window && window.removeEventListener('vrdisplaypresentchange', _)
        }
        ,
        this.setFrameOfReferenceType = function() {}
    }
    function La(t, e) {
        var n = this
          , i = null
          , r = null
          , o = 'local-floor'
          , a = null
          , s = []
          , l = [];
        var c = new dr;
        c.layers.enable(1),
        c.viewport = new Ue;
        var h = new dr;
        h.layers.enable(2),
        h.viewport = new Ue;
        var u = new Sa([c, h]);
        function p(t) {
            for (var e = 0; e < s.length; e++)
                l[e] === t.inputSource && s[e].dispatchEvent({
                    type: t.type
                })
        }
        function d() {
            t.setFramebuffer(null),
            t.setRenderTarget(t.getRenderTarget()),
            x.stop(),
            n.dispatchEvent({
                type: 'sessionend'
            })
        }
        function f(t) {
            r = t,
            x.setContext(i),
            x.start(),
            n.dispatchEvent({
                type: 'sessionstart'
            })
        }
        function m() {
            for (var t = 0; t < s.length; t++)
                l[t] = g(t)
        }
        function g(t) {
            for (var e = i.inputSources, n = 0; n < e.length; n++) {
                var r = e[n]
                  , o = r.handedness;
                if (0 === t && ('none' === o || 'right' === o))
                    return r;
                if (1 === t && 'left' === o)
                    return r
            }
        }
        function v(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.getInverse(t.matrixWorld)
        }
        u.layers.enable(1),
        u.layers.enable(2),
        this.enabled = !1,
        this.getController = function(t) {
            var e = s[t];
            return void 0 === e && ((e = new wa).matrixAutoUpdate = !1,
            e.visible = !1,
            s[t] = e),
            e
        }
        ,
        this.setFramebufferScaleFactor = function() {}
        ,
        this.setReferenceSpaceType = function(t) {
            o = t
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = function(t) {
            null !== (i = t) && (i.addEventListener('select', p),
            i.addEventListener('selectstart', p),
            i.addEventListener('selectend', p),
            i.addEventListener('squeeze', p),
            i.addEventListener('squeezestart', p),
            i.addEventListener('squeezeend', p),
            i.addEventListener('end', d),
            i.updateRenderState({
                baseLayer: new XRWebGLLayer(i,e)
            }),
            i.requestReferenceSpace(o).then(f),
            i.addEventListener('inputsourceschange', m),
            m())
        }
        ,
        this.getCamera = function(t) {
            var e = t.parent
              , n = u.cameras;
            v(u, e);
            for (var i = 0; i < n.length; i++)
                v(n[i], e);
            t.matrixWorld.copy(u.matrixWorld);
            for (var r = t.children, o = (i = 0,
            r.length); i < o; i++)
                r[i].updateMatrixWorld(!0);
            return Ea(u, c, h),
            u
        }
        ,
        this.isPresenting = function() {
            return null !== i && null !== r
        }
        ;
        var y = null;
        var x = new Pr;
        x.setAnimationLoop((function(e, n) {
            if (null !== (a = n.getViewerPose(r))) {
                var o = a.views
                  , c = i.renderState.baseLayer;
                t.setFramebuffer(c.framebuffer);
                for (var h = 0; h < o.length; h++) {
                    var p = o[h]
                      , d = c.getViewport(p)
                      , f = p.transform.inverse.matrix
                      , m = u.cameras[h];
                    m.matrix.fromArray(f).getInverse(m.matrix),
                    m.projectionMatrix.fromArray(p.projectionMatrix),
                    m.viewport.set(d.x, d.y, d.width, d.height),
                    0 === h && u.matrix.copy(m.matrix)
                }
            }
            for (h = 0; h < s.length; h++) {
                var g = s[h]
                  , v = l[h];
                if (v) {
                    var x = n.getPose(v.targetRaySpace, r);
                    if (null !== x) {
                        g.matrix.fromArray(x.transform.matrix),
                        g.matrix.decompose(g.position, g.rotation, g.scale),
                        g.visible = !0;
                        continue
                    }
                }
                g.visible = !1
            }
            y && y(e)
        }
        )),
        this.setAnimationLoop = function(t) {
            y = t
        }
        ,
        this.dispose = function() {}
        ,
        this.getStandingMatrix = function() {
            return new Ze
        }
        ,
        this.getDevice = function() {}
        ,
        this.setDevice = function() {}
        ,
        this.setFrameOfReferenceType = function() {}
        ,
        this.submitFrame = function() {}
    }
    function Da(t) {
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
          , n = void 0 !== t.context ? t.context : null
          , i = void 0 !== t.alpha && t.alpha
          , r = void 0 === t.depth || t.depth
          , o = void 0 === t.stencil || t.stencil
          , a = void 0 !== t.antialias && t.antialias
          , s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , c = void 0 !== t.powerPreference ? t.powerPreference : 'default'
          , u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat
          , p = null
          , d = null;
        this.domElement = e,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.gammaInput = !1,
        this.gammaOutput = !1,
        this.physicallyCorrectLights = !1,
        this.toneMapping = J,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var f, m, g, v, y, x, b, _, M, w, S, P, C, A, E, T, L, D, I = this, O = !1, j = null, N = 0, k = 0, F = null, z = null, R = -1, U = {
            geometry: null,
            program: null,
            wireframe: !1
        }, B = null, V = null, G = new Ue, H = new Ue, W = null, X = e.width, q = e.height, Y = 1, Z = new Ue(0,0,X,q), K = new Ue(0,0,X,q), Q = !1, $ = new _r, tt = new Ir, et = !1, nt = !1, it = new Ze, rt = new Oe;
        function ot() {
            return null === F ? Y : 1
        }
        try {
            var at = {
                alpha: i,
                depth: r,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: u,
                xrCompatible: !0
            };
            if (e.addEventListener('webglcontextlost', ut, !1),
            e.addEventListener('webglcontextrestored', pt, !1),
            null === (f = n || e.getContext('webgl', at) || e.getContext('experimental-webgl', at)))
                throw null !== e.getContext('webgl') ? new Error('Error creating WebGL context with your selected attributes.') : new Error('Error creating WebGL context.');
            void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            throw t
        }
        function st() {
            m = new Or(f),
            !1 === (g = new Dr(f,m,t)).isWebGL2 && (m.get('WEBGL_depth_texture'),
            m.get('OES_texture_float'),
            m.get('OES_texture_half_float'),
            m.get('OES_texture_half_float_linear'),
            m.get('OES_standard_derivatives'),
            m.get('OES_element_index_uint'),
            m.get('ANGLE_instanced_arrays')),
            m.get('OES_texture_float_linear'),
            D = new ba(f,m,g),
            (v = new ya(f,m,g)).scissor(H.copy(K).multiplyScalar(Y).floor()),
            v.viewport(G.copy(Z).multiplyScalar(Y).floor()),
            y = new kr(f),
            x = new na,
            b = new xa(f,m,v,x,g,D,y),
            _ = new Cr(f),
            M = new jr(f,_,y),
            w = new Rr(f,M,_,y),
            E = new zr(f),
            S = new ea(I,m,g),
            P = new aa,
            C = new pa,
            A = new Tr(I,v,w,s),
            T = new Lr(f,m,y,g),
            L = new Nr(f,m,y,g),
            y.programs = S.programs,
            I.capabilities = g,
            I.extensions = m,
            I.properties = x,
            I.renderLists = P,
            I.state = v,
            I.info = y
        }
        st();
        var lt = 'undefined' != typeof navigator && 'xr'in navigator ? new La(I,f) : new Ta(I);
        this.vr = lt;
        var ct = new Ma(I,f)
          , ht = new va(I,w,g.maxTextureSize);
        function ut(t) {
            t.preventDefault(),
            O = !0
        }
        function pt() {
            O = !1,
            st()
        }
        function dt(t) {
            var e = t.target;
            e.removeEventListener('dispose', dt),
            function(t) {
                ft(t),
                x.remove(t)
            }(e)
        }
        function ft(t) {
            var e = x.get(t).program;
            t.program = void 0,
            void 0 !== e && S.releaseProgram(e)
        }
        this.shadowMap = ht,
        this.getContext = function() {
            return f
        }
        ,
        this.getContextAttributes = function() {
            return f.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var t = m.get('WEBGL_lose_context');
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var t = m.get('WEBGL_lose_context');
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Y
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (Y = t,
            this.setSize(X, q, !1))
        }
        ,
        this.getSize = function(t) {
            return void 0 === t && (t = new Te),
            t.set(X, q)
        }
        ,
        this.setSize = function(t, n, i) {
            lt.isPresenting() || (X = t,
            q = n,
            e.width = Math.floor(t * Y),
            e.height = Math.floor(n * Y),
            !1 !== i && (e.style.width = t + 'px',
            e.style.height = n + 'px'),
            this.setViewport(0, 0, t, n))
        }
        ,
        this.getDrawingBufferSize = function(t) {
            return void 0 === t && (t = new Te),
            t.set(X * Y, q * Y).floor()
        }
        ,
        this.setDrawingBufferSize = function(t, n, i) {
            X = t,
            q = n,
            Y = i,
            e.width = Math.floor(t * i),
            e.height = Math.floor(n * i),
            this.setViewport(0, 0, t, n)
        }
        ,
        this.getCurrentViewport = function(t) {
            return void 0 === t && (t = new Ue),
            t.copy(G)
        }
        ,
        this.getViewport = function(t) {
            return t.copy(Z)
        }
        ,
        this.setViewport = function(t, e, n, i) {
            t.isVector4 ? Z.set(t.x, t.y, t.z, t.w) : Z.set(t, e, n, i),
            v.viewport(G.copy(Z).multiplyScalar(Y).floor())
        }
        ,
        this.getScissor = function(t) {
            return t.copy(K)
        }
        ,
        this.setScissor = function(t, e, n, i) {
            t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, n, i),
            v.scissor(H.copy(K).multiplyScalar(Y).floor())
        }
        ,
        this.getScissorTest = function() {
            return Q
        }
        ,
        this.setScissorTest = function(t) {
            v.setScissorTest(Q = t)
        }
        ,
        this.getClearColor = function() {
            return A.getClearColor()
        }
        ,
        this.setClearColor = function() {
            A.setClearColor.apply(A, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return A.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            A.setClearAlpha.apply(A, arguments)
        }
        ,
        this.clear = function(t, e, n) {
            var i = 0;
            (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            f.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            e.removeEventListener('webglcontextlost', ut, !1),
            e.removeEventListener('webglcontextrestored', pt, !1),
            P.dispose(),
            C.dispose(),
            x.dispose(),
            w.dispose(),
            lt.dispose(),
            vt.stop()
        }
        ,
        this.renderBufferImmediate = function(t, e) {
            v.initAttributes();
            var n = x.get(t);
            t.hasPositions && !n.position && (n.position = f.createBuffer()),
            t.hasNormals && !n.normal && (n.normal = f.createBuffer()),
            t.hasUvs && !n.uv && (n.uv = f.createBuffer()),
            t.hasColors && !n.color && (n.color = f.createBuffer());
            var i = e.getAttributes();
            t.hasPositions && (f.bindBuffer(34962, n.position),
            f.bufferData(34962, t.positionArray, 35048),
            v.enableAttribute(i.position),
            f.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            t.hasNormals && (f.bindBuffer(34962, n.normal),
            f.bufferData(34962, t.normalArray, 35048),
            v.enableAttribute(i.normal),
            f.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs && (f.bindBuffer(34962, n.uv),
            f.bufferData(34962, t.uvArray, 35048),
            v.enableAttribute(i.uv),
            f.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            t.hasColors && (f.bindBuffer(34962, n.color),
            f.bufferData(34962, t.colorArray, 35048),
            v.enableAttribute(i.color),
            f.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            v.disableUnusedAttributes(),
            f.drawArrays(4, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, e, n, i, r, o) {
            var a = r.isMesh && r.matrixWorld.determinant() < 0;
            v.setMaterial(i, a);
            var s = St(t, e, i, r)
              , l = !1;
            U.geometry === n.id && U.program === s.id && U.wireframe === (!0 === i.wireframe) || (U.geometry = n.id,
            U.program = s.id,
            U.wireframe = !0 === i.wireframe,
            l = !0),
            r.morphTargetInfluences && (E.update(r, n, i, s),
            l = !0);
            var c = n.index
              , h = n.attributes.position;
            if ((null === c || 0 !== c.count) && void 0 !== h && 0 !== h.count) {
                var u, p = 1;
                !0 === i.wireframe && (c = M.getWireframeAttribute(n),
                p = 2);
                var d = T;
                null !== c && (u = _.get(c),
                (d = L).setIndex(u)),
                l && (!function(t, e, n, i) {
                    if (!1 === g.isWebGL2 && (t.isInstancedMesh || e.isInstancedBufferGeometry) && null === m.get('ANGLE_instanced_arrays'))
                        return;
                    v.initAttributes();
                    var r = e.attributes
                      , o = i.getAttributes()
                      , a = n.defaultAttributeValues;
                    for (var s in o) {
                        var l = o[s];
                        if (l >= 0) {
                            var c = r[s];
                            if (void 0 !== c) {
                                var h = c.normalized
                                  , u = c.itemSize;
                                if (void 0 === (w = _.get(c)))
                                    continue;
                                var p = w.buffer
                                  , d = w.type
                                  , y = w.bytesPerElement;
                                if (c.isInterleavedBufferAttribute) {
                                    var x = c.data
                                      , b = x.stride
                                      , M = c.offset;
                                    x && x.isInstancedInterleavedBuffer ? (v.enableAttributeAndDivisor(l, x.meshPerAttribute),
                                    void 0 === e.maxInstancedCount && (e.maxInstancedCount = x.meshPerAttribute * x.count)) : v.enableAttribute(l),
                                    f.bindBuffer(34962, p),
                                    f.vertexAttribPointer(l, u, d, h, b * y, M * y)
                                } else
                                    c.isInstancedBufferAttribute ? (v.enableAttributeAndDivisor(l, c.meshPerAttribute),
                                    void 0 === e.maxInstancedCount && (e.maxInstancedCount = c.meshPerAttribute * c.count)) : v.enableAttribute(l),
                                    f.bindBuffer(34962, p),
                                    f.vertexAttribPointer(l, u, d, h, 0, 0)
                            } else if ('instanceMatrix' === s) {
                                var w;
                                if (void 0 === (w = _.get(t.instanceMatrix)))
                                    continue;
                                p = w.buffer,
                                d = w.type;
                                v.enableAttributeAndDivisor(l + 0, 1),
                                v.enableAttributeAndDivisor(l + 1, 1),
                                v.enableAttributeAndDivisor(l + 2, 1),
                                v.enableAttributeAndDivisor(l + 3, 1),
                                f.bindBuffer(34962, p),
                                f.vertexAttribPointer(l + 0, 4, d, !1, 64, 0),
                                f.vertexAttribPointer(l + 1, 4, d, !1, 64, 16),
                                f.vertexAttribPointer(l + 2, 4, d, !1, 64, 32),
                                f.vertexAttribPointer(l + 3, 4, d, !1, 64, 48)
                            } else if (void 0 !== a) {
                                var S = a[s];
                                if (void 0 !== S)
                                    switch (S.length) {
                                    case 2:
                                        f.vertexAttrib2fv(l, S);
                                        break;
                                    case 3:
                                        f.vertexAttrib3fv(l, S);
                                        break;
                                    case 4:
                                        f.vertexAttrib4fv(l, S);
                                        break;
                                    default:
                                        f.vertexAttrib1fv(l, S)
                                    }
                            }
                        }
                    }
                    v.disableUnusedAttributes()
                }(r, n, i, s),
                null !== c && f.bindBuffer(34963, u.buffer));
                var y = 1 / 0;
                null !== c ? y = c.count : void 0 !== h && (y = h.count);
                var x = n.drawRange.start * p
                  , b = n.drawRange.count * p
                  , w = null !== o ? o.start * p : 0
                  , S = null !== o ? o.count * p : 1 / 0
                  , P = Math.max(x, w)
                  , C = Math.min(y, x + b, w + S) - 1
                  , A = Math.max(0, C - P + 1);
                if (0 !== A) {
                    if (r.isMesh)
                        if (!0 === i.wireframe)
                            v.setLineWidth(i.wireframeLinewidth * ot()),
                            d.setMode(1);
                        else
                            switch (r.drawMode) {
                            case se:
                                d.setMode(4);
                                break;
                            case le:
                                d.setMode(5);
                                break;
                            case ce:
                                d.setMode(6)
                            }
                    else if (r.isLine) {
                        var D = i.linewidth;
                        void 0 === D && (D = 1),
                        v.setLineWidth(D * ot()),
                        r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                    } else
                        r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                    r.isInstancedMesh ? d.renderInstances(n, P, A, r.count) : n.isInstancedBufferGeometry ? d.renderInstances(n, P, A, n.maxInstancedCount) : d.render(P, A)
                }
            }
        }
        ,
        this.compile = function(t, e) {
            (d = C.get(t, e)).init(),
            t.traverse((function(t) {
                t.isLight && (d.pushLight(t),
                t.castShadow && d.pushShadow(t))
            }
            )),
            d.setupLights(e),
            t.traverse((function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var n = 0; n < e.material.length; n++)
                            _t(e.material[n], t.fog, e);
                    else
                        _t(e.material, t.fog, e)
            }
            ))
        }
        ;
        var mt = null;
        var vt = new Pr;
        function yt(t, e, n, i) {
            if (!1 !== t.visible) {
                if (t.layers.test(e.layers))
                    if (t.isGroup)
                        n = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        d.pushLight(t),
                        t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || $.intersectsSprite(t)) {
                            i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                            var r = w.update(t);
                            (o = t.material).visible && p.push(t, r, o, n, rt.z, null)
                        }
                    } else if (t.isImmediateRenderObject)
                        i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it),
                        p.push(t, null, t.material, n, rt.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== y.render.frame && (t.skeleton.update(),
                    t.skeleton.frame = y.render.frame),
                    !t.frustumCulled || $.intersectsObject(t))) {
                        i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                        r = w.update(t);
                        var o = t.material;
                        if (Array.isArray(o))
                            for (var a = r.groups, s = 0, l = a.length; s < l; s++) {
                                var c = a[s]
                                  , h = o[c.materialIndex];
                                h && h.visible && p.push(t, r, h, n, rt.z, c)
                            }
                        else
                            o.visible && p.push(t, r, o, n, rt.z, null)
                    }
                var u = t.children;
                for (s = 0,
                l = u.length; s < l; s++)
                    yt(u[s], e, n, i)
            }
        }
        function xt(t, e, n, i) {
            for (var r = 0, o = t.length; r < o; r++) {
                var a = t[r]
                  , s = a.object
                  , l = a.geometry
                  , c = void 0 === i ? a.material : i
                  , h = a.group;
                if (n.isArrayCamera)
                    if (V = n,
                    lt.enabled && ct.isAvailable())
                        bt(s, e, n, l, c, h);
                    else
                        for (var u = n.cameras, p = 0, f = u.length; p < f; p++) {
                            var m = u[p];
                            s.layers.test(m.layers) && (v.viewport(G.copy(m.viewport)),
                            d.setupLights(m),
                            bt(s, e, m, l, c, h))
                        }
                else
                    V = null,
                    bt(s, e, n, l, c, h)
            }
        }
        function bt(t, e, n, i, r, o) {
            if (t.onBeforeRender(I, e, n, i, r, o),
            d = C.get(e, V || n),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject) {
                v.setMaterial(r);
                var a = St(n, e.fog, r, t);
                U.geometry = null,
                U.program = null,
                U.wireframe = !1,
                function(t, e) {
                    t.render((function(t) {
                        I.renderBufferImmediate(t, e)
                    }
                    ))
                }(t, a)
            } else
                I.renderBufferDirect(n, e.fog, i, r, t, o);
            t.onAfterRender(I, e, n, i, r, o),
            d = C.get(e, V || n)
        }
        function _t(t, e, n) {
            var i = x.get(t)
              , r = d.state.lights
              , o = d.state.shadowsArray
              , a = r.state.version
              , s = S.getParameters(t, r.state, o, e, tt.numPlanes, tt.numIntersection, n)
              , l = S.getProgramCacheKey(t, s)
              , c = i.program
              , h = !0;
            if (void 0 === c)
                t.addEventListener('dispose', dt);
            else if (c.cacheKey !== l)
                ft(t);
            else if (i.lightsStateVersion !== a)
                i.lightsStateVersion = a,
                h = !1;
            else {
                if (void 0 !== s.shaderID)
                    return;
                h = !1
            }
            if (h) {
                if (s.shaderID) {
                    var u = Sr[s.shaderID];
                    i.shader = {
                        name: t.type,
                        uniforms: sr(u.uniforms),
                        vertexShader: u.vertexShader,
                        fragmentShader: u.fragmentShader
                    }
                } else
                    i.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                t.onBeforeCompile(i.shader, I),
                l = S.getProgramCacheKey(t, s),
                c = S.acquireProgram(t, i.shader, s, l),
                i.program = c,
                t.program = c
            }
            var p = c.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var f = 0; f < I.maxMorphTargets; f++)
                    p['morphTarget' + f] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (f = 0; f < I.maxMorphNormals; f++)
                    p['morphNormal' + f] >= 0 && t.numSupportedMorphNormals++
            }
            var m = i.shader.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = tt.numPlanes,
            i.numIntersection = tt.numIntersection,
            m.clippingPlanes = tt.uniform),
            i.fog = e,
            i.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t),
            i.lightsStateVersion = a,
            i.needsLights && (m.ambientLightColor.value = r.state.ambient,
            m.lightProbe.value = r.state.probe,
            m.directionalLights.value = r.state.directional,
            m.spotLights.value = r.state.spot,
            m.rectAreaLights.value = r.state.rectArea,
            m.pointLights.value = r.state.point,
            m.hemisphereLights.value = r.state.hemi,
            m.directionalShadowMap.value = r.state.directionalShadowMap,
            m.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            m.spotShadowMap.value = r.state.spotShadowMap,
            m.spotShadowMatrix.value = r.state.spotShadowMatrix,
            m.pointShadowMap.value = r.state.pointShadowMap,
            m.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var g = i.program.getUniforms()
              , v = Fo.seqWithValue(g.seq, m);
            i.uniformsList = v
        }
        function St(t, e, n, i) {
            b.resetTextureUnits();
            var r = x.get(n)
              , o = d.state.lights;
            if (et && (nt || t !== B)) {
                var a = t === B && n.id === R;
                tt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, a)
            }
            n.version === r.__version && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : r.needsLights && r.lightsStateVersion !== o.state.version ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === tt.numPlanes && r.numIntersection === tt.numIntersection || (n.needsUpdate = !0)),
            n.version !== r.__version && (_t(n, e, i),
            r.__version = n.version);
            var s, l, c = !1, u = !1, p = !1, m = r.program, y = m.getUniforms(), _ = r.shader.uniforms;
            if (v.useProgram(m.program) && (c = !0,
            u = !0,
            p = !0),
            n.id !== R && (R = n.id,
            u = !0),
            c || B !== t) {
                if (m.numMultiviewViews > 0 ? ct.updateCameraProjectionMatricesUniform(t, y) : y.setValue(f, 'projectionMatrix', t.projectionMatrix),
                g.logarithmicDepthBuffer && y.setValue(f, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
                B !== t && (B = t,
                u = !0,
                p = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var M = y.map.cameraPosition;
                    void 0 !== M && M.setValue(f, rt.setFromMatrixPosition(t.matrixWorld))
                }
                (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(f, 'isOrthographic', !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && (m.numMultiviewViews > 0 ? ct.updateCameraViewMatricesUniform(t, y) : y.setValue(f, 'viewMatrix', t.matrixWorldInverse))
            }
            if (n.skinning) {
                y.setOptional(f, i, 'bindMatrix'),
                y.setOptional(f, i, 'bindMatrixInverse');
                var w = i.skeleton;
                if (w) {
                    var S = w.bones;
                    if (g.floatVertexTextures) {
                        if (void 0 === w.boneTexture) {
                            var P = Math.sqrt(4 * S.length);
                            P = Ee.ceilPowerOfTwo(P),
                            P = Math.max(P, 4);
                            var C = new Float32Array(P * P * 4);
                            C.set(w.boneMatrices);
                            var A = new yr(C,P,P,Lt,Mt);
                            w.boneMatrices = C,
                            w.boneTexture = A,
                            w.boneTextureSize = P
                        }
                        y.setValue(f, 'boneTexture', w.boneTexture, b),
                        y.setValue(f, 'boneTextureSize', w.boneTextureSize)
                    } else
                        y.setOptional(f, w, 'boneMatrices')
                }
            }
            return (u || r.receiveShadow !== i.receiveShadow) && (r.receiveShadow = i.receiveShadow,
            y.setValue(f, 'receiveShadow', i.receiveShadow)),
            u && (y.setValue(f, 'toneMappingExposure', I.toneMappingExposure),
            y.setValue(f, 'toneMappingWhitePoint', I.toneMappingWhitePoint),
            r.needsLights && (l = p,
            (s = _).ambientLightColor.needsUpdate = l,
            s.lightProbe.needsUpdate = l,
            s.directionalLights.needsUpdate = l,
            s.pointLights.needsUpdate = l,
            s.spotLights.needsUpdate = l,
            s.rectAreaLights.needsUpdate = l,
            s.hemisphereLights.needsUpdate = l),
            e && n.fog && function(t, e) {
                t.fogColor.value.copy(e.color),
                e.isFog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(_, e),
            n.isMeshBasicMaterial ? Pt(_, n) : n.isMeshLambertMaterial ? (Pt(_, n),
            function(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(_, n)) : n.isMeshPhongMaterial ? (Pt(_, n),
            n.isMeshToonMaterial ? function(t, e) {
                Ct(t, e),
                e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }(_, n) : Ct(_, n)) : n.isMeshStandardMaterial ? (Pt(_, n),
            n.isMeshPhysicalMaterial ? function(t, e) {
                At(t, e),
                t.reflectivity.value = e.reflectivity,
                t.clearcoat.value = e.clearcoat,
                t.clearcoatRoughness.value = e.clearcoatRoughness,
                e.sheen && t.sheen.value.copy(e.sheen);
                e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                e.side === h && t.clearcoatNormalScale.value.negate());
                t.transparency.value = e.transparency
            }(_, n) : At(_, n)) : n.isMeshMatcapMaterial ? (Pt(_, n),
            function(t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                t.bumpScale.value = e.bumpScale,
                e.side === h && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap,
                t.normalScale.value.copy(e.normalScale),
                e.side === h && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }(_, n)) : n.isMeshDepthMaterial ? (Pt(_, n),
            function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }(_, n)) : n.isMeshDistanceMaterial ? (Pt(_, n),
            function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias);
                t.referencePosition.value.copy(e.referencePosition),
                t.nearDistance.value = e.nearDistance,
                t.farDistance.value = e.farDistance
            }(_, n)) : n.isMeshNormalMaterial ? (Pt(_, n),
            function(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                t.bumpScale.value = e.bumpScale,
                e.side === h && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap,
                t.normalScale.value.copy(e.normalScale),
                e.side === h && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }(_, n)) : n.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity
            }(_, n),
            n.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize,
                t.totalSize.value = e.dashSize + e.gapSize,
                t.scale.value = e.scale
            }(_, n)) : n.isPointsMaterial ? function(t, e) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity,
                t.size.value = e.size * Y,
                t.scale.value = .5 * q,
                e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                t.uvTransform.value.copy(n.matrix))
            }(_, n) : n.isSpriteMaterial ? function(t, e) {
                t.diffuse.value.copy(e.color),
                t.opacity.value = e.opacity,
                t.rotation.value = e.rotation,
                e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                t.uvTransform.value.copy(n.matrix))
            }(_, n) : n.isShadowMaterial && (_.color.value.copy(n.color),
            _.opacity.value = n.opacity),
            void 0 !== _.ltc_1 && (_.ltc_1.value = wr.LTC_1),
            void 0 !== _.ltc_2 && (_.ltc_2.value = wr.LTC_2),
            Fo.upload(f, r.uniformsList, _, b),
            n.isShaderMaterial && (n.uniformsNeedUpdate = !1)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Fo.upload(f, r.uniformsList, _, b),
            n.uniformsNeedUpdate = !1),
            n.isSpriteMaterial && y.setValue(f, 'center', i.center),
            m.numMultiviewViews > 0 ? ct.updateObjectMatricesUniforms(i, t, y) : (y.setValue(f, 'modelViewMatrix', i.modelViewMatrix),
            y.setValue(f, 'normalMatrix', i.normalMatrix)),
            y.setValue(f, 'modelMatrix', i.matrixWorld),
            m
        }
        function Pt(t, e) {
            var n;
            t.opacity.value = e.opacity,
            e.color && t.diffuse.value.copy(e.color),
            e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.specularMap && (t.specularMap.value = e.specularMap),
            e.envMap && (t.envMap.value = e.envMap,
            t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1,
            t.reflectivity.value = e.reflectivity,
            t.refractionRatio.value = e.refractionRatio,
            t.maxMipLevel.value = x.get(e.envMap).__maxMipLevel),
            e.lightMap && (t.lightMap.value = e.lightMap,
            t.lightMapIntensity.value = e.lightMapIntensity),
            e.aoMap && (t.aoMap.value = e.aoMap,
            t.aoMapIntensity.value = e.aoMapIntensity),
            e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap),
            void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture),
            !0 === n.matrixAutoUpdate && n.updateMatrix(),
            t.uvTransform.value.copy(n.matrix))
        }
        function Ct(t, e) {
            t.specular.value.copy(e.specular),
            t.shininess.value = Math.max(e.shininess, 1e-4),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale,
            e.side === h && (t.bumpScale.value *= -1)),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale),
            e.side === h && t.normalScale.value.negate()),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias)
        }
        function At(t, e) {
            t.roughness.value = e.roughness,
            t.metalness.value = e.metalness,
            e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
            e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale,
            e.side === h && (t.bumpScale.value *= -1)),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale),
            e.side === h && t.normalScale.value.negate()),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias),
            e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        vt.setAnimationLoop((function(t) {
            lt.isPresenting() || mt && mt(t)
        }
        )),
        'undefined' != typeof window && vt.setContext(window),
        this.setAnimationLoop = function(t) {
            mt = t,
            lt.setAnimationLoop(t),
            vt.start()
        }
        ,
        this.render = function(t, e) {
            var n, i;
            if (void 0 !== arguments[2] && (n = arguments[2]),
            void 0 !== arguments[3] && (i = arguments[3]),
            e && e.isCamera && !O) {
                U.geometry = null,
                U.program = null,
                U.wireframe = !1,
                R = -1,
                B = null,
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                lt.enabled && lt.isPresenting() && (e = lt.getCamera(e)),
                (d = C.get(t, e)).init(),
                t.onBeforeRender(I, t, e, n || F),
                it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                $.setFromMatrix(it),
                nt = this.localClippingEnabled,
                et = tt.init(this.clippingPlanes, nt, e),
                (p = P.get(t, e)).init(),
                yt(t, e, 0, I.sortObjects),
                !0 === I.sortObjects && p.sort(),
                et && tt.beginShadows();
                var r = d.state.shadowsArray;
                ht.render(r, t, e),
                d.setupLights(e),
                et && tt.endShadows(),
                this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                lt.enabled && ct.isAvailable() && ct.attachCamera(e),
                A.render(p, t, e, i);
                var o = p.opaque
                  , a = p.transparent;
                if (t.overrideMaterial) {
                    var s = t.overrideMaterial;
                    o.length && xt(o, t, e, s),
                    a.length && xt(a, t, e, s)
                } else
                    o.length && xt(o, t, e),
                    a.length && xt(a, t, e);
                t.onAfterRender(I, t, e),
                null !== F && (b.updateRenderTargetMipmap(F),
                b.updateMultisampleRenderTarget(F)),
                v.buffers.depth.setTest(!0),
                v.buffers.depth.setMask(!0),
                v.buffers.color.setMask(!0),
                v.setPolygonOffset(!1),
                lt.enabled && (ct.isAvailable() && ct.detachCamera(e),
                lt.submitFrame()),
                p = null,
                d = null
            }
        }
        ,
        this.setFramebuffer = function(t) {
            j !== t && null === F && f.bindFramebuffer(36160, t),
            j = t
        }
        ,
        this.getActiveCubeFace = function() {
            return N
        }
        ,
        this.getActiveMipmapLevel = function() {
            return k
        }
        ,
        this.getRenderTarget = function() {
            return F
        }
        ,
        this.setRenderTarget = function(t, e, n) {
            F = t,
            N = e,
            k = n,
            t && void 0 === x.get(t).__webglFramebuffer && b.setupRenderTarget(t);
            var i = j
              , r = !1;
            if (t) {
                var o = x.get(t).__webglFramebuffer;
                t.isWebGLRenderTargetCube ? (i = o[e || 0],
                r = !0) : i = t.isWebGLMultisampleRenderTarget ? x.get(t).__webglMultisampledFramebuffer : o,
                G.copy(t.viewport),
                H.copy(t.scissor),
                W = t.scissorTest
            } else
                G.copy(Z).multiplyScalar(Y).floor(),
                H.copy(K).multiplyScalar(Y).floor(),
                W = Q;
            if (z !== i && (f.bindFramebuffer(36160, i),
            z = i),
            v.viewport(G),
            v.scissor(H),
            v.setScissorTest(W),
            r) {
                var a = x.get(t.texture);
                f.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, n || 0)
            }
        }
        ,
        this.readRenderTargetPixels = function(t, e, n, i, r, o, a) {
            if (t && t.isWebGLRenderTarget) {
                var s = x.get(t).__webglFramebuffer;
                if (t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]),
                s) {
                    var l = !1;
                    s !== z && (f.bindFramebuffer(36160, s),
                    l = !0);
                    try {
                        var c = t.texture
                          , h = c.format
                          , u = c.type;
                        if (h !== Lt && D.convert(h) !== f.getParameter(35739))
                            return;
                        if (!(u === gt || D.convert(u) === f.getParameter(35738) || u === Mt && (g.isWebGL2 || m.get('OES_texture_float') || m.get('WEBGL_color_buffer_float')) || u === wt && (g.isWebGL2 ? m.get('EXT_color_buffer_float') : m.get('EXT_color_buffer_half_float'))))
                            return;
                        36053 === f.checkFramebufferStatus(36160) && e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && f.readPixels(e, n, i, r, D.convert(h), D.convert(u), o)
                    } finally {
                        l && f.bindFramebuffer(36160, z)
                    }
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(t, e, n) {
            void 0 === n && (n = 0);
            var i = Math.pow(2, -n)
              , r = Math.floor(e.image.width * i)
              , o = Math.floor(e.image.height * i)
              , a = D.convert(e.format);
            b.setTexture2D(e, 0),
            f.copyTexImage2D(3553, n, a, t.x, t.y, r, o, 0),
            v.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(t, e, n, i) {
            var r = e.image.width
              , o = e.image.height
              , a = D.convert(n.format)
              , s = D.convert(n.type);
            b.setTexture2D(n, 0),
            e.isDataTexture ? f.texSubImage2D(3553, i || 0, t.x, t.y, r, o, a, s, e.image.data) : f.texSubImage2D(3553, i || 0, t.x, t.y, a, s, e.image),
            v.unbindTexture()
        }
        ,
        this.initTexture = function(t) {
            b.setTexture2D(t, 0),
            v.unbindTexture()
        }
        ,
        'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{
            detail: this
        }))
    }
    function Ia(t, e) {
        this.name = '',
        this.color = new ai(t),
        this.density = void 0 !== e ? e : 25e-5
    }
    function Oa(t, e, n) {
        this.name = '',
        this.color = new ai(t),
        this.near = void 0 !== e ? e : 1,
        this.far = void 0 !== n ? n : 1e3
    }
    function ja(t, e) {
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.usage = Se,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Na(t, e, n, i) {
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = !0 === i
    }
    function ka(t) {
        pi.call(this),
        this.type = 'SpriteMaterial',
        this.color = new ai(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.setValues(t)
    }
    Object.assign(Ta.prototype, Pe.prototype),
    Object.assign(La.prototype, Pe.prototype),
    Object.assign(Ia.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new Ia(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: 'FogExp2',
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(Oa.prototype, {
        isFog: !0,
        clone: function() {
            return new Oa(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: 'Fog',
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    Object.defineProperty(ja.prototype, 'needsUpdate', {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(ja.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.usage = t.usage,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (var i = 0, r = this.stride; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        }
    }),
    Object.defineProperties(Na.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(Na.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this.data.array[t + 3] = r,
            this
        }
    }),
    ka.prototype = Object.create(pi.prototype),
    ka.prototype.constructor = ka,
    ka.prototype.isSpriteMaterial = !0,
    ka.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.rotation = t.rotation,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
    ;
    var Fa = new Oe
      , za = new Oe
      , Ra = new Oe
      , Ua = new Te
      , Ba = new Te
      , Va = new Ze
      , Ga = new Oe
      , Ha = new Oe
      , Wa = new Oe
      , Xa = new Te
      , qa = new Te
      , Ya = new Te;
    function Ja(t) {
        if (mn.call(this),
        this.type = 'Sprite',
        void 0 === Pa) {
            Pa = new Oi;
            var e = new ja(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            Pa.setIndex([0, 1, 2, 0, 2, 3]),
            Pa.setAttribute('position', new Na(e,3,0,!1)),
            Pa.setAttribute('uv', new Na(e,2,3,!1))
        }
        this.geometry = Pa,
        this.material = void 0 !== t ? t : new ka,
        this.center = new Te(.5,.5)
    }
    function Za(t, e, n, i, r, o) {
        Ua.subVectors(t, n).addScalar(.5).multiply(i),
        void 0 !== r ? (Ba.x = o * Ua.x - r * Ua.y,
        Ba.y = r * Ua.x + o * Ua.y) : Ba.copy(Ua),
        t.copy(e),
        t.x += Ba.x,
        t.y += Ba.y,
        t.applyMatrix4(Va)
    }
    Ja.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Ja,
        isSprite: !0,
        raycast: function(t, e) {
            t.camera,
            za.setFromMatrixScale(this.matrixWorld),
            Va.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
            Ra.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && za.multiplyScalar(-Ra.z);
            var n, i, r = this.material.rotation;
            0 !== r && (i = Math.cos(r),
            n = Math.sin(r));
            var o = this.center;
            Za(Ga.set(-.5, -.5, 0), Ra, o, za, n, i),
            Za(Ha.set(.5, -.5, 0), Ra, o, za, n, i),
            Za(Wa.set(.5, .5, 0), Ra, o, za, n, i),
            Xa.set(0, 0),
            qa.set(1, 0),
            Ya.set(1, 1);
            var a = t.ray.intersectTriangle(Ga, Ha, Wa, !1, Fa);
            if (null !== a || (Za(Ha.set(-.5, .5, 0), Ra, o, za, n, i),
            qa.set(0, 1),
            null !== (a = t.ray.intersectTriangle(Ga, Wa, Ha, !1, Fa)))) {
                var s = t.ray.origin.distanceTo(Fa);
                s < t.near || s > t.far || e.push({
                    distance: s,
                    point: Fa.clone(),
                    uv: ni.getUV(Fa, Ga, Ha, Wa, Xa, qa, Ya, new Te),
                    face: null,
                    object: this
                })
            }
        },
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return mn.prototype.copy.call(this, t),
            void 0 !== t.center && this.center.copy(t.center),
            this
        }
    });
    var Ka = new Oe
      , Qa = new Oe;
    function $a() {
        mn.call(this),
        this.type = 'LOD',
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }),
        this.autoUpdate = !0
    }
    function ts(t, e) {
        t && t.isGeometry,
        Ki.call(this, t, e),
        this.type = 'SkinnedMesh',
        this.bindMode = 'attached',
        this.bindMatrix = new Ze,
        this.bindMatrixInverse = new Ze
    }
    $a.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: $a,
        isLOD: !0,
        copy: function(t) {
            mn.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                var r = e[n];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this.autoUpdate = t.autoUpdate,
            this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0),
            e = Math.abs(e);
            for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++)
                ;
            return n.splice(i, 0, {
                distance: e,
                object: t
            }),
            this.add(t),
            this
        },
        getObjectForDistance: function(t) {
            var e = this.levels;
            if (e.length > 0) {
                for (var n = 1, i = e.length; n < i && !(t < e[n].distance); n++)
                    ;
                return e[n - 1].object
            }
            return null
        },
        raycast: function(t, e) {
            if (this.levels.length > 0) {
                Ka.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(Ka);
                this.getObjectForDistance(n).raycast(t, e)
            }
        },
        update: function(t) {
            var e = this.levels;
            if (e.length > 1) {
                Ka.setFromMatrixPosition(t.matrixWorld),
                Qa.setFromMatrixPosition(this.matrixWorld);
                var n = Ka.distanceTo(Qa);
                e[0].object.visible = !0;
                for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++)
                    e[i - 1].object.visible = !1,
                    e[i].object.visible = !0;
                for (; i < r; i++)
                    e[i].object.visible = !1
            }
        },
        toJSON: function(t) {
            var e = mn.prototype.toJSON.call(this, t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            e.object.levels = [];
            for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                var o = n[i];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    }),
    ts.prototype = Object.assign(Object.create(Ki.prototype), {
        constructor: ts,
        isSkinnedMesh: !0,
        bind: function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var t = new Ue, e = this.geometry.attributes.skinWeight, n = 0, i = e.count; n < i; n++) {
                t.x = e.getX(n),
                t.y = e.getY(n),
                t.z = e.getZ(n),
                t.w = e.getW(n);
                var r = 1 / t.manhattanLength();
                r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function(t) {
            Ki.prototype.updateMatrixWorld.call(this, t),
            'attached' === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : 'detached' === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var es = new Ze
      , ns = new Ze;
    function is(t, e) {
        if (t = t || [],
        this.bones = t.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        this.frame = -1,
        void 0 === e)
            this.calculateInverses();
        else if (this.bones.length === e.length)
            this.boneInverses = e.slice(0);
        else {
            this.boneInverses = [];
            for (var n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new Ze)
        }
    }
    function rs() {
        mn.call(this),
        this.type = 'Bone'
    }
    Object.assign(is.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new Ze;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(n)
            }
        },
        pose: function() {
            var t, e, n;
            for (e = 0,
            n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0,
            n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = t.length; r < o; r++) {
                var a = t[r] ? t[r].matrixWorld : ns;
                es.multiplyMatrices(a, e[r]),
                es.toArray(n, 16 * r)
            }
            void 0 !== i && (i.needsUpdate = !0)
        },
        clone: function() {
            return new is(this.bones,this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
                var i = this.bones[e];
                if (i.name === t)
                    return i
            }
        }
    }),
    rs.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: rs,
        isBone: !0
    });
    var os = new Ze
      , as = new Ze
      , ss = []
      , ls = new Ki;
    function cs(t, e, n) {
        Ki.call(this, t, e),
        this.instanceMatrix = new fi(new Float32Array(16 * n),16),
        this.count = n
    }
    function hs(t) {
        pi.call(this),
        this.type = 'LineBasicMaterial',
        this.color = new ai(16777215),
        this.linewidth = 1,
        this.linecap = 'round',
        this.linejoin = 'round',
        this.setValues(t)
    }
    cs.prototype = Object.assign(Object.create(Ki.prototype), {
        constructor: cs,
        isInstancedMesh: !0,
        getMatrixAt: function(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        },
        raycast: function(t, e) {
            var n = this.matrixWorld
              , i = this.count;
            if (ls.geometry = this.geometry,
            ls.material = this.material,
            void 0 !== ls.material)
                for (var r = 0; r < i; r++)
                    this.getMatrixAt(r, os),
                    as.multiplyMatrices(n, os),
                    ls.matrixWorld = as,
                    ls.raycast(t, ss),
                    ss.length > 0 && (ss[0].instanceId = r,
                    ss[0].object = this,
                    e.push(ss[0]),
                    ss.length = 0)
        },
        setMatrixAt: function(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        },
        updateMorphTargets: function() {}
    }),
    hs.prototype = Object.create(pi.prototype),
    hs.prototype.constructor = hs,
    hs.prototype.isLineBasicMaterial = !0,
    hs.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this
    }
    ;
    var us = new Oe
      , ps = new Oe
      , ds = new Ze
      , fs = new Bn
      , ms = new On;
    function gs(t, e, n) {
        mn.call(this),
        this.type = 'Line',
        this.geometry = void 0 !== t ? t : new Oi,
        this.material = void 0 !== e ? e : new hs({
            color: 16777215 * Math.random()
        })
    }
    gs.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: gs,
        isLine: !0,
        computeLineDistances: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [0], i = 1, r = e.count; i < r; i++)
                        us.fromBufferAttribute(e, i - 1),
                        ps.fromBufferAttribute(e, i),
                        n[i] = n[i - 1],
                        n[i] += us.distanceTo(ps);
                    t.setAttribute('lineDistance', new Mi(n,1))
                }
            } else if (t.isGeometry) {
                var o = t.vertices;
                (n = t.lineDistances)[0] = 0;
                for (i = 1,
                r = o.length; i < r; i++)
                    n[i] = n[i - 1],
                    n[i] += o[i - 1].distanceTo(o[i])
            }
            return this
        },
        raycast: function(t, e) {
            var n = t.linePrecision
              , i = this.geometry
              , r = this.matrixWorld;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
            ms.copy(i.boundingSphere),
            ms.applyMatrix4(r),
            ms.radius += n,
            !1 !== t.ray.intersectsSphere(ms)) {
                ds.getInverse(r),
                fs.copy(t.ray).applyMatrix4(ds);
                var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o
                  , s = new Oe
                  , l = new Oe
                  , c = new Oe
                  , h = new Oe
                  , u = this && this.isLineSegments ? 2 : 1;
                if (i.isBufferGeometry) {
                    var p = i.index
                      , d = i.attributes.position.array;
                    if (null !== p)
                        for (var f = p.array, m = 0, g = f.length - 1; m < g; m += u) {
                            var v = f[m]
                              , y = f[m + 1];
                            if (s.fromArray(d, 3 * v),
                            l.fromArray(d, 3 * y),
                            !(fs.distanceSqToSegment(s, l, h, c) > a))
                                h.applyMatrix4(this.matrixWorld),
                                (_ = t.ray.origin.distanceTo(h)) < t.near || _ > t.far || e.push({
                                    distance: _,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                    else
                        for (m = 0,
                        g = d.length / 3 - 1; m < g; m += u) {
                            if (s.fromArray(d, 3 * m),
                            l.fromArray(d, 3 * m + 3),
                            !(fs.distanceSqToSegment(s, l, h, c) > a))
                                h.applyMatrix4(this.matrixWorld),
                                (_ = t.ray.origin.distanceTo(h)) < t.near || _ > t.far || e.push({
                                    distance: _,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                } else if (i.isGeometry) {
                    var x = i.vertices
                      , b = x.length;
                    for (m = 0; m < b - 1; m += u) {
                        var _;
                        if (!(fs.distanceSqToSegment(x[m], x[m + 1], h, c) > a))
                            h.applyMatrix4(this.matrixWorld),
                            (_ = t.ray.origin.distanceTo(h)) < t.near || _ > t.far || e.push({
                                distance: _,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: m,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                    }
                }
            }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var vs = new Oe
      , ys = new Oe;
    function xs(t, e) {
        gs.call(this, t, e),
        this.type = 'LineSegments'
    }
    function bs(t, e) {
        gs.call(this, t, e),
        this.type = 'LineLoop'
    }
    function _s(t) {
        pi.call(this),
        this.type = 'PointsMaterial',
        this.color = new ai(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.setValues(t)
    }
    xs.prototype = Object.assign(Object.create(gs.prototype), {
        constructor: xs,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                if (null === t.index) {
                    for (var e = t.attributes.position, n = [], i = 0, r = e.count; i < r; i += 2)
                        vs.fromBufferAttribute(e, i),
                        ys.fromBufferAttribute(e, i + 1),
                        n[i] = 0 === i ? 0 : n[i - 1],
                        n[i + 1] = n[i] + vs.distanceTo(ys);
                    t.setAttribute('lineDistance', new Mi(n,1))
                }
            } else if (t.isGeometry) {
                var o = t.vertices;
                for (n = t.lineDistances,
                i = 0,
                r = o.length; i < r; i += 2)
                    vs.copy(o[i]),
                    ys.copy(o[i + 1]),
                    n[i] = 0 === i ? 0 : n[i - 1],
                    n[i + 1] = n[i] + vs.distanceTo(ys)
            }
            return this
        }
    }),
    bs.prototype = Object.assign(Object.create(gs.prototype), {
        constructor: bs,
        isLineLoop: !0
    }),
    _s.prototype = Object.create(pi.prototype),
    _s.prototype.constructor = _s,
    _s.prototype.isPointsMaterial = !0,
    _s.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this.morphTargets = t.morphTargets,
        this
    }
    ;
    var Ms = new Ze
      , ws = new Bn
      , Ss = new On
      , Ps = new Oe;
    function Cs(t, e) {
        mn.call(this),
        this.type = 'Points',
        this.geometry = void 0 !== t ? t : new Oi,
        this.material = void 0 !== e ? e : new _s({
            color: 16777215 * Math.random()
        }),
        this.updateMorphTargets()
    }
    function As(t, e, n, i, r, o, a) {
        var s = ws.distanceSqToPoint(t);
        if (s < n) {
            var l = new Oe;
            ws.closestPointToPoint(t, l),
            l.applyMatrix4(i);
            var c = r.ray.origin.distanceTo(l);
            if (c < r.near || c > r.far)
                return;
            o.push({
                distance: c,
                distanceToRay: Math.sqrt(s),
                point: l,
                index: e,
                face: null,
                object: a
            })
        }
    }
    function Es(t, e, n, i, r, o, a, s, l) {
        Re.call(this, t, e, n, i, r, o, a, s, l),
        this.format = void 0 !== a ? a : Tt,
        this.minFilter = void 0 !== o ? o : dt,
        this.magFilter = void 0 !== r ? r : dt,
        this.generateMipmaps = !1
    }
    function Ts(t, e, n, i, r, o, a, s, l, c, h, u) {
        Re.call(this, null, o, a, s, l, c, i, r, h, u),
        this.image = {
            width: e,
            height: n
        },
        this.mipmaps = t,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Ls(t, e, n, i, r, o, a, s, l) {
        Re.call(this, t, e, n, i, r, o, a, s, l),
        this.needsUpdate = !0
    }
    function Ds(t, e, n, i, r, o, a, s, l, c) {
        if ((c = void 0 !== c ? c : Ot) !== Ot && c !== jt)
            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        void 0 === n && c === Ot && (n = xt),
        void 0 === n && c === jt && (n = At),
        Re.call(this, null, i, r, o, a, s, c, n, l),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = void 0 !== a ? a : ht,
        this.minFilter = void 0 !== s ? s : ht,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Is(t) {
        Oi.call(this),
        this.type = 'WireframeGeometry';
        var e, n, i, r, o, a, s, l, c, h, u = [], p = [0, 0], d = {}, f = ['a', 'b', 'c'];
        if (t && t.isGeometry) {
            var m = t.faces;
            for (e = 0,
            i = m.length; e < i; e++) {
                var g = m[e];
                for (n = 0; n < 3; n++)
                    s = g[f[n]],
                    l = g[f[(n + 1) % 3]],
                    p[0] = Math.min(s, l),
                    p[1] = Math.max(s, l),
                    void 0 === d[c = p[0] + ',' + p[1]] && (d[c] = {
                        index1: p[0],
                        index2: p[1]
                    })
            }
            for (c in d)
                a = d[c],
                h = t.vertices[a.index1],
                u.push(h.x, h.y, h.z),
                h = t.vertices[a.index2],
                u.push(h.x, h.y, h.z)
        } else if (t && t.isBufferGeometry) {
            var v, y, x, b, _, M, w;
            if (h = new Oe,
            null !== t.index) {
                for (v = t.attributes.position,
                y = t.index,
                0 === (x = t.groups).length && (x = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                r = 0,
                o = x.length; r < o; ++r)
                    for (e = _ = (b = x[r]).start,
                    i = _ + b.count; e < i; e += 3)
                        for (n = 0; n < 3; n++)
                            s = y.getX(e + n),
                            l = y.getX(e + (n + 1) % 3),
                            p[0] = Math.min(s, l),
                            p[1] = Math.max(s, l),
                            void 0 === d[c = p[0] + ',' + p[1]] && (d[c] = {
                                index1: p[0],
                                index2: p[1]
                            });
                for (c in d)
                    a = d[c],
                    h.fromBufferAttribute(v, a.index1),
                    u.push(h.x, h.y, h.z),
                    h.fromBufferAttribute(v, a.index2),
                    u.push(h.x, h.y, h.z)
            } else
                for (e = 0,
                i = (v = t.attributes.position).count / 3; e < i; e++)
                    for (n = 0; n < 3; n++)
                        M = 3 * e + n,
                        h.fromBufferAttribute(v, M),
                        u.push(h.x, h.y, h.z),
                        w = 3 * e + (n + 1) % 3,
                        h.fromBufferAttribute(v, w),
                        u.push(h.x, h.y, h.z)
        }
        this.setAttribute('position', new Mi(u,3))
    }
    function Os(t, e, n) {
        rr.call(this),
        this.type = 'ParametricGeometry',
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        },
        this.fromBufferGeometry(new js(t,e,n)),
        this.mergeVertices()
    }
    function js(t, e, n) {
        Oi.call(this),
        this.type = 'ParametricBufferGeometry',
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        var i, r, o = [], a = [], s = [], l = [], c = new Oe, h = new Oe, u = new Oe, p = new Oe, d = new Oe;
        t.length;
        var f = e + 1;
        for (i = 0; i <= n; i++) {
            var m = i / n;
            for (r = 0; r <= e; r++) {
                var g = r / e;
                t(g, m, h),
                a.push(h.x, h.y, h.z),
                g - 1e-5 >= 0 ? (t(g - 1e-5, m, u),
                p.subVectors(h, u)) : (t(g + 1e-5, m, u),
                p.subVectors(u, h)),
                m - 1e-5 >= 0 ? (t(g, m - 1e-5, u),
                d.subVectors(h, u)) : (t(g, m + 1e-5, u),
                d.subVectors(u, h)),
                c.crossVectors(p, d).normalize(),
                s.push(c.x, c.y, c.z),
                l.push(g, m)
            }
        }
        for (i = 0; i < n; i++)
            for (r = 0; r < e; r++) {
                var v = i * f + r
                  , y = i * f + r + 1
                  , x = (i + 1) * f + r + 1
                  , b = (i + 1) * f + r;
                o.push(v, y, b),
                o.push(y, x, b)
            }
        this.setIndex(o),
        this.setAttribute('position', new Mi(a,3)),
        this.setAttribute('normal', new Mi(s,3)),
        this.setAttribute('uv', new Mi(l,2))
    }
    function Ns(t, e, n, i) {
        rr.call(this),
        this.type = 'PolyhedronGeometry',
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        },
        this.fromBufferGeometry(new ks(t,e,n,i)),
        this.mergeVertices()
    }
    function ks(t, e, n, i) {
        Oi.call(this),
        this.type = 'PolyhedronBufferGeometry',
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        },
        n = n || 1;
        var r = []
          , o = [];
        function a(t, e, n, i) {
            var r, o, a = Math.pow(2, i), l = [];
            for (r = 0; r <= a; r++) {
                l[r] = [];
                var c = t.clone().lerp(n, r / a)
                  , h = e.clone().lerp(n, r / a)
                  , u = a - r;
                for (o = 0; o <= u; o++)
                    l[r][o] = 0 === o && r === a ? c : c.clone().lerp(h, o / u)
            }
            for (r = 0; r < a; r++)
                for (o = 0; o < 2 * (a - r) - 1; o++) {
                    var p = Math.floor(o / 2);
                    o % 2 == 0 ? (s(l[r][p + 1]),
                    s(l[r + 1][p]),
                    s(l[r][p])) : (s(l[r][p + 1]),
                    s(l[r + 1][p + 1]),
                    s(l[r + 1][p]))
                }
        }
        function s(t) {
            r.push(t.x, t.y, t.z)
        }
        function l(e, n) {
            var i = 3 * e;
            n.x = t[i + 0],
            n.y = t[i + 1],
            n.z = t[i + 2]
        }
        function c(t, e, n, i) {
            i < 0 && 1 === t.x && (o[e] = t.x - 1),
            0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
        }
        function h(t) {
            return Math.atan2(t.z, -t.x)
        }
        !function(t) {
            for (var n = new Oe, i = new Oe, r = new Oe, o = 0; o < e.length; o += 3)
                l(e[o + 0], n),
                l(e[o + 1], i),
                l(e[o + 2], r),
                a(n, i, r, t)
        }(i = i || 0),
        function(t) {
            for (var e = new Oe, n = 0; n < r.length; n += 3)
                e.x = r[n + 0],
                e.y = r[n + 1],
                e.z = r[n + 2],
                e.normalize().multiplyScalar(t),
                r[n + 0] = e.x,
                r[n + 1] = e.y,
                r[n + 2] = e.z
        }(n),
        function() {
            for (var t = new Oe, e = 0; e < r.length; e += 3) {
                t.x = r[e + 0],
                t.y = r[e + 1],
                t.z = r[e + 2];
                var n = h(t) / 2 / Math.PI + .5
                  , i = (a = t,
                Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                o.push(n, 1 - i)
            }
            var a;
            (function() {
                for (var t = new Oe, e = new Oe, n = new Oe, i = new Oe, a = new Te, s = new Te, l = new Te, u = 0, p = 0; u < r.length; u += 9,
                p += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]),
                    e.set(r[u + 3], r[u + 4], r[u + 5]),
                    n.set(r[u + 6], r[u + 7], r[u + 8]),
                    a.set(o[p + 0], o[p + 1]),
                    s.set(o[p + 2], o[p + 3]),
                    l.set(o[p + 4], o[p + 5]),
                    i.copy(t).add(e).add(n).divideScalar(3);
                    var d = h(i);
                    c(a, p + 0, t, d),
                    c(s, p + 2, e, d),
                    c(l, p + 4, n, d)
                }
            }
            )(),
            function() {
                for (var t = 0; t < o.length; t += 6) {
                    var e = o[t + 0]
                      , n = o[t + 2]
                      , i = o[t + 4]
                      , r = Math.max(e, n, i)
                      , a = Math.min(e, n, i);
                    r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1),
                    n < .2 && (o[t + 2] += 1),
                    i < .2 && (o[t + 4] += 1))
                }
            }()
        }(),
        this.setAttribute('position', new Mi(r,3)),
        this.setAttribute('normal', new Mi(r.slice(),3)),
        this.setAttribute('uv', new Mi(o,2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function Fs(t, e) {
        rr.call(this),
        this.type = 'TetrahedronGeometry',
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new zs(t,e)),
        this.mergeVertices()
    }
    function zs(t, e) {
        ks.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
        this.type = 'TetrahedronBufferGeometry',
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Rs(t, e) {
        rr.call(this),
        this.type = 'OctahedronGeometry',
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Us(t,e)),
        this.mergeVertices()
    }
    function Us(t, e) {
        ks.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e),
        this.type = 'OctahedronBufferGeometry',
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Bs(t, e) {
        rr.call(this),
        this.type = 'IcosahedronGeometry',
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Vs(t,e)),
        this.mergeVertices()
    }
    function Vs(t, e) {
        var n = (1 + Math.sqrt(5)) / 2
          , i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        ks.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e),
        this.type = 'IcosahedronBufferGeometry',
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Gs(t, e) {
        rr.call(this),
        this.type = 'DodecahedronGeometry',
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Hs(t,e)),
        this.mergeVertices()
    }
    function Hs(t, e) {
        var n = (1 + Math.sqrt(5)) / 2
          , i = 1 / n
          , r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
        ks.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e),
        this.type = 'DodecahedronBufferGeometry',
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ws(t, e, n, i, r, o) {
        rr.call(this),
        this.type = 'TubeGeometry',
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        };
        var a = new Xs(t,e,n,i,r);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function Xs(t, e, n, i, r) {
        Oi.call(this),
        this.type = 'TubeBufferGeometry',
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: i,
            closed: r
        },
        e = e || 64,
        n = n || 1,
        i = i || 8,
        r = r || !1;
        var o = t.computeFrenetFrames(e, r);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        var a, s, l = new Oe, c = new Oe, h = new Te, u = new Oe, p = [], d = [], f = [], m = [];
        function g(r) {
            u = t.getPointAt(r / e, u);
            var a = o.normals[r]
              , h = o.binormals[r];
            for (s = 0; s <= i; s++) {
                var f = s / i * Math.PI * 2
                  , m = Math.sin(f)
                  , g = -Math.cos(f);
                c.x = g * a.x + m * h.x,
                c.y = g * a.y + m * h.y,
                c.z = g * a.z + m * h.z,
                c.normalize(),
                d.push(c.x, c.y, c.z),
                l.x = u.x + n * c.x,
                l.y = u.y + n * c.y,
                l.z = u.z + n * c.z,
                p.push(l.x, l.y, l.z)
            }
        }
        !function() {
            for (a = 0; a < e; a++)
                g(a);
            g(!1 === r ? e : 0),
            function() {
                for (a = 0; a <= e; a++)
                    for (s = 0; s <= i; s++)
                        h.x = a / e,
                        h.y = s / i,
                        f.push(h.x, h.y)
            }(),
            function() {
                for (s = 1; s <= e; s++)
                    for (a = 1; a <= i; a++) {
                        var t = (i + 1) * (s - 1) + (a - 1)
                          , n = (i + 1) * s + (a - 1)
                          , r = (i + 1) * s + a
                          , o = (i + 1) * (s - 1) + a;
                        m.push(t, n, o),
                        m.push(n, r, o)
                    }
            }()
        }(),
        this.setIndex(m),
        this.setAttribute('position', new Mi(p,3)),
        this.setAttribute('normal', new Mi(d,3)),
        this.setAttribute('uv', new Mi(f,2))
    }
    function qs(t, e, n, i, r, o, a) {
        rr.call(this),
        this.type = 'TorusKnotGeometry',
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        },
        this.fromBufferGeometry(new Ys(t,e,n,i,r,o)),
        this.mergeVertices()
    }
    function Ys(t, e, n, i, r, o) {
        Oi.call(this),
        this.type = 'TorusKnotBufferGeometry',
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: o
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 64,
        i = Math.floor(i) || 8,
        r = r || 2,
        o = o || 3;
        var a, s, l = [], c = [], h = [], u = [], p = new Oe, d = new Oe, f = new Oe, m = new Oe, g = new Oe, v = new Oe, y = new Oe;
        for (a = 0; a <= n; ++a) {
            var x = a / n * r * Math.PI * 2;
            for (A(x, r, o, t, f),
            A(x + .01, r, o, t, m),
            v.subVectors(m, f),
            y.addVectors(m, f),
            g.crossVectors(v, y),
            y.crossVectors(g, v),
            g.normalize(),
            y.normalize(),
            s = 0; s <= i; ++s) {
                var b = s / i * Math.PI * 2
                  , _ = -e * Math.cos(b)
                  , M = e * Math.sin(b);
                p.x = f.x + (_ * y.x + M * g.x),
                p.y = f.y + (_ * y.y + M * g.y),
                p.z = f.z + (_ * y.z + M * g.z),
                c.push(p.x, p.y, p.z),
                d.subVectors(p, f).normalize(),
                h.push(d.x, d.y, d.z),
                u.push(a / n),
                u.push(s / i)
            }
        }
        for (s = 1; s <= n; s++)
            for (a = 1; a <= i; a++) {
                var w = (i + 1) * (s - 1) + (a - 1)
                  , S = (i + 1) * s + (a - 1)
                  , P = (i + 1) * s + a
                  , C = (i + 1) * (s - 1) + a;
                l.push(w, S, C),
                l.push(S, P, C)
            }
        function A(t, e, n, i, r) {
            var o = Math.cos(t)
              , a = Math.sin(t)
              , s = n / e * t
              , l = Math.cos(s);
            r.x = i * (2 + l) * .5 * o,
            r.y = i * (2 + l) * a * .5,
            r.z = i * Math.sin(s) * .5
        }
        this.setIndex(l),
        this.setAttribute('position', new Mi(c,3)),
        this.setAttribute('normal', new Mi(h,3)),
        this.setAttribute('uv', new Mi(u,2))
    }
    function Js(t, e, n, i, r) {
        rr.call(this),
        this.type = 'TorusGeometry',
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        this.fromBufferGeometry(new Zs(t,e,n,i,r)),
        this.mergeVertices()
    }
    function Zs(t, e, n, i, r) {
        Oi.call(this),
        this.type = 'TorusBufferGeometry',
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 8,
        i = Math.floor(i) || 6,
        r = r || 2 * Math.PI;
        var o, a, s = [], l = [], c = [], h = [], u = new Oe, p = new Oe, d = new Oe;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= i; a++) {
                var f = a / i * r
                  , m = o / n * Math.PI * 2;
                p.x = (t + e * Math.cos(m)) * Math.cos(f),
                p.y = (t + e * Math.cos(m)) * Math.sin(f),
                p.z = e * Math.sin(m),
                l.push(p.x, p.y, p.z),
                u.x = t * Math.cos(f),
                u.y = t * Math.sin(f),
                d.subVectors(p, u).normalize(),
                c.push(d.x, d.y, d.z),
                h.push(a / i),
                h.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= i; a++) {
                var g = (i + 1) * o + a - 1
                  , v = (i + 1) * (o - 1) + a - 1
                  , y = (i + 1) * (o - 1) + a
                  , x = (i + 1) * o + a;
                s.push(g, v, x),
                s.push(v, y, x)
            }
        this.setIndex(s),
        this.setAttribute('position', new Mi(l,3)),
        this.setAttribute('normal', new Mi(c,3)),
        this.setAttribute('uv', new Mi(h,2))
    }
    Cs.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Cs,
        isPoints: !0,
        raycast: function(t, e) {
            var n = this.geometry
              , i = this.matrixWorld
              , r = t.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Ss.copy(n.boundingSphere),
            Ss.applyMatrix4(i),
            Ss.radius += r,
            !1 !== t.ray.intersectsSphere(Ss)) {
                Ms.getInverse(i),
                ws.copy(t.ray).applyMatrix4(Ms);
                var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o;
                if (n.isBufferGeometry) {
                    var s = n.index
                      , l = n.attributes.position.array;
                    if (null !== s)
                        for (var c = s.array, h = 0, u = c.length; h < u; h++) {
                            var p = c[h];
                            Ps.fromArray(l, 3 * p),
                            As(Ps, p, a, i, t, e, this)
                        }
                    else {
                        h = 0;
                        for (var d = l.length / 3; h < d; h++)
                            Ps.fromArray(l, 3 * h),
                            As(Ps, h, a, i, t, e, this)
                    }
                } else {
                    var f = n.vertices;
                    for (h = 0,
                    d = f.length; h < d; h++)
                        As(f[h], h, a, i, t, e, this)
                }
            }
        },
        updateMorphTargets: function() {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes
                  , o = Object.keys(r);
                if (o.length > 0) {
                    var a = r[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        t = 0,
                        e = a.length; t < e; t++)
                            n = a[t].name || String(t),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                }
            } else {
                var s = i.morphTargets;
                void 0 !== s && s.length
            }
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Es.prototype = Object.assign(Object.create(Re.prototype), {
        constructor: Es,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    Ts.prototype = Object.create(Re.prototype),
    Ts.prototype.constructor = Ts,
    Ts.prototype.isCompressedTexture = !0,
    Ls.prototype = Object.create(Re.prototype),
    Ls.prototype.constructor = Ls,
    Ls.prototype.isCanvasTexture = !0,
    Ds.prototype = Object.create(Re.prototype),
    Ds.prototype.constructor = Ds,
    Ds.prototype.isDepthTexture = !0,
    Is.prototype = Object.create(Oi.prototype),
    Is.prototype.constructor = Is,
    Os.prototype = Object.create(rr.prototype),
    Os.prototype.constructor = Os,
    js.prototype = Object.create(Oi.prototype),
    js.prototype.constructor = js,
    Ns.prototype = Object.create(rr.prototype),
    Ns.prototype.constructor = Ns,
    ks.prototype = Object.create(Oi.prototype),
    ks.prototype.constructor = ks,
    Fs.prototype = Object.create(rr.prototype),
    Fs.prototype.constructor = Fs,
    zs.prototype = Object.create(ks.prototype),
    zs.prototype.constructor = zs,
    Rs.prototype = Object.create(rr.prototype),
    Rs.prototype.constructor = Rs,
    Us.prototype = Object.create(ks.prototype),
    Us.prototype.constructor = Us,
    Bs.prototype = Object.create(rr.prototype),
    Bs.prototype.constructor = Bs,
    Vs.prototype = Object.create(ks.prototype),
    Vs.prototype.constructor = Vs,
    Gs.prototype = Object.create(rr.prototype),
    Gs.prototype.constructor = Gs,
    Hs.prototype = Object.create(ks.prototype),
    Hs.prototype.constructor = Hs,
    Ws.prototype = Object.create(rr.prototype),
    Ws.prototype.constructor = Ws,
    Xs.prototype = Object.create(Oi.prototype),
    Xs.prototype.constructor = Xs,
    Xs.prototype.toJSON = function() {
        var t = Oi.prototype.toJSON.call(this);
        return t.path = this.parameters.path.toJSON(),
        t
    }
    ,
    qs.prototype = Object.create(rr.prototype),
    qs.prototype.constructor = qs,
    Ys.prototype = Object.create(Oi.prototype),
    Ys.prototype.constructor = Ys,
    Js.prototype = Object.create(rr.prototype),
    Js.prototype.constructor = Js,
    Zs.prototype = Object.create(Oi.prototype),
    Zs.prototype.constructor = Zs;
    var Ks = function(t, e, n) {
        n = n || 2;
        var i, r, o, a, s, l, c, h = e && e.length, u = h ? e[0] * n : t.length, p = Qs(t, 0, u, n, !0), d = [];
        if (!p || p.next === p.prev)
            return d;
        if (h && (p = function(t, e, n, i) {
            var r, o, a, s, l, c = [];
            for (r = 0,
            o = e.length; r < o; r++)
                a = e[r] * i,
                s = r < o - 1 ? e[r + 1] * i : t.length,
                (l = Qs(t, a, s, i, !1)) === l.next && (l.steiner = !0),
                c.push(ll(l));
            for (c.sort(ol),
            r = 0; r < c.length; r++)
                al(c[r], n),
                n = $s(n, n.next);
            return n
        }(t, e, p, n)),
        t.length > 80 * n) {
            i = o = t[0],
            r = a = t[1];
            for (var f = n; f < u; f += n)
                (s = t[f]) < i && (i = s),
                (l = t[f + 1]) < r && (r = l),
                s > o && (o = s),
                l > a && (a = l);
            c = 0 !== (c = Math.max(o - i, a - r)) ? 1 / c : 0
        }
        return tl(p, d, n, i, r, c),
        d
    };
    function Qs(t, e, n, i, r) {
        var o, a;
        if (r === function(t, e, n, i) {
            for (var r = 0, o = e, a = n - i; o < n; o += i)
                r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]),
                a = o;
            return r
        }(t, e, n, i) > 0)
            for (o = e; o < n; o += i)
                a = gl(o, t[o], t[o + 1], a);
        else
            for (o = n - i; o >= e; o -= i)
                a = gl(o, t[o], t[o + 1], a);
        return a && pl(a, a.next) && (vl(a),
        a = a.next),
        a
    }
    function $s(t, e) {
        if (!t)
            return t;
        e || (e = t);
        var n, i = t;
        do {
            if (n = !1,
            i.steiner || !pl(i, i.next) && 0 !== ul(i.prev, i, i.next))
                i = i.next;
            else {
                if (vl(i),
                (i = e = i.prev) === i.next)
                    break;
                n = !0
            }
        } while (n || i !== e);
        return e
    }
    function tl(t, e, n, i, r, o, a) {
        if (t) {
            !a && o && function(t, e, n, i) {
                var r = t;
                do {
                    null === r.z && (r.z = sl(r.x, r.y, e, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(t) {
                    var e, n, i, r, o, a, s, l, c = 1;
                    do {
                        for (n = t,
                        t = null,
                        o = null,
                        a = 0; n; ) {
                            for (a++,
                            i = n,
                            s = 0,
                            e = 0; e < c && (s++,
                            i = i.nextZ); e++)
                                ;
                            for (l = c; s > 0 || l > 0 && i; )
                                0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                s--) : (r = i,
                                i = i.nextZ,
                                l--),
                                o ? o.nextZ = r : t = r,
                                r.prevZ = o,
                                o = r;
                            n = i
                        }
                        o.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(r)
            }(t, i, r, o);
            for (var s, l, c = t; t.prev !== t.next; )
                if (s = t.prev,
                l = t.next,
                o ? nl(t, i, r, o) : el(t))
                    e.push(s.i / n),
                    e.push(t.i / n),
                    e.push(l.i / n),
                    vl(t),
                    t = l.next,
                    c = l.next;
                else if ((t = l) === c) {
                    a ? 1 === a ? tl(t = il(t, e, n), e, n, i, r, o, 2) : 2 === a && rl(t, e, n, i, r, o) : tl($s(t), e, n, i, r, o, 1);
                    break
                }
        }
    }
    function el(t) {
        var e = t.prev
          , n = t
          , i = t.next;
        if (ul(e, n, i) >= 0)
            return !1;
        for (var r = t.next.next; r !== t.prev; ) {
            if (cl(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && ul(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function nl(t, e, n, i) {
        var r = t.prev
          , o = t
          , a = t.next;
        if (ul(r, o, a) >= 0)
            return !1;
        for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, c = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = sl(s, l, e, n, i), p = sl(c, h, e, n, i), d = t.prevZ, f = t.nextZ; d && d.z >= u && f && f.z <= p; ) {
            if (d !== t.prev && d !== t.next && cl(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && ul(d.prev, d, d.next) >= 0)
                return !1;
            if (d = d.prevZ,
            f !== t.prev && f !== t.next && cl(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && ul(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        for (; d && d.z >= u; ) {
            if (d !== t.prev && d !== t.next && cl(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && ul(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        for (; f && f.z <= p; ) {
            if (f !== t.prev && f !== t.next && cl(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && ul(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        return !0
    }
    function il(t, e, n) {
        var i = t;
        do {
            var r = i.prev
              , o = i.next.next;
            !pl(r, o) && dl(r, i, i.next, o) && fl(r, o) && fl(o, r) && (e.push(r.i / n),
            e.push(i.i / n),
            e.push(o.i / n),
            vl(i),
            vl(i.next),
            i = t = o),
            i = i.next
        } while (i !== t);
        return i
    }
    function rl(t, e, n, i, r, o) {
        var a = t;
        do {
            for (var s = a.next.next; s !== a.prev; ) {
                if (a.i !== s.i && hl(a, s)) {
                    var l = ml(a, s);
                    return a = $s(a, a.next),
                    l = $s(l, l.next),
                    tl(a, e, n, i, r, o),
                    void tl(l, e, n, i, r, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== t)
    }
    function ol(t, e) {
        return t.x - e.x
    }
    function al(t, e) {
        if (e = function(t, e) {
            var n, i = e, r = t.x, o = t.y, a = -1 / 0;
            do {
                if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                    var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (s <= r && s > a) {
                        if (a = s,
                        s === r) {
                            if (o === i.y)
                                return i;
                            if (o === i.next.y)
                                return i.next
                        }
                        n = i.x < i.next.x ? i : i.next
                    }
                }
                i = i.next
            } while (i !== e);
            if (!n)
                return null;
            if (r === a)
                return n.prev;
            var l, c = n, h = n.x, u = n.y, p = 1 / 0;
            i = n.next;
            for (; i !== c; )
                r >= i.x && i.x >= h && r !== i.x && cl(o < u ? r : a, o, h, u, o < u ? a : r, o, i.x, i.y) && ((l = Math.abs(o - i.y) / (r - i.x)) < p || l === p && i.x > n.x) && fl(i, t) && (n = i,
                p = l),
                i = i.next;
            return n
        }(t, e)) {
            var n = ml(e, t);
            $s(n, n.next)
        }
    }
    function sl(t, e, n, i, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function ll(t) {
        var e = t
          , n = t;
        do {
            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
            e = e.next
        } while (e !== t);
        return n
    }
    function cl(t, e, n, i, r, o, a, s) {
        return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (i - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
    }
    function hl(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
            var n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && dl(n, n.next, t, e))
                    return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && fl(t, e) && fl(e, t) && function(t, e) {
            var n = t
              , i = !1
              , r = (t.x + e.x) / 2
              , o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                n = n.next
            } while (n !== t);
            return i
        }(t, e)
    }
    function ul(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }
    function pl(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function dl(t, e, n, i) {
        return !!(pl(t, n) && pl(e, i) || pl(t, i) && pl(n, e)) || ul(t, e, n) > 0 != ul(t, e, i) > 0 && ul(n, i, t) > 0 != ul(n, i, e) > 0
    }
    function fl(t, e) {
        return ul(t.prev, t, t.next) < 0 ? ul(t, e, t.next) >= 0 && ul(t, t.prev, e) >= 0 : ul(t, e, t.prev) < 0 || ul(t, t.next, e) < 0
    }
    function ml(t, e) {
        var n = new yl(t.i,t.x,t.y)
          , i = new yl(e.i,e.x,e.y)
          , r = t.next
          , o = e.prev;
        return t.next = e,
        e.prev = t,
        n.next = r,
        r.prev = n,
        i.next = n,
        n.prev = i,
        o.next = i,
        i.prev = o,
        i
    }
    function gl(t, e, n, i) {
        var r = new yl(t,e,n);
        return i ? (r.next = i.next,
        r.prev = i,
        i.next.prev = r,
        i.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function vl(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function yl(t, e, n) {
        this.i = t,
        this.x = e,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var xl = {
        area: function(t) {
            for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
                n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return xl.area(t) < 0
        },
        triangulateShape: function(t, e) {
            var n = []
              , i = []
              , r = [];
            bl(t),
            _l(n, t);
            var o = t.length;
            e.forEach(bl);
            for (var a = 0; a < e.length; a++)
                i.push(o),
                o += e[a].length,
                _l(n, e[a]);
            var s = Ks(n, i);
            for (a = 0; a < s.length; a += 3)
                r.push(s.slice(a, a + 3));
            return r
        }
    };
    function bl(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }
    function _l(t, e) {
        for (var n = 0; n < e.length; n++)
            t.push(e[n].x),
            t.push(e[n].y)
    }
    function Ml(t, e) {
        rr.call(this),
        this.type = 'ExtrudeGeometry',
        this.parameters = {
            shapes: t,
            options: e
        },
        this.fromBufferGeometry(new wl(t,e)),
        this.mergeVertices()
    }
    function wl(t, e) {
        Oi.call(this),
        this.type = 'ExtrudeBufferGeometry',
        this.parameters = {
            shapes: t,
            options: e
        },
        t = Array.isArray(t) ? t : [t];
        for (var n = this, i = [], r = [], o = 0, a = t.length; o < a; o++) {
            s(t[o])
        }
        function s(t) {
            var o = []
              , a = void 0 !== e.curveSegments ? e.curveSegments : 12
              , s = void 0 !== e.steps ? e.steps : 1
              , l = void 0 !== e.depth ? e.depth : 100
              , c = void 0 === e.bevelEnabled || e.bevelEnabled
              , h = void 0 !== e.bevelThickness ? e.bevelThickness : 6
              , u = void 0 !== e.bevelSize ? e.bevelSize : h - 2
              , p = void 0 !== e.bevelOffset ? e.bevelOffset : 0
              , d = void 0 !== e.bevelSegments ? e.bevelSegments : 3
              , f = e.extrudePath
              , m = void 0 !== e.UVGenerator ? e.UVGenerator : Sl;
            void 0 !== e.amount && (l = e.amount);
            var g, v, y, x, b, _, M, w, S = !1;
            f && (g = f.getSpacedPoints(s),
            S = !0,
            c = !1,
            v = f.computeFrenetFrames(s, !1),
            y = new Oe,
            x = new Oe,
            b = new Oe),
            c || (d = 0,
            h = 0,
            u = 0,
            p = 0);
            var P = t.extractPoints(a)
              , C = P.shape
              , A = P.holes;
            if (!xl.isClockWise(C))
                for (C = C.reverse(),
                M = 0,
                w = A.length; M < w; M++)
                    _ = A[M],
                    xl.isClockWise(_) && (A[M] = _.reverse());
            var E = xl.triangulateShape(C, A)
              , T = C;
            for (M = 0,
            w = A.length; M < w; M++)
                _ = A[M],
                C = C.concat(_);
            function L(t, e, n) {
                return e.clone().multiplyScalar(n).add(t)
            }
            var D, I, O, j, N, k, F = C.length, z = E.length;
            function R(t, e, n) {
                var i, r, o, a = t.x - e.x, s = t.y - e.y, l = n.x - t.x, c = n.y - t.y, h = a * a + s * s, u = a * c - s * l;
                if (Math.abs(u) > Number.EPSILON) {
                    var p = Math.sqrt(h)
                      , d = Math.sqrt(l * l + c * c)
                      , f = e.x - s / p
                      , m = e.y + a / p
                      , g = ((n.x - c / d - f) * c - (n.y + l / d - m) * l) / (a * c - s * l)
                      , v = (i = f + a * g - t.x) * i + (r = m + s * g - t.y) * r;
                    if (v <= 2)
                        return new Te(i,r);
                    o = Math.sqrt(v / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0),
                    y ? (i = -s,
                    r = a,
                    o = Math.sqrt(h)) : (i = a,
                    r = s,
                    o = Math.sqrt(h / 2))
                }
                return new Te(i / o,r / o)
            }
            for (var U = [], B = 0, V = T.length, G = V - 1, H = B + 1; B < V; B++,
            G++,
            H++)
                G === V && (G = 0),
                H === V && (H = 0),
                U[B] = R(T[B], T[G], T[H]);
            var W, X, q = [], Y = U.concat();
            for (M = 0,
            w = A.length; M < w; M++) {
                for (_ = A[M],
                W = [],
                B = 0,
                G = (V = _.length) - 1,
                H = B + 1; B < V; B++,
                G++,
                H++)
                    G === V && (G = 0),
                    H === V && (H = 0),
                    W[B] = R(_[B], _[G], _[H]);
                q.push(W),
                Y = Y.concat(W)
            }
            for (D = 0; D < d; D++) {
                for (O = D / d,
                j = h * Math.cos(O * Math.PI / 2),
                I = u * Math.sin(O * Math.PI / 2) + p,
                B = 0,
                V = T.length; B < V; B++)
                    Z((N = L(T[B], U[B], I)).x, N.y, -j);
                for (M = 0,
                w = A.length; M < w; M++)
                    for (_ = A[M],
                    W = q[M],
                    B = 0,
                    V = _.length; B < V; B++)
                        Z((N = L(_[B], W[B], I)).x, N.y, -j)
            }
            for (I = u + p,
            B = 0; B < F; B++)
                N = c ? L(C[B], Y[B], I) : C[B],
                S ? (x.copy(v.normals[0]).multiplyScalar(N.x),
                y.copy(v.binormals[0]).multiplyScalar(N.y),
                b.copy(g[0]).add(x).add(y),
                Z(b.x, b.y, b.z)) : Z(N.x, N.y, 0);
            for (X = 1; X <= s; X++)
                for (B = 0; B < F; B++)
                    N = c ? L(C[B], Y[B], I) : C[B],
                    S ? (x.copy(v.normals[X]).multiplyScalar(N.x),
                    y.copy(v.binormals[X]).multiplyScalar(N.y),
                    b.copy(g[X]).add(x).add(y),
                    Z(b.x, b.y, b.z)) : Z(N.x, N.y, l / s * X);
            for (D = d - 1; D >= 0; D--) {
                for (O = D / d,
                j = h * Math.cos(O * Math.PI / 2),
                I = u * Math.sin(O * Math.PI / 2) + p,
                B = 0,
                V = T.length; B < V; B++)
                    Z((N = L(T[B], U[B], I)).x, N.y, l + j);
                for (M = 0,
                w = A.length; M < w; M++)
                    for (_ = A[M],
                    W = q[M],
                    B = 0,
                    V = _.length; B < V; B++)
                        N = L(_[B], W[B], I),
                        S ? Z(N.x, N.y + g[s - 1].y, g[s - 1].x + j) : Z(N.x, N.y, l + j)
            }
            function J(t, e) {
                var n, i;
                for (B = t.length; --B >= 0; ) {
                    n = B,
                    (i = B - 1) < 0 && (i = t.length - 1);
                    var r = 0
                      , o = s + 2 * d;
                    for (r = 0; r < o; r++) {
                        var a = F * r
                          , l = F * (r + 1);
                        Q(e + n + a, e + i + a, e + i + l, e + n + l)
                    }
                }
            }
            function Z(t, e, n) {
                o.push(t),
                o.push(e),
                o.push(n)
            }
            function K(t, e, r) {
                $(t),
                $(e),
                $(r);
                var o = i.length / 3
                  , a = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                tt(a[0]),
                tt(a[1]),
                tt(a[2])
            }
            function Q(t, e, r, o) {
                $(t),
                $(e),
                $(o),
                $(e),
                $(r),
                $(o);
                var a = i.length / 3
                  , s = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                tt(s[0]),
                tt(s[1]),
                tt(s[3]),
                tt(s[1]),
                tt(s[2]),
                tt(s[3])
            }
            function $(t) {
                i.push(o[3 * t + 0]),
                i.push(o[3 * t + 1]),
                i.push(o[3 * t + 2])
            }
            function tt(t) {
                r.push(t.x),
                r.push(t.y)
            }
            !function() {
                var t = i.length / 3;
                if (c) {
                    var e = 0
                      , r = F * e;
                    for (B = 0; B < z; B++)
                        K((k = E[B])[2] + r, k[1] + r, k[0] + r);
                    for (r = F * (e = s + 2 * d),
                    B = 0; B < z; B++)
                        K((k = E[B])[0] + r, k[1] + r, k[2] + r)
                } else {
                    for (B = 0; B < z; B++)
                        K((k = E[B])[2], k[1], k[0]);
                    for (B = 0; B < z; B++)
                        K((k = E[B])[0] + F * s, k[1] + F * s, k[2] + F * s)
                }
                n.addGroup(t, i.length / 3 - t, 0)
            }(),
            function() {
                var t = i.length / 3
                  , e = 0;
                for (J(T, e),
                e += T.length,
                M = 0,
                w = A.length; M < w; M++)
                    J(_ = A[M], e),
                    e += _.length;
                n.addGroup(t, i.length / 3 - t, 1)
            }()
        }
        this.setAttribute('position', new Mi(i,3)),
        this.setAttribute('uv', new Mi(r,2)),
        this.computeVertexNormals()
    }
    Ml.prototype = Object.create(rr.prototype),
    Ml.prototype.constructor = Ml,
    Ml.prototype.toJSON = function() {
        var t = rr.prototype.toJSON.call(this);
        return Pl(this.parameters.shapes, this.parameters.options, t)
    }
    ,
    wl.prototype = Object.create(Oi.prototype),
    wl.prototype.constructor = wl,
    wl.prototype.toJSON = function() {
        var t = Oi.prototype.toJSON.call(this);
        return Pl(this.parameters.shapes, this.parameters.options, t)
    }
    ;
    var Sl = {
        generateTopUV: function(t, e, n, i, r) {
            var o = e[3 * n]
              , a = e[3 * n + 1]
              , s = e[3 * i]
              , l = e[3 * i + 1]
              , c = e[3 * r]
              , h = e[3 * r + 1];
            return [new Te(o,a), new Te(s,l), new Te(c,h)]
        },
        generateSideWallUV: function(t, e, n, i, r, o) {
            var a = e[3 * n]
              , s = e[3 * n + 1]
              , l = e[3 * n + 2]
              , c = e[3 * i]
              , h = e[3 * i + 1]
              , u = e[3 * i + 2]
              , p = e[3 * r]
              , d = e[3 * r + 1]
              , f = e[3 * r + 2]
              , m = e[3 * o]
              , g = e[3 * o + 1]
              , v = e[3 * o + 2];
            return Math.abs(s - h) < .01 ? [new Te(a,1 - l), new Te(c,1 - u), new Te(p,1 - f), new Te(m,1 - v)] : [new Te(s,1 - l), new Te(h,1 - u), new Te(d,1 - f), new Te(g,1 - v)]
        }
    };
    function Pl(t, e, n) {
        if (n.shapes = [],
        Array.isArray(t))
            for (var i = 0, r = t.length; i < r; i++) {
                var o = t[i];
                n.shapes.push(o.uuid)
            }
        else
            n.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()),
        n
    }
    function Cl(t, e) {
        rr.call(this),
        this.type = 'TextGeometry',
        this.parameters = {
            text: t,
            parameters: e
        },
        this.fromBufferGeometry(new Al(t,e)),
        this.mergeVertices()
    }
    function Al(t, e) {
        var n = (e = e || {}).font;
        if (!n || !n.isFont)
            return new rr;
        var i = n.generateShapes(t, e.size);
        e.depth = void 0 !== e.height ? e.height : 50,
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        wl.call(this, i, e),
        this.type = 'TextBufferGeometry'
    }
    function El(t, e, n, i, r, o, a) {
        rr.call(this),
        this.type = 'SphereGeometry',
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        },
        this.fromBufferGeometry(new Tl(t,e,n,i,r,o,a)),
        this.mergeVertices()
    }
    function Tl(t, e, n, i, r, o, a) {
        Oi.call(this),
        this.type = 'SphereBufferGeometry',
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        },
        t = t || 1,
        e = Math.max(3, Math.floor(e) || 8),
        n = Math.max(2, Math.floor(n) || 6),
        i = void 0 !== i ? i : 0,
        r = void 0 !== r ? r : 2 * Math.PI,
        o = void 0 !== o ? o : 0,
        a = void 0 !== a ? a : Math.PI;
        var s, l, c = Math.min(o + a, Math.PI), h = 0, u = [], p = new Oe, d = new Oe, f = [], m = [], g = [], v = [];
        for (l = 0; l <= n; l++) {
            var y = []
              , x = l / n
              , b = 0;
            for (0 == l && 0 == o ? b = .5 / e : l == n && c == Math.PI && (b = -.5 / e),
            s = 0; s <= e; s++) {
                var _ = s / e;
                p.x = -t * Math.cos(i + _ * r) * Math.sin(o + x * a),
                p.y = t * Math.cos(o + x * a),
                p.z = t * Math.sin(i + _ * r) * Math.sin(o + x * a),
                m.push(p.x, p.y, p.z),
                d.copy(p).normalize(),
                g.push(d.x, d.y, d.z),
                v.push(_ + b, 1 - x),
                y.push(h++)
            }
            u.push(y)
        }
        for (l = 0; l < n; l++)
            for (s = 0; s < e; s++) {
                var M = u[l][s + 1]
                  , w = u[l][s]
                  , S = u[l + 1][s]
                  , P = u[l + 1][s + 1];
                (0 !== l || o > 0) && f.push(M, w, P),
                (l !== n - 1 || c < Math.PI) && f.push(w, S, P)
            }
        this.setIndex(f),
        this.setAttribute('position', new Mi(m,3)),
        this.setAttribute('normal', new Mi(g,3)),
        this.setAttribute('uv', new Mi(v,2))
    }
    function Ll(t, e, n, i, r, o) {
        rr.call(this),
        this.type = 'RingGeometry',
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        },
        this.fromBufferGeometry(new Dl(t,e,n,i,r,o)),
        this.mergeVertices()
    }
    function Dl(t, e, n, i, r, o) {
        Oi.call(this),
        this.type = 'RingBufferGeometry',
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: o
        },
        t = t || .5,
        e = e || 1,
        r = void 0 !== r ? r : 0,
        o = void 0 !== o ? o : 2 * Math.PI,
        n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s, l, c = [], h = [], u = [], p = [], d = t, f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1), m = new Oe, g = new Te;
        for (s = 0; s <= i; s++) {
            for (l = 0; l <= n; l++)
                a = r + l / n * o,
                m.x = d * Math.cos(a),
                m.y = d * Math.sin(a),
                h.push(m.x, m.y, m.z),
                u.push(0, 0, 1),
                g.x = (m.x / e + 1) / 2,
                g.y = (m.y / e + 1) / 2,
                p.push(g.x, g.y);
            d += f
        }
        for (s = 0; s < i; s++) {
            var v = s * (n + 1);
            for (l = 0; l < n; l++) {
                var y = a = l + v
                  , x = a + n + 1
                  , b = a + n + 2
                  , _ = a + 1;
                c.push(y, x, _),
                c.push(x, b, _)
            }
        }
        this.setIndex(c),
        this.setAttribute('position', new Mi(h,3)),
        this.setAttribute('normal', new Mi(u,3)),
        this.setAttribute('uv', new Mi(p,2))
    }
    function Il(t, e, n, i) {
        rr.call(this),
        this.type = 'LatheGeometry',
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        this.fromBufferGeometry(new Ol(t,e,n,i)),
        this.mergeVertices()
    }
    function Ol(t, e, n, i) {
        Oi.call(this),
        this.type = 'LatheBufferGeometry',
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        e = Math.floor(e) || 12,
        n = n || 0,
        i = i || 2 * Math.PI,
        i = Ee.clamp(i, 0, 2 * Math.PI);
        var r, o, a, s = [], l = [], c = [], h = 1 / e, u = new Oe, p = new Te;
        for (o = 0; o <= e; o++) {
            var d = n + o * h * i
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (a = 0; a <= t.length - 1; a++)
                u.x = t[a].x * f,
                u.y = t[a].y,
                u.z = t[a].x * m,
                l.push(u.x, u.y, u.z),
                p.x = o / e,
                p.y = a / (t.length - 1),
                c.push(p.x, p.y)
        }
        for (o = 0; o < e; o++)
            for (a = 0; a < t.length - 1; a++) {
                var g = r = a + o * t.length
                  , v = r + t.length
                  , y = r + t.length + 1
                  , x = r + 1;
                s.push(g, v, x),
                s.push(v, y, x)
            }
        if (this.setIndex(s),
        this.setAttribute('position', new Mi(l,3)),
        this.setAttribute('uv', new Mi(c,2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI) {
            var b = this.attributes.normal.array
              , _ = new Oe
              , M = new Oe
              , w = new Oe;
            for (r = e * t.length * 3,
            o = 0,
            a = 0; o < t.length; o++,
            a += 3)
                _.x = b[a + 0],
                _.y = b[a + 1],
                _.z = b[a + 2],
                M.x = b[r + a + 0],
                M.y = b[r + a + 1],
                M.z = b[r + a + 2],
                w.addVectors(_, M).normalize(),
                b[a + 0] = b[r + a + 0] = w.x,
                b[a + 1] = b[r + a + 1] = w.y,
                b[a + 2] = b[r + a + 2] = w.z
        }
    }
    function jl(t, e) {
        rr.call(this),
        this.type = 'ShapeGeometry',
        'object' == typeof e && (e = e.curveSegments),
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        this.fromBufferGeometry(new Nl(t,e)),
        this.mergeVertices()
    }
    function Nl(t, e) {
        Oi.call(this),
        this.type = 'ShapeBufferGeometry',
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        e = e || 12;
        var n = []
          , i = []
          , r = []
          , o = []
          , a = 0
          , s = 0;
        if (!1 === Array.isArray(t))
            c(t);
        else
            for (var l = 0; l < t.length; l++)
                c(t[l]),
                this.addGroup(a, s, l),
                a += s,
                s = 0;
        function c(t) {
            var a, l, c, h = i.length / 3, u = t.extractPoints(e), p = u.shape, d = u.holes;
            for (!1 === xl.isClockWise(p) && (p = p.reverse()),
            a = 0,
            l = d.length; a < l; a++)
                c = d[a],
                !0 === xl.isClockWise(c) && (d[a] = c.reverse());
            var f = xl.triangulateShape(p, d);
            for (a = 0,
            l = d.length; a < l; a++)
                c = d[a],
                p = p.concat(c);
            for (a = 0,
            l = p.length; a < l; a++) {
                var m = p[a];
                i.push(m.x, m.y, 0),
                r.push(0, 0, 1),
                o.push(m.x, m.y)
            }
            for (a = 0,
            l = f.length; a < l; a++) {
                var g = f[a]
                  , v = g[0] + h
                  , y = g[1] + h
                  , x = g[2] + h;
                n.push(v, y, x),
                s += 3
            }
        }
        this.setIndex(n),
        this.setAttribute('position', new Mi(i,3)),
        this.setAttribute('normal', new Mi(r,3)),
        this.setAttribute('uv', new Mi(o,2))
    }
    function kl(t, e) {
        if (e.shapes = [],
        Array.isArray(t))
            for (var n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.shapes.push(r.uuid)
            }
        else
            e.shapes.push(t.uuid);
        return e
    }
    function Fl(t, e) {
        Oi.call(this),
        this.type = 'EdgesGeometry',
        this.parameters = {
            thresholdAngle: e
        },
        e = void 0 !== e ? e : 1;
        var n, i, r, o, a = [], s = Math.cos(Ee.DEG2RAD * e), l = [0, 0], c = {}, h = ['a', 'b', 'c'];
        t.isBufferGeometry ? (o = new rr).fromBufferGeometry(t) : o = t.clone(),
        o.mergeVertices(),
        o.computeFaceNormals();
        for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
            for (var m = p[d], g = 0; g < 3; g++)
                n = m[h[g]],
                i = m[h[(g + 1) % 3]],
                l[0] = Math.min(n, i),
                l[1] = Math.max(n, i),
                void 0 === c[r = l[0] + ',' + l[1]] ? c[r] = {
                    index1: l[0],
                    index2: l[1],
                    face1: d,
                    face2: void 0
                } : c[r].face2 = d;
        for (r in c) {
            var v = c[r];
            if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
                var y = u[v.index1];
                a.push(y.x, y.y, y.z),
                y = u[v.index2],
                a.push(y.x, y.y, y.z)
            }
        }
        this.setAttribute('position', new Mi(a,3))
    }
    function zl(t, e, n, i, r, o, a, s) {
        rr.call(this),
        this.type = 'CylinderGeometry',
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        },
        this.fromBufferGeometry(new Rl(t,e,n,i,r,o,a,s)),
        this.mergeVertices()
    }
    function Rl(t, e, n, i, r, o, a, s) {
        Oi.call(this),
        this.type = 'CylinderBufferGeometry',
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var l = this;
        t = void 0 !== t ? t : 1,
        e = void 0 !== e ? e : 1,
        n = n || 1,
        i = Math.floor(i) || 8,
        r = Math.floor(r) || 1,
        o = void 0 !== o && o,
        a = void 0 !== a ? a : 0,
        s = void 0 !== s ? s : 2 * Math.PI;
        var c = []
          , h = []
          , u = []
          , p = []
          , d = 0
          , f = []
          , m = n / 2
          , g = 0;
        function v(n) {
            var r, o, f, v = new Te, y = new Oe, x = 0, b = !0 === n ? t : e, _ = !0 === n ? 1 : -1;
            for (o = d,
            r = 1; r <= i; r++)
                h.push(0, m * _, 0),
                u.push(0, _, 0),
                p.push(.5, .5),
                d++;
            for (f = d,
            r = 0; r <= i; r++) {
                var M = r / i * s + a
                  , w = Math.cos(M)
                  , S = Math.sin(M);
                y.x = b * S,
                y.y = m * _,
                y.z = b * w,
                h.push(y.x, y.y, y.z),
                u.push(0, _, 0),
                v.x = .5 * w + .5,
                v.y = .5 * S * _ + .5,
                p.push(v.x, v.y),
                d++
            }
            for (r = 0; r < i; r++) {
                var P = o + r
                  , C = f + r;
                !0 === n ? c.push(C, C + 1, P) : c.push(C + 1, C, P),
                x += 3
            }
            l.addGroup(g, x, !0 === n ? 1 : 2),
            g += x
        }
        !function() {
            var o, v, y = new Oe, x = new Oe, b = 0, _ = (e - t) / n;
            for (v = 0; v <= r; v++) {
                var M = []
                  , w = v / r
                  , S = w * (e - t) + t;
                for (o = 0; o <= i; o++) {
                    var P = o / i
                      , C = P * s + a
                      , A = Math.sin(C)
                      , E = Math.cos(C);
                    x.x = S * A,
                    x.y = -w * n + m,
                    x.z = S * E,
                    h.push(x.x, x.y, x.z),
                    y.set(A, _, E).normalize(),
                    u.push(y.x, y.y, y.z),
                    p.push(P, 1 - w),
                    M.push(d++)
                }
                f.push(M)
            }
            for (o = 0; o < i; o++)
                for (v = 0; v < r; v++) {
                    var T = f[v][o]
                      , L = f[v + 1][o]
                      , D = f[v + 1][o + 1]
                      , I = f[v][o + 1];
                    c.push(T, L, I),
                    c.push(L, D, I),
                    b += 6
                }
            l.addGroup(g, b, 0),
            g += b
        }(),
        !1 === o && (t > 0 && v(!0),
        e > 0 && v(!1)),
        this.setIndex(c),
        this.setAttribute('position', new Mi(h,3)),
        this.setAttribute('normal', new Mi(u,3)),
        this.setAttribute('uv', new Mi(p,2))
    }
    function Ul(t, e, n, i, r, o, a) {
        zl.call(this, 0, t, e, n, i, r, o, a),
        this.type = 'ConeGeometry',
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Bl(t, e, n, i, r, o, a) {
        Rl.call(this, 0, t, e, n, i, r, o, a),
        this.type = 'ConeBufferGeometry',
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Vl(t, e, n, i) {
        rr.call(this),
        this.type = 'CircleGeometry',
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        this.fromBufferGeometry(new Gl(t,e,n,i)),
        this.mergeVertices()
    }
    function Gl(t, e, n, i) {
        Oi.call(this),
        this.type = 'CircleBufferGeometry',
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        t = t || 1,
        e = void 0 !== e ? Math.max(3, e) : 8,
        n = void 0 !== n ? n : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var r, o, a = [], s = [], l = [], c = [], h = new Oe, u = new Te;
        for (s.push(0, 0, 0),
        l.push(0, 0, 1),
        c.push(.5, .5),
        o = 0,
        r = 3; o <= e; o++,
        r += 3) {
            var p = n + o / e * i;
            h.x = t * Math.cos(p),
            h.y = t * Math.sin(p),
            s.push(h.x, h.y, h.z),
            l.push(0, 0, 1),
            u.x = (s[r] / t + 1) / 2,
            u.y = (s[r + 1] / t + 1) / 2,
            c.push(u.x, u.y)
        }
        for (r = 1; r <= e; r++)
            a.push(r, r + 1, 0);
        this.setIndex(a),
        this.setAttribute('position', new Mi(s,3)),
        this.setAttribute('normal', new Mi(l,3)),
        this.setAttribute('uv', new Mi(c,2))
    }
    Cl.prototype = Object.create(rr.prototype),
    Cl.prototype.constructor = Cl,
    Al.prototype = Object.create(wl.prototype),
    Al.prototype.constructor = Al,
    El.prototype = Object.create(rr.prototype),
    El.prototype.constructor = El,
    Tl.prototype = Object.create(Oi.prototype),
    Tl.prototype.constructor = Tl,
    Ll.prototype = Object.create(rr.prototype),
    Ll.prototype.constructor = Ll,
    Dl.prototype = Object.create(Oi.prototype),
    Dl.prototype.constructor = Dl,
    Il.prototype = Object.create(rr.prototype),
    Il.prototype.constructor = Il,
    Ol.prototype = Object.create(Oi.prototype),
    Ol.prototype.constructor = Ol,
    jl.prototype = Object.create(rr.prototype),
    jl.prototype.constructor = jl,
    jl.prototype.toJSON = function() {
        var t = rr.prototype.toJSON.call(this);
        return kl(this.parameters.shapes, t)
    }
    ,
    Nl.prototype = Object.create(Oi.prototype),
    Nl.prototype.constructor = Nl,
    Nl.prototype.toJSON = function() {
        var t = Oi.prototype.toJSON.call(this);
        return kl(this.parameters.shapes, t)
    }
    ,
    Fl.prototype = Object.create(Oi.prototype),
    Fl.prototype.constructor = Fl,
    zl.prototype = Object.create(rr.prototype),
    zl.prototype.constructor = zl,
    Rl.prototype = Object.create(Oi.prototype),
    Rl.prototype.constructor = Rl,
    Ul.prototype = Object.create(zl.prototype),
    Ul.prototype.constructor = Ul,
    Bl.prototype = Object.create(Rl.prototype),
    Bl.prototype.constructor = Bl,
    Vl.prototype = Object.create(rr.prototype),
    Vl.prototype.constructor = Vl,
    Gl.prototype = Object.create(Oi.prototype),
    Gl.prototype.constructor = Gl;
    var Hl = Object.freeze({
        __proto__: null,
        WireframeGeometry: Is,
        ParametricGeometry: Os,
        ParametricBufferGeometry: js,
        TetrahedronGeometry: Fs,
        TetrahedronBufferGeometry: zs,
        OctahedronGeometry: Rs,
        OctahedronBufferGeometry: Us,
        IcosahedronGeometry: Bs,
        IcosahedronBufferGeometry: Vs,
        DodecahedronGeometry: Gs,
        DodecahedronBufferGeometry: Hs,
        PolyhedronGeometry: Ns,
        PolyhedronBufferGeometry: ks,
        TubeGeometry: Ws,
        TubeBufferGeometry: Xs,
        TorusKnotGeometry: qs,
        TorusKnotBufferGeometry: Ys,
        TorusGeometry: Js,
        TorusBufferGeometry: Zs,
        TextGeometry: Cl,
        TextBufferGeometry: Al,
        SphereGeometry: El,
        SphereBufferGeometry: Tl,
        RingGeometry: Ll,
        RingBufferGeometry: Dl,
        PlaneGeometry: Ar,
        PlaneBufferGeometry: Er,
        LatheGeometry: Il,
        LatheBufferGeometry: Ol,
        ShapeGeometry: jl,
        ShapeBufferGeometry: Nl,
        ExtrudeGeometry: Ml,
        ExtrudeBufferGeometry: wl,
        EdgesGeometry: Fl,
        ConeGeometry: Ul,
        ConeBufferGeometry: Bl,
        CylinderGeometry: zl,
        CylinderBufferGeometry: Rl,
        CircleGeometry: Vl,
        CircleBufferGeometry: Gl,
        BoxGeometry: or,
        BoxBufferGeometry: ar
    });
    function Wl(t) {
        pi.call(this),
        this.type = 'ShadowMaterial',
        this.color = new ai(0),
        this.transparent = !0,
        this.setValues(t)
    }
    function Xl(t) {
        ur.call(this, t),
        this.type = 'RawShaderMaterial'
    }
    function ql(t) {
        pi.call(this),
        this.defines = {
            STANDARD: ''
        },
        this.type = 'MeshStandardMaterial',
        this.color = new ai(16777215),
        this.roughness = .5,
        this.metalness = .5,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ai(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = be,
        this.normalScale = new Te(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = 'round',
        this.wireframeLinejoin = 'round',
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Yl(t) {
        ql.call(this),
        this.defines = {
            STANDARD: '',
            PHYSICAL: ''
        },
        this.type = 'MeshPhysicalMaterial',
        this.reflectivity = .5,
        this.clearcoat = 0,
        this.clearcoatRoughness = 0,
        this.sheen = null,
        this.clearcoatNormalScale = new Te(1,1),
        this.clearcoatNormalMap = null,
        this.transparency = 0,
        this.setValues(t)
    }
    function Jl(t) {
        pi.call(this),
        this.type = 'MeshPhongMaterial',
        this.color = new ai(16777215),
        this.specular = new ai(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ai(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = be,
        this.normalScale = new Te(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = W,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = 'round',
        this.wireframeLinejoin = 'round',
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Zl(t) {
        Jl.call(this),
        this.defines = {
            TOON: ''
        },
        this.type = 'MeshToonMaterial',
        this.gradientMap = null,
        this.setValues(t)
    }
    function Kl(t) {
        pi.call(this),
        this.type = 'MeshNormalMaterial',
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = be,
        this.normalScale = new Te(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Ql(t) {
        pi.call(this),
        this.type = 'MeshLambertMaterial',
        this.color = new ai(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ai(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = W,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = 'round',
        this.wireframeLinejoin = 'round',
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function $l(t) {
        pi.call(this),
        this.defines = {
            MATCAP: ''
        },
        this.type = 'MeshMatcapMaterial',
        this.color = new ai(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = be,
        this.normalScale = new Te(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function tc(t) {
        hs.call(this),
        this.type = 'LineDashedMaterial',
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    Wl.prototype = Object.create(pi.prototype),
    Wl.prototype.constructor = Wl,
    Wl.prototype.isShadowMaterial = !0,
    Wl.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this
    }
    ,
    Xl.prototype = Object.create(ur.prototype),
    Xl.prototype.constructor = Xl,
    Xl.prototype.isRawShaderMaterial = !0,
    ql.prototype = Object.create(pi.prototype),
    ql.prototype.constructor = ql,
    ql.prototype.isMeshStandardMaterial = !0,
    ql.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: ''
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Yl.prototype = Object.create(ql.prototype),
    Yl.prototype.constructor = Yl,
    Yl.prototype.isMeshPhysicalMaterial = !0,
    Yl.prototype.copy = function(t) {
        return ql.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: '',
            PHYSICAL: ''
        },
        this.reflectivity = t.reflectivity,
        this.clearcoat = t.clearcoat,
        this.clearcoatRoughness = t.clearcoatRoughness,
        t.sheen ? this.sheen = (this.sheen || new ai).copy(t.sheen) : this.sheen = null,
        this.clearcoatNormalMap = t.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        this.transparency = t.transparency,
        this
    }
    ,
    Jl.prototype = Object.create(pi.prototype),
    Jl.prototype.constructor = Jl,
    Jl.prototype.isMeshPhongMaterial = !0,
    Jl.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Zl.prototype = Object.create(Jl.prototype),
    Zl.prototype.constructor = Zl,
    Zl.prototype.isMeshToonMaterial = !0,
    Zl.prototype.copy = function(t) {
        return Jl.prototype.copy.call(this, t),
        this.gradientMap = t.gradientMap,
        this
    }
    ,
    Kl.prototype = Object.create(pi.prototype),
    Kl.prototype.constructor = Kl,
    Kl.prototype.isMeshNormalMaterial = !0,
    Kl.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Ql.prototype = Object.create(pi.prototype),
    Ql.prototype.constructor = Ql,
    Ql.prototype.isMeshLambertMaterial = !0,
    Ql.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    $l.prototype = Object.create(pi.prototype),
    $l.prototype.constructor = $l,
    $l.prototype.isMeshMatcapMaterial = !0,
    $l.prototype.copy = function(t) {
        return pi.prototype.copy.call(this, t),
        this.defines = {
            MATCAP: ''
        },
        this.color.copy(t.color),
        this.matcap = t.matcap,
        this.map = t.map,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    tc.prototype = Object.create(hs.prototype),
    tc.prototype.constructor = tc,
    tc.prototype.isLineDashedMaterial = !0,
    tc.prototype.copy = function(t) {
        return hs.prototype.copy.call(this, t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
    ;
    var ec = Object.freeze({
        __proto__: null,
        ShadowMaterial: Wl,
        SpriteMaterial: ka,
        RawShaderMaterial: Xl,
        ShaderMaterial: ur,
        PointsMaterial: _s,
        MeshPhysicalMaterial: Yl,
        MeshStandardMaterial: ql,
        MeshPhongMaterial: Jl,
        MeshToonMaterial: Zl,
        MeshNormalMaterial: Kl,
        MeshLambertMaterial: Ql,
        MeshDepthMaterial: da,
        MeshDistanceMaterial: fa,
        MeshBasicMaterial: di,
        MeshMatcapMaterial: $l,
        LineDashedMaterial: tc,
        LineBasicMaterial: hs,
        Material: pi
    })
      , nc = {
        arraySlice: function(t, e, n) {
            return nc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : 'number' == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i)
                n[i] = i;
            return n.sort((function(e, n) {
                return t[e] - t[n]
            }
            )),
            n
        },
        sortedArray: function(t, e, n) {
            for (var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
                for (var s = n[o] * e, l = 0; l !== e; ++l)
                    r[a++] = t[s + l];
            return r
        },
        flattenJSON: function(t, e, n, i) {
            for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i]; )
                o = t[r++];
            if (void 0 !== o) {
                var a = o[i];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = o[i]) && (e.push(o.time),
                            n.push.apply(n, a)),
                            o = t[r++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[i]) && (e.push(o.time),
                            a.toArray(n, n.length)),
                            o = t[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[i]) && (e.push(o.time),
                            n.push(a)),
                            o = t[r++]
                        } while (void 0 !== o)
            }
        },
        subclip: function(t, e, n, i, r) {
            r = r || 30;
            var o = t.clone();
            o.name = e;
            for (var a = [], s = 0; s < o.tracks.length; ++s) {
                for (var l = o.tracks[s], c = l.getValueSize(), h = [], u = [], p = 0; p < l.times.length; ++p) {
                    var d = l.times[p] * r;
                    if (!(d < n || d >= i)) {
                        h.push(l.times[p]);
                        for (var f = 0; f < c; ++f)
                            u.push(l.values[p * c + f])
                    }
                }
                0 !== h.length && (l.times = nc.convertArray(h, l.times.constructor),
                l.values = nc.convertArray(u, l.values.constructor),
                a.push(l))
            }
            o.tracks = a;
            var m = 1 / 0;
            for (s = 0; s < o.tracks.length; ++s)
                m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]);
            for (s = 0; s < o.tracks.length; ++s)
                o.tracks[s].shift(-1 * m);
            return o.resetDuration(),
            o
        }
    };
    function ic(t, e, n, i) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n
    }
    function rc(t, e, n, i) {
        ic.call(this, t, e, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function oc(t, e, n, i) {
        ic.call(this, t, e, n, i)
    }
    function ac(t, e, n, i) {
        ic.call(this, t, e, n, i)
    }
    function sc(t, e, n, i) {
        if (void 0 === t)
            throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (void 0 === e || 0 === e.length)
            throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
        this.name = t,
        this.times = nc.convertArray(e, this.TimeBufferType),
        this.values = nc.convertArray(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    function lc(t, e, n) {
        sc.call(this, t, e, n)
    }
    function cc(t, e, n, i) {
        sc.call(this, t, e, n, i)
    }
    function hc(t, e, n, i) {
        sc.call(this, t, e, n, i)
    }
    function uc(t, e, n, i) {
        ic.call(this, t, e, n, i)
    }
    function pc(t, e, n, i) {
        sc.call(this, t, e, n, i)
    }
    function dc(t, e, n, i) {
        sc.call(this, t, e, n, i)
    }
    function fc(t, e, n, i) {
        sc.call(this, t, e, n, i)
    }
    function mc(t, e, n) {
        this.name = t,
        this.tracks = n,
        this.duration = void 0 !== e ? e : -1,
        this.uuid = Ee.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function gc(t) {
        if (void 0 === t.type)
            throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
        var e = function(t) {
            switch (t.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
                return hc;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
                return fc;
            case 'color':
                return cc;
            case 'quaternion':
                return pc;
            case 'bool':
            case 'boolean':
                return lc;
            case 'string':
                return dc
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
        }(t.type);
        if (void 0 === t.times) {
            var n = []
              , i = [];
            nc.flattenJSON(t.keys, n, i, 'value'),
            t.times = n,
            t.values = i
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
    }
    Object.assign(ic.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions
              , n = this._cachedIndex
              , i = e[n]
              , r = e[n - 1];
            t: {
                e: {
                    var o;
                    n: {
                        i: if (!(t < i)) {
                            for (var a = n + 2; ; ) {
                                if (void 0 === i) {
                                    if (t < r)
                                        break i;
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, t, r)
                                }
                                if (n === a)
                                    break;
                                if (r = i,
                                t < (i = e[++n]))
                                    break e
                            }
                            o = e.length;
                            break n
                        }
                        if (t >= r)
                            break t;
                        var s = e[1];
                        t < s && (n = 2,
                        r = s);
                        for (a = n - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                            if (n === a)
                                break;
                            if (i = r,
                            t >= (r = e[--n - 1]))
                                break e
                        }
                        o = n,
                        n = 0
                    }
                    for (; n < o; ) {
                        var l = n + o >>> 1;
                        t < e[l] ? o = l : n = l + 1
                    }
                    if (i = e[n],
                    void 0 === (r = e[n - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, i);
                    if (void 0 === i)
                        return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, o = 0; o !== i; ++o)
                e[o] = n[r + o];
            return e
        },
        interpolate_: function() {
            throw new Error('call to abstract method')
        },
        intervalChanged_: function() {}
    }),
    Object.assign(ic.prototype, {
        beforeStart_: ic.prototype.copySampleValue_,
        afterEnd_: ic.prototype.copySampleValue_
    }),
    rc.prototype = Object.assign(Object.create(ic.prototype), {
        constructor: rc,
        DefaultSettings_: {
            endingStart: ae,
            endingEnd: ae
        },
        intervalChanged_: function(t, e, n) {
            var i = this.parameterPositions
              , r = t - 2
              , o = t + 1
              , a = i[r]
              , s = i[o];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t,
                    a = 2 * e - n;
                    break;
                case 2402:
                    a = e + i[r = i.length - 2] - i[r + 1];
                    break;
                default:
                    r = t,
                    a = n
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = t,
                    s = 2 * n - e;
                    break;
                case 2402:
                    o = 1,
                    s = n + i[1] - i[0];
                    break;
                default:
                    o = t - 1,
                    s = e
                }
            var l = .5 * (n - e)
              , c = this.valueSize;
            this._weightPrev = l / (e - a),
            this._weightNext = l / (s - n),
            this._offsetPrev = r * c,
            this._offsetNext = o * c
        },
        interpolate_: function(t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - e) / (i - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== a; ++b)
                r[b] = g * o[c + b] + v * o[l + b] + y * o[s + b] + x * o[h + b];
            return r
        }
    }),
    oc.prototype = Object.assign(Object.create(ic.prototype), {
        constructor: oc,
        interpolate_: function(t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = (n - e) / (i - e), h = 1 - c, u = 0; u !== a; ++u)
                r[u] = o[l + u] * h + o[s + u] * c;
            return r
        }
    }),
    ac.prototype = Object.assign(Object.create(ic.prototype), {
        constructor: ac,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    }),
    Object.assign(sc, {
        toJSON: function(t) {
            var e, n = t.constructor;
            if (void 0 !== n.toJSON)
                e = n.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: nc.convertArray(t.times, Array),
                    values: nc.convertArray(t.values, Array)
                };
                var i = t.getInterpolation();
                i !== t.DefaultInterpolation && (e.interpolation = i)
            }
            return e.type = t.ValueTypeName,
            e
        }
    }),
    Object.assign(sc.prototype, {
        constructor: sc,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new ac(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new oc(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new rc(this.times,this.values,this.getValueSize(),t)
        },
        setInterpolation: function(t) {
            var e;
            switch (t) {
            case 2300:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                var n = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return this
            }
            return this.createInterpolant = e,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                    e[n] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, n = 0, i = e.length; n !== i; ++n)
                    e[n] *= t;
            return this
        },
        trim: function(t, e) {
            for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t; )
                ++r;
            for (; -1 !== o && n[o] > e; )
                --o;
            if (++o,
            0 !== r || o !== i) {
                r >= o && (r = (o = Math.max(o, 1)) - 1);
                var a = this.getValueSize();
                this.times = nc.arraySlice(n, r, o),
                this.values = nc.arraySlice(this.values, r * a, o * a)
            }
            return this
        },
        validate: function() {
            var t = !0
              , e = this.getValueSize();
            e - Math.floor(e) != 0 && (t = !1);
            var n = this.times
              , i = this.values
              , r = n.length;
            0 === r && (t = !1);
            for (var o = null, a = 0; a !== r; a++) {
                var s = n[a];
                if ('number' == typeof s && isNaN(s)) {
                    t = !1;
                    break
                }
                if (null !== o && o > s) {
                    t = !1;
                    break
                }
                o = s
            }
            if (void 0 !== i && nc.isTypedArray(i)) {
                a = 0;
                for (var l = i.length; a !== l; ++a) {
                    var c = i[a];
                    if (isNaN(c)) {
                        t = !1;
                        break
                    }
                }
            }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                var s = !1
                  , l = t[a];
                if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                    if (i)
                        s = !0;
                    else
                        for (var c = a * n, h = c - n, u = c + n, p = 0; p !== n; ++p) {
                            var d = e[c + p];
                            if (d !== e[h + p] || d !== e[u + p]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== r) {
                        t[r] = t[a];
                        var f = a * n
                          , m = r * n;
                        for (p = 0; p !== n; ++p)
                            e[m + p] = e[f + p]
                    }
                    ++r
                }
            }
            if (o > 0) {
                t[r] = t[o];
                for (f = o * n,
                m = r * n,
                p = 0; p !== n; ++p)
                    e[m + p] = e[f + p];
                ++r
            }
            return r !== t.length && (this.times = nc.arraySlice(t, 0, r),
            this.values = nc.arraySlice(e, 0, r * n)),
            this
        },
        clone: function() {
            var t = nc.arraySlice(this.times, 0)
              , e = nc.arraySlice(this.values, 0)
              , n = new (0,
            this.constructor)(this.name,t,e);
            return n.createInterpolant = this.createInterpolant,
            n
        }
    }),
    lc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: lc,
        ValueTypeName: 'bool',
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    cc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: cc,
        ValueTypeName: 'color'
    }),
    hc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: hc,
        ValueTypeName: 'number'
    }),
    uc.prototype = Object.assign(Object.create(ic.prototype), {
        constructor: uc,
        interpolate_: function(t, e, n, i) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = (n - e) / (i - e), c = s + a; s !== c; s += 4)
                Le.slerpFlat(r, 0, o, s - a, o, s, l);
            return r
        }
    }),
    pc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: pc,
        ValueTypeName: 'quaternion',
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(t) {
            return new uc(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    dc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: dc,
        ValueTypeName: 'string',
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    fc.prototype = Object.assign(Object.create(sc.prototype), {
        constructor: fc,
        ValueTypeName: 'vector'
    }),
    Object.assign(mc, {
        parse: function(t) {
            for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r)
                e.push(gc(n[r]).scale(i));
            return new mc(t.name,t.duration,e)
        },
        toJSON: function(t) {
            for (var e = [], n = t.tracks, i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid
            }, r = 0, o = n.length; r !== o; ++r)
                e.push(sc.toJSON(n[r]));
            return i
        },
        CreateFromMorphTargetSequence: function(t, e, n, i) {
            for (var r = e.length, o = [], a = 0; a < r; a++) {
                var s = []
                  , l = [];
                s.push((a + r - 1) % r, a, (a + 1) % r),
                l.push(0, 1, 0);
                var c = nc.getKeyframeOrder(s);
                s = nc.sortedArray(s, 1, c),
                l = nc.sortedArray(l, 1, c),
                i || 0 !== s[0] || (s.push(r),
                l.push(l[0])),
                o.push(new hc('.morphTargetInfluences[' + e[a].name + ']',s,l).scale(1 / n))
            }
            return new mc(t,-1,o)
        },
        findByName: function(t, e) {
            var n = t;
            if (!Array.isArray(t)) {
                var i = t;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (var r = 0; r < n.length; r++)
                if (n[r].name === e)
                    return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s = t[o]
                  , l = s.name.match(r);
                if (l && l.length > 1) {
                    var c = i[u = l[1]];
                    c || (i[u] = c = []),
                    c.push(s)
                }
            }
            var h = [];
            for (var u in i)
                h.push(mc.CreateFromMorphTargetSequence(u, i[u], e, n));
            return h
        },
        parseAnimation: function(t, e) {
            if (!t)
                return null;
            for (var n = function(t, e, n, i, r) {
                if (0 !== n.length) {
                    var o = []
                      , a = [];
                    nc.flattenJSON(n, o, a, i),
                    0 !== o.length && r.push(new t(e,o,a))
                }
            }, i = [], r = t.name || 'default', o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
                var c = s[l].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        for (var h = {}, u = 0; u < c.length; u++)
                            if (c[u].morphTargets)
                                for (var p = 0; p < c[u].morphTargets.length; p++)
                                    h[c[u].morphTargets[p]] = -1;
                        for (var d in h) {
                            var f = []
                              , m = [];
                            for (p = 0; p !== c[u].morphTargets.length; ++p) {
                                var g = c[u];
                                f.push(g.time),
                                m.push(g.morphTarget === d ? 1 : 0)
                            }
                            i.push(new hc('.morphTargetInfluence[' + d + ']',f,m))
                        }
                        o = h.length * (a || 1)
                    } else {
                        var v = '.bones[' + e[l].name + ']';
                        n(fc, v + '.position', c, 'pos', i),
                        n(pc, v + '.quaternion', c, 'rot', i),
                        n(fc, v + '.scale', c, 'scl', i)
                    }
            }
            return 0 === i.length ? null : new mc(r,o,i)
        }
    }),
    Object.assign(mc.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                var i = this.tracks[e];
                t = Math.max(t, i.times[i.times.length - 1])
            }
            return this.duration = t,
            this
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var t = !0, e = 0; e < this.tracks.length; e++)
                t = t && this.tracks[e].validate();
            return t
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        },
        clone: function() {
            for (var t = [], e = 0; e < this.tracks.length; e++)
                t.push(this.tracks[e].clone());
            return new mc(this.name,this.duration,t)
        }
    });
    var vc = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };
    function yc(t, e, n) {
        var i = this
          , r = !1
          , o = 0
          , a = 0
          , s = void 0
          , l = [];
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(t) {
            a++,
            !1 === r && void 0 !== i.onStart && i.onStart(t, o, a),
            r = !0
        }
        ,
        this.itemEnd = function(t) {
            o++,
            void 0 !== i.onProgress && i.onProgress(t, o, a),
            o === a && (r = !1,
            void 0 !== i.onLoad && i.onLoad())
        }
        ,
        this.itemError = function(t) {
            void 0 !== i.onError && i.onError(t)
        }
        ,
        this.resolveURL = function(t) {
            return s ? s(t) : t
        }
        ,
        this.setURLModifier = function(t) {
            return s = t,
            this
        }
        ,
        this.addHandler = function(t, e) {
            return l.push(t, e),
            this
        }
        ,
        this.removeHandler = function(t) {
            var e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2),
            this
        }
        ,
        this.getHandler = function(t) {
            for (var e = 0, n = l.length; e < n; e += 2) {
                var i = l[e]
                  , r = l[e + 1];
                if (i.global && (i.lastIndex = 0),
                i.test(t))
                    return r
            }
            return null
        }
    }
    var xc = new yc;
    function bc(t) {
        this.manager = void 0 !== t ? t : xc,
        this.crossOrigin = 'anonymous',
        this.path = '',
        this.resourcePath = ''
    }
    Object.assign(bc.prototype, {
        load: function() {},
        parse: function() {},
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResourcePath: function(t) {
            return this.resourcePath = t,
            this
        }
    });
    var _c = {};
    function Mc(t) {
        bc.call(this, t)
    }
    function wc(t) {
        bc.call(this, t)
    }
    function Sc(t) {
        bc.call(this, t)
    }
    function Pc(t) {
        bc.call(this, t)
    }
    function Cc(t) {
        bc.call(this, t)
    }
    function Ac(t) {
        bc.call(this, t)
    }
    function Ec(t) {
        bc.call(this, t)
    }
    function Tc() {
        this.type = 'Curve',
        this.arcLengthDivisions = 200
    }
    function Lc(t, e, n, i, r, o, a, s) {
        Tc.call(this),
        this.type = 'EllipseCurve',
        this.aX = t || 0,
        this.aY = e || 0,
        this.xRadius = n || 1,
        this.yRadius = i || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = o || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = s || 0
    }
    function Dc(t, e, n, i, r, o) {
        Lc.call(this, t, e, n, n, i, r, o),
        this.type = 'ArcCurve'
    }
    function Ic() {
        var t = 0
          , e = 0
          , n = 0
          , i = 0;
        function r(r, o, a, s) {
            t = r,
            e = a,
            n = -3 * r + 3 * o - 2 * a - s,
            i = 2 * r - 2 * o + a + s
        }
        return {
            initCatmullRom: function(t, e, n, i, o) {
                r(e, n, o * (n - t), o * (i - e))
            },
            initNonuniformCatmullRom: function(t, e, n, i, o, a, s) {
                var l = (e - t) / o - (n - t) / (o + a) + (n - e) / a
                  , c = (n - e) / a - (i - e) / (a + s) + (i - n) / s;
                r(e, n, l *= a, c *= a)
            },
            calc: function(r) {
                var o = r * r;
                return t + e * r + n * o + i * (o * r)
            }
        }
    }
    Mc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Mc,
        load: function(t, e, n, i) {
            void 0 === t && (t = ''),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , o = vc.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            if (void 0 === _c[t]) {
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1]
                      , l = !!a[2]
                      , c = a[3];
                    c = decodeURIComponent(c),
                    l && (c = atob(c));
                    try {
                        var h, u = (this.responseType || '').toLowerCase();
                        switch (u) {
                        case 'arraybuffer':
                        case 'blob':
                            for (var p = new Uint8Array(c.length), d = 0; d < c.length; d++)
                                p[d] = c.charCodeAt(d);
                            h = 'blob' === u ? new Blob([p.buffer],{
                                type: s
                            }) : p.buffer;
                            break;
                        case 'document':
                            var f = new DOMParser;
                            h = f.parseFromString(c, s);
                            break;
                        case 'json':
                            h = JSON.parse(c);
                            break;
                        default:
                            h = c
                        }
                        setTimeout((function() {
                            e && e(h),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    } catch (e) {
                        setTimeout((function() {
                            i && i(e),
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    }
                } else {
                    _c[t] = [],
                    _c[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                    var m = new XMLHttpRequest;
                    for (var g in m.open('GET', t, !0),
                    m.addEventListener('load', (function(e) {
                        var n = this.response
                          , i = _c[t];
                        if (delete _c[t],
                        200 === this.status || 0 === this.status) {
                            this.status,
                            vc.add(t, n);
                            for (var o = 0, a = i.length; o < a; o++) {
                                (s = i[o]).onLoad && s.onLoad(n)
                            }
                            r.manager.itemEnd(t)
                        } else {
                            for (o = 0,
                            a = i.length; o < a; o++) {
                                var s;
                                (s = i[o]).onError && s.onError(e)
                            }
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                    }
                    ), !1),
                    m.addEventListener('progress', (function(e) {
                        for (var n = _c[t], i = 0, r = n.length; i < r; i++) {
                            var o = n[i];
                            o.onProgress && o.onProgress(e)
                        }
                    }
                    ), !1),
                    m.addEventListener('error', (function(e) {
                        var n = _c[t];
                        delete _c[t];
                        for (var i = 0, o = n.length; i < o; i++) {
                            var a = n[i];
                            a.onError && a.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    m.addEventListener('abort', (function(e) {
                        var n = _c[t];
                        delete _c[t];
                        for (var i = 0, o = n.length; i < o; i++) {
                            var a = n[i];
                            a.onError && a.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain'),
                    this.requestHeader)
                        m.setRequestHeader(g, this.requestHeader[g]);
                    m.send(null)
                }
                return r.manager.itemStart(t),
                m
            }
            _c[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            })
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    }),
    wc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: wc,
        load: function(t, e, n, i) {
            var r = this
              , o = new Mc(r.manager);
            o.setPath(r.path),
            o.load(t, (function(t) {
                e(r.parse(JSON.parse(t)))
            }
            ), n, i)
        },
        parse: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var i = mc.parse(t[n]);
                e.push(i)
            }
            return e
        }
    }),
    Sc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Sc,
        load: function(t, e, n, i) {
            var r = this
              , o = []
              , a = new Ts;
            a.image = o;
            var s = new Mc(this.manager);
            function l(l) {
                s.load(t[l], (function(t) {
                    var n = r.parse(t, !0);
                    o[l] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = dt),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    e && e(a))
                }
                ), n, i)
            }
            if (s.setPath(this.path),
            s.setResponseType('arraybuffer'),
            Array.isArray(t))
                for (var c = 0, h = 0, u = t.length; h < u; ++h)
                    l(h);
            else
                s.load(t, (function(t) {
                    var n = r.parse(t, !0);
                    if (n.isCubemap)
                        for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var l = 0; l < n.mipmapCount; l++)
                                o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + l]),
                                o[s].format = n.format,
                                o[s].width = n.width,
                                o[s].height = n.height
                        }
                    else
                        a.image.width = n.width,
                        a.image.height = n.height,
                        a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = dt),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    e && e(a)
                }
                ), n, i);
            return a
        }
    }),
    Pc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Pc,
        load: function(t, e, n, i) {
            var r = this
              , o = new yr
              , a = new Mc(this.manager);
            return a.setResponseType('arraybuffer'),
            a.setPath(this.path),
            a.load(t, (function(t) {
                var n = r.parse(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                o.image.height = n.height,
                o.image.data = n.data),
                o.wrapS = void 0 !== n.wrapS ? n.wrapS : lt,
                o.wrapT = void 0 !== n.wrapT ? n.wrapT : lt,
                o.magFilter = void 0 !== n.magFilter ? n.magFilter : dt,
                o.minFilter = void 0 !== n.minFilter ? n.minFilter : dt,
                o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps,
                o.minFilter = mt),
                1 === n.mipmapCount && (o.minFilter = dt),
                o.needsUpdate = !0,
                e && e(o, n))
            }
            ), n, i),
            o
        }
    }),
    Cc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Cc,
        load: function(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , o = vc.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            var a = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            function s() {
                a.removeEventListener('load', s, !1),
                a.removeEventListener('error', l, !1),
                vc.add(t, this),
                e && e(this),
                r.manager.itemEnd(t)
            }
            function l(e) {
                a.removeEventListener('load', s, !1),
                a.removeEventListener('error', l, !1),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            return a.addEventListener('load', s, !1),
            a.addEventListener('error', l, !1),
            'data:' !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            a.src = t,
            a
        }
    }),
    Ac.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Ac,
        load: function(t, e, n, i) {
            var r = new Ur
              , o = new Cc(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            var a = 0;
            function s(n) {
                o.load(t[n], (function(t) {
                    r.images[n] = t,
                    6 === ++a && (r.needsUpdate = !0,
                    e && e(r))
                }
                ), void 0, i)
            }
            for (var l = 0; l < t.length; ++l)
                s(l);
            return r
        }
    }),
    Ec.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Ec,
        load: function(t, e, n, i) {
            var r = new Re
              , o = new Cc(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(t, (function(n) {
                r.image = n;
                var i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = i ? Tt : Lt,
                r.needsUpdate = !0,
                void 0 !== e && e(r)
            }
            ), n, i),
            r
        }
    }),
    Object.assign(Tc.prototype, {
        getPoint: function() {
            return null
        },
        getPointAt: function(t, e) {
            var n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n, i = [], r = this.getPoint(0), o = 0;
            for (i.push(0),
            n = 1; n <= t; n++)
                o += (e = this.getPoint(n / t)).distanceTo(r),
                i.push(o),
                r = e;
            return this.cacheArcLengths = i,
            i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var n, i = this.getLengths(), r = 0, o = i.length;
            n = e || t * i[o - 1];
            for (var a, s = 0, l = o - 1; s <= l; )
                if ((a = i[r = Math.floor(s + (l - s) / 2)] - n) < 0)
                    s = r + 1;
                else {
                    if (!(a > 0)) {
                        l = r;
                        break
                    }
                    l = r - 1
                }
            if (i[r = l] === n)
                return r / (o - 1);
            var c = i[r];
            return (r + (n - c) / (i[r + 1] - c)) / (o - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4
              , n = t + 1e-4;
            e < 0 && (e = 0),
            n > 1 && (n = 1);
            var i = this.getPoint(e);
            return this.getPoint(n).clone().sub(i).normalize()
        },
        getTangentAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e)
        },
        computeFrenetFrames: function(t, e) {
            var n, i, r, o = new Oe, a = [], s = [], l = [], c = new Oe, h = new Ze;
            for (n = 0; n <= t; n++)
                i = n / t,
                a[n] = this.getTangentAt(i),
                a[n].normalize();
            s[0] = new Oe,
            l[0] = new Oe;
            var u = Number.MAX_VALUE
              , p = Math.abs(a[0].x)
              , d = Math.abs(a[0].y)
              , f = Math.abs(a[0].z);
            for (p <= u && (u = p,
            o.set(1, 0, 0)),
            d <= u && (u = d,
            o.set(0, 1, 0)),
            f <= u && o.set(0, 0, 1),
            c.crossVectors(a[0], o).normalize(),
            s[0].crossVectors(a[0], c),
            l[0].crossVectors(a[0], s[0]),
            n = 1; n <= t; n++)
                s[n] = s[n - 1].clone(),
                l[n] = l[n - 1].clone(),
                c.crossVectors(a[n - 1], a[n]),
                c.length() > Number.EPSILON && (c.normalize(),
                r = Math.acos(Ee.clamp(a[n - 1].dot(a[n]), -1, 1)),
                s[n].applyMatrix4(h.makeRotationAxis(c, r))),
                l[n].crossVectors(a[n], s[n]);
            if (!0 === e)
                for (r = Math.acos(Ee.clamp(s[0].dot(s[t]), -1, 1)),
                r /= t,
                a[0].dot(c.crossVectors(s[0], s[t])) > 0 && (r = -r),
                n = 1; n <= t; n++)
                    s[n].applyMatrix4(h.makeRotationAxis(a[n], r * n)),
                    l[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: l
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }),
    Lc.prototype = Object.create(Tc.prototype),
    Lc.prototype.constructor = Lc,
    Lc.prototype.isEllipseCurve = !0,
    Lc.prototype.getPoint = function(t, e) {
        for (var n = e || new Te, i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0; )
            r += i;
        for (; r > i; )
            r -= i;
        r < Number.EPSILON && (r = o ? 0 : i),
        !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
        var a = this.aStartAngle + t * r
          , s = this.aX + this.xRadius * Math.cos(a)
          , l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var c = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , u = s - this.aX
              , p = l - this.aY;
            s = u * c - p * h + this.aX,
            l = u * h + p * c + this.aY
        }
        return n.set(s, l)
    }
    ,
    Lc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Lc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    ,
    Lc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Dc.prototype = Object.create(Lc.prototype),
    Dc.prototype.constructor = Dc,
    Dc.prototype.isArcCurve = !0;
    var Oc = new Oe
      , jc = new Ic
      , Nc = new Ic
      , kc = new Ic;
    function Fc(t, e, n, i) {
        Tc.call(this),
        this.type = 'CatmullRomCurve3',
        this.points = t || [],
        this.closed = e || !1,
        this.curveType = n || 'centripetal',
        this.tension = i || .5
    }
    function zc(t, e, n, i, r) {
        var o = .5 * (i - e)
          , a = .5 * (r - n)
          , s = t * t;
        return (2 * n - 2 * i + o + a) * (t * s) + (-3 * n + 3 * i - 2 * o - a) * s + o * t + n
    }
    function Rc(t, e, n, i) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function(t, e) {
            return t * t * e
        }(t, i)
    }
    function Uc(t, e, n, i, r) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            var n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function(t, e) {
            return t * t * t * e
        }(t, r)
    }
    function Bc(t, e, n, i) {
        Tc.call(this),
        this.type = 'CubicBezierCurve',
        this.v0 = t || new Te,
        this.v1 = e || new Te,
        this.v2 = n || new Te,
        this.v3 = i || new Te
    }
    function Vc(t, e, n, i) {
        Tc.call(this),
        this.type = 'CubicBezierCurve3',
        this.v0 = t || new Oe,
        this.v1 = e || new Oe,
        this.v2 = n || new Oe,
        this.v3 = i || new Oe
    }
    function Gc(t, e) {
        Tc.call(this),
        this.type = 'LineCurve',
        this.v1 = t || new Te,
        this.v2 = e || new Te
    }
    function Hc(t, e) {
        Tc.call(this),
        this.type = 'LineCurve3',
        this.v1 = t || new Oe,
        this.v2 = e || new Oe
    }
    function Wc(t, e, n) {
        Tc.call(this),
        this.type = 'QuadraticBezierCurve',
        this.v0 = t || new Te,
        this.v1 = e || new Te,
        this.v2 = n || new Te
    }
    function Xc(t, e, n) {
        Tc.call(this),
        this.type = 'QuadraticBezierCurve3',
        this.v0 = t || new Oe,
        this.v1 = e || new Oe,
        this.v2 = n || new Oe
    }
    function qc(t) {
        Tc.call(this),
        this.type = 'SplineCurve',
        this.points = t || []
    }
    Fc.prototype = Object.create(Tc.prototype),
    Fc.prototype.constructor = Fc,
    Fc.prototype.isCatmullRomCurve3 = !0,
    Fc.prototype.getPoint = function(t, e) {
        var n, i, r, o, a = e || new Oe, s = this.points, l = s.length, c = (l - (this.closed ? 0 : 1)) * t, h = Math.floor(c), u = c - h;
        if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / l) + 1) * l : 0 === u && h === l - 1 && (h = l - 2,
        u = 1),
        this.closed || h > 0 ? n = s[(h - 1) % l] : (Oc.subVectors(s[0], s[1]).add(s[0]),
        n = Oc),
        i = s[h % l],
        r = s[(h + 1) % l],
        this.closed || h + 2 < l ? o = s[(h + 2) % l] : (Oc.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]),
        o = Oc),
        'centripetal' === this.curveType || 'chordal' === this.curveType) {
            var p = 'chordal' === this.curveType ? .5 : .25
              , d = Math.pow(n.distanceToSquared(i), p)
              , f = Math.pow(i.distanceToSquared(r), p)
              , m = Math.pow(r.distanceToSquared(o), p);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            jc.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, d, f, m),
            Nc.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, d, f, m),
            kc.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, d, f, m)
        } else
            'catmullrom' === this.curveType && (jc.initCatmullRom(n.x, i.x, r.x, o.x, this.tension),
            Nc.initCatmullRom(n.y, i.y, r.y, o.y, this.tension),
            kc.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
        return a.set(jc.calc(u), Nc.calc(u), kc.calc(u)),
        a
    }
    ,
    Fc.prototype.copy = function(t) {
        Tc.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone())
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    Fc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray())
        }
        return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    ,
    Fc.prototype.fromJSON = function(t) {
        Tc.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new Oe).fromArray(i))
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    Bc.prototype = Object.create(Tc.prototype),
    Bc.prototype.constructor = Bc,
    Bc.prototype.isCubicBezierCurve = !0,
    Bc.prototype.getPoint = function(t, e) {
        var n = e || new Te
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(Uc(t, i.x, r.x, o.x, a.x), Uc(t, i.y, r.y, o.y, a.y)),
        n
    }
    ,
    Bc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    Bc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    Bc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    Vc.prototype = Object.create(Tc.prototype),
    Vc.prototype.constructor = Vc,
    Vc.prototype.isCubicBezierCurve3 = !0,
    Vc.prototype.getPoint = function(t, e) {
        var n = e || new Oe
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(Uc(t, i.x, r.x, o.x, a.x), Uc(t, i.y, r.y, o.y, a.y), Uc(t, i.z, r.z, o.z, a.z)),
        n
    }
    ,
    Vc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    Vc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    Vc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    Gc.prototype = Object.create(Tc.prototype),
    Gc.prototype.constructor = Gc,
    Gc.prototype.isLineCurve = !0,
    Gc.prototype.getPoint = function(t, e) {
        var n = e || new Te;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    Gc.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    Gc.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    Gc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Gc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Gc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Hc.prototype = Object.create(Tc.prototype),
    Hc.prototype.constructor = Hc,
    Hc.prototype.isLineCurve3 = !0,
    Hc.prototype.getPoint = function(t, e) {
        var n = e || new Oe;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    Hc.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    Hc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Hc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Hc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Wc.prototype = Object.create(Tc.prototype),
    Wc.prototype.constructor = Wc,
    Wc.prototype.isQuadraticBezierCurve = !0,
    Wc.prototype.getPoint = function(t, e) {
        var n = e || new Te
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(Rc(t, i.x, r.x, o.x), Rc(t, i.y, r.y, o.y)),
        n
    }
    ,
    Wc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Wc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Wc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Xc.prototype = Object.create(Tc.prototype),
    Xc.prototype.constructor = Xc,
    Xc.prototype.isQuadraticBezierCurve3 = !0,
    Xc.prototype.getPoint = function(t, e) {
        var n = e || new Oe
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(Rc(t, i.x, r.x, o.x), Rc(t, i.y, r.y, o.y), Rc(t, i.z, r.z, o.z)),
        n
    }
    ,
    Xc.prototype.copy = function(t) {
        return Tc.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Xc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Xc.prototype.fromJSON = function(t) {
        return Tc.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    qc.prototype = Object.create(Tc.prototype),
    qc.prototype.constructor = qc,
    qc.prototype.isSplineCurve = !0,
    qc.prototype.getPoint = function(t, e) {
        var n = e || new Te
          , i = this.points
          , r = (i.length - 1) * t
          , o = Math.floor(r)
          , a = r - o
          , s = i[0 === o ? o : o - 1]
          , l = i[o]
          , c = i[o > i.length - 2 ? i.length - 1 : o + 1]
          , h = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(zc(a, s.x, l.x, c.x, h.x), zc(a, s.y, l.y, c.y, h.y)),
        n
    }
    ,
    qc.prototype.copy = function(t) {
        Tc.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push(i.clone())
        }
        return this
    }
    ,
    qc.prototype.toJSON = function() {
        var t = Tc.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var i = this.points[e];
            t.points.push(i.toArray())
        }
        return t
    }
    ,
    qc.prototype.fromJSON = function(t) {
        Tc.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var i = t.points[e];
            this.points.push((new Te).fromArray(i))
        }
        return this
    }
    ;
    var Yc = Object.freeze({
        __proto__: null,
        ArcCurve: Dc,
        CatmullRomCurve3: Fc,
        CubicBezierCurve: Bc,
        CubicBezierCurve3: Vc,
        EllipseCurve: Lc,
        LineCurve: Gc,
        LineCurve3: Hc,
        QuadraticBezierCurve: Wc,
        QuadraticBezierCurve3: Xc,
        SplineCurve: qc
    });
    function Jc() {
        Tc.call(this),
        this.type = 'CurvePath',
        this.curves = [],
        this.autoClose = !1
    }
    function Zc(t) {
        Jc.call(this),
        this.type = 'Path',
        this.currentPoint = new Te,
        t && this.setFromPoints(t)
    }
    function Kc(t) {
        Zc.call(this, t),
        this.uuid = Ee.generateUUID(),
        this.type = 'Shape',
        this.holes = []
    }
    function Qc(t, e) {
        mn.call(this),
        this.type = 'Light',
        this.color = new ai(t),
        this.intensity = void 0 !== e ? e : 1,
        this.receiveShadow = void 0
    }
    function $c(t, e, n) {
        Qc.call(this, t, n),
        this.type = 'HemisphereLight',
        this.castShadow = void 0,
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new ai(e)
    }
    function th(t) {
        this.camera = t,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new Te(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Ze,
        this._frustum = new _r,
        this._frameExtents = new Te(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ue(0,0,1,1)]
    }
    function eh() {
        th.call(this, new dr(50,1,.5,500))
    }
    function nh(t, e, n, i, r, o) {
        Qc.call(this, t, e),
        this.type = 'SpotLight',
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.target = new mn,
        Object.defineProperty(this, 'power', {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.angle = void 0 !== i ? i : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== o ? o : 1,
        this.shadow = new eh
    }
    function ih() {
        th.call(this, new dr(90,1,.5,500)),
        this._frameExtents = new Te(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ue(2,1,1,1), new Ue(0,1,1,1), new Ue(3,1,1,1), new Ue(1,1,1,1), new Ue(3,0,1,1), new Ue(1,0,1,1)],
        this._cubeDirections = [new Oe(1,0,0), new Oe(-1,0,0), new Oe(0,0,1), new Oe(0,0,-1), new Oe(0,1,0), new Oe(0,-1,0)],
        this._cubeUps = [new Oe(0,1,0), new Oe(0,1,0), new Oe(0,1,0), new Oe(0,1,0), new Oe(0,0,1), new Oe(0,0,-1)]
    }
    function rh(t, e, n, i) {
        Qc.call(this, t, e),
        this.type = 'PointLight',
        Object.defineProperty(this, 'power', {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.decay = void 0 !== i ? i : 1,
        this.shadow = new ih
    }
    function oh(t, e, n, i, r, o) {
        pr.call(this),
        this.type = 'OrthographicCamera',
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== t ? t : -1,
        this.right = void 0 !== e ? e : 1,
        this.top = void 0 !== n ? n : 1,
        this.bottom = void 0 !== i ? i : -1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== o ? o : 2e3,
        this.updateProjectionMatrix()
    }
    function ah() {
        th.call(this, new oh(-5,5,5,-5,.5,500))
    }
    function sh(t, e) {
        Qc.call(this, t, e),
        this.type = 'DirectionalLight',
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.target = new mn,
        this.shadow = new ah
    }
    function lh(t, e) {
        Qc.call(this, t, e),
        this.type = 'AmbientLight',
        this.castShadow = void 0
    }
    function ch(t, e, n, i) {
        Qc.call(this, t, e),
        this.type = 'RectAreaLight',
        this.width = void 0 !== n ? n : 10,
        this.height = void 0 !== i ? i : 10
    }
    function hh(t) {
        bc.call(this, t),
        this.textures = {}
    }
    Jc.prototype = Object.assign(Object.create(Tc.prototype), {
        constructor: Jc,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Gc(e,t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length; ) {
                if (n[i] >= e) {
                    var r = n[i] - e
                      , o = this.curves[i]
                      , a = o.getLength()
                      , s = 0 === a ? 0 : 1 - r / a;
                    return o.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
                e += this.curves[n].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
                for (var o = r[i], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
                    var c = s[l];
                    e && e.equals(c) || (n.push(c),
                    e = c)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
            n
        },
        copy: function(t) {
            Tc.prototype.copy.call(this, t),
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var i = t.curves[e];
                this.curves.push(i.clone())
            }
            return this.autoClose = t.autoClose,
            this
        },
        toJSON: function() {
            var t = Tc.prototype.toJSON.call(this);
            t.autoClose = this.autoClose,
            t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++) {
                var i = this.curves[e];
                t.curves.push(i.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Tc.prototype.fromJSON.call(this, t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var i = t.curves[e];
                this.curves.push((new Yc[i.type]).fromJSON(i))
            }
            return this
        }
    }),
    Zc.prototype = Object.assign(Object.create(Jc.prototype), {
        constructor: Zc,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++)
                this.lineTo(t[e].x, t[e].y);
            return this
        },
        moveTo: function(t, e) {
            return this.currentPoint.set(t, e),
            this
        },
        lineTo: function(t, e) {
            var n = new Gc(this.currentPoint.clone(),new Te(t,e));
            return this.curves.push(n),
            this.currentPoint.set(t, e),
            this
        },
        quadraticCurveTo: function(t, e, n, i) {
            var r = new Wc(this.currentPoint.clone(),new Te(t,e),new Te(n,i));
            return this.curves.push(r),
            this.currentPoint.set(n, i),
            this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            var a = new Bc(this.currentPoint.clone(),new Te(t,e),new Te(n,i),new Te(r,o));
            return this.curves.push(a),
            this.currentPoint.set(r, o),
            this
        },
        splineThru: function(t) {
            var e = new qc([this.currentPoint.clone()].concat(t));
            return this.curves.push(e),
            this.currentPoint.copy(t[t.length - 1]),
            this
        },
        arc: function(t, e, n, i, r, o) {
            var a = this.currentPoint.x
              , s = this.currentPoint.y;
            return this.absarc(t + a, e + s, n, i, r, o),
            this
        },
        absarc: function(t, e, n, i, r, o) {
            return this.absellipse(t, e, n, n, i, r, o),
            this
        },
        ellipse: function(t, e, n, i, r, o, a, s) {
            var l = this.currentPoint.x
              , c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, o, a, s),
            this
        },
        absellipse: function(t, e, n, i, r, o, a, s) {
            var l = new Lc(t,e,n,i,r,o,a,s);
            if (this.curves.length > 0) {
                var c = l.getPoint(0);
                c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
            }
            this.curves.push(l);
            var h = l.getPoint(1);
            return this.currentPoint.copy(h),
            this
        },
        copy: function(t) {
            return Jc.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
        },
        toJSON: function() {
            var t = Jc.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(),
            t
        },
        fromJSON: function(t) {
            return Jc.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }),
    Kc.prototype = Object.assign(Object.create(Zc.prototype), {
        constructor: Kc,
        getPointsHoles: function(t) {
            for (var e = [], n = 0, i = this.holes.length; n < i; n++)
                e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            Zc.prototype.copy.call(this, t),
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var i = t.holes[e];
                this.holes.push(i.clone())
            }
            return this
        },
        toJSON: function() {
            var t = Zc.prototype.toJSON.call(this);
            t.uuid = this.uuid,
            t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++) {
                var i = this.holes[e];
                t.holes.push(i.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Zc.prototype.fromJSON.call(this, t),
            this.uuid = t.uuid,
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var i = t.holes[e];
                this.holes.push((new Zc).fromJSON(i))
            }
            return this
        }
    }),
    Qc.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Qc,
        isLight: !0,
        copy: function(t) {
            return mn.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            var e = mn.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }),
    $c.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: $c,
        isHemisphereLight: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }),
    Object.assign(th.prototype, {
        _projScreenMatrix: new Ze,
        _lightPositionWorld: new Oe,
        _lookTarget: new Oe,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(t) {
            var e = this.camera
              , n = this.matrix
              , i = this._projScreenMatrix
              , r = this._lookTarget
              , o = this._lightPositionWorld;
            o.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(o),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(r),
            e.updateMatrixWorld(),
            i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromMatrix(i),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse)
        },
        getViewport: function(t) {
            return this._viewports[t]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }),
    eh.prototype = Object.assign(Object.create(th.prototype), {
        constructor: eh,
        isSpotLightShadow: !0,
        updateMatrices: function(t) {
            var e = this.camera
              , n = 2 * Ee.RAD2DEG * t.angle
              , i = this.mapSize.width / this.mapSize.height
              , r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
            e.aspect = i,
            e.far = r,
            e.updateProjectionMatrix()),
            th.prototype.updateMatrices.call(this, t)
        }
    }),
    nh.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: nh,
        isSpotLight: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    ih.prototype = Object.assign(Object.create(th.prototype), {
        constructor: ih,
        isPointLightShadow: !0,
        updateMatrices: function(t, e) {
            void 0 === e && (e = 0);
            var n = this.camera
              , i = this.matrix
              , r = this._lightPositionWorld
              , o = this._lookTarget
              , a = this._projScreenMatrix;
            r.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(r),
            o.copy(n.position),
            o.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(o),
            n.updateMatrixWorld(),
            i.makeTranslation(-r.x, -r.y, -r.z),
            a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromMatrix(a)
        }
    }),
    rh.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: rh,
        isPointLight: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    oh.prototype = Object.assign(Object.create(pr.prototype), {
        constructor: oh,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return pr.prototype.copy.call(this, t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        },
        setViewOffset: function(t, e, n, i, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2
              , r = n - t
              , o = n + t
              , a = i + e
              , s = i - e;
            if (null !== this.view && this.view.enabled) {
                var l = this.zoom / (this.view.width / this.view.fullWidth)
                  , c = this.zoom / (this.view.height / this.view.fullHeight)
                  , h = (this.right - this.left) / this.view.width
                  , u = (this.top - this.bottom) / this.view.height;
                o = (r += h * (this.view.offsetX / l)) + h * (this.view.width / l),
                s = (a -= u * (this.view.offsetY / c)) - u * (this.view.height / c)
            }
            this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            var e = mn.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }),
    ah.prototype = Object.assign(Object.create(th.prototype), {
        constructor: ah,
        isDirectionalLightShadow: !0,
        updateMatrices: function(t) {
            th.prototype.updateMatrices.call(this, t)
        }
    }),
    sh.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: sh,
        isDirectionalLight: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    lh.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: lh,
        isAmbientLight: !0
    }),
    ch.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: ch,
        isRectAreaLight: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            var e = Qc.prototype.toJSON.call(this, t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    }),
    hh.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: hh,
        load: function(t, e, n, i) {
            var r = this
              , o = new Mc(r.manager);
            o.setPath(r.path),
            o.load(t, (function(t) {
                e(r.parse(JSON.parse(t)))
            }
            ), n, i)
        },
        parse: function(t) {
            var e = this.textures;
            function n(t) {
                return e[t],
                e[t]
            }
            var i = new ec[t.type];
            if (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = (new ai).setHex(t.sheen)),
            void 0 !== t.emissive && i.emissive.setHex(t.emissive),
            void 0 !== t.specular && i.specular.setHex(t.specular),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.vertexColors && (i.vertexColors = t.vertexColors),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (i.skinning = t.skinning),
            void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
            void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.uniforms)
                for (var r in t.uniforms) {
                    var o = t.uniforms[r];
                    switch (i.uniforms[r] = {},
                    o.type) {
                    case 't':
                        i.uniforms[r].value = n(o.value);
                        break;
                    case 'c':
                        i.uniforms[r].value = (new ai).setHex(o.value);
                        break;
                    case 'v2':
                        i.uniforms[r].value = (new Te).fromArray(o.value);
                        break;
                    case 'v3':
                        i.uniforms[r].value = (new Oe).fromArray(o.value);
                        break;
                    case 'v4':
                        i.uniforms[r].value = (new Ue).fromArray(o.value);
                        break;
                    case 'm3':
                        i.uniforms[r].value = (new ke).fromArray(o.value);
                    case 'm4':
                        i.uniforms[r].value = (new Ze).fromArray(o.value);
                        break;
                    default:
                        i.uniforms[r].value = o.value
                    }
                }
            if (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
                for (var a in t.extensions)
                    i.extensions[a] = t.extensions[a];
            if (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap),
            i.transparent = !0),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale) {
                var s = t.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]),
                i.normalScale = (new Te).fromArray(s)
            }
            return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Te).fromArray(t.clearcoatNormalScale)),
            i
        },
        setTextures: function(t) {
            return this.textures = t,
            this
        }
    });
    var uh = function(t) {
        var e = t.lastIndexOf('/');
        return -1 === e ? './' : t.substr(0, e + 1)
    };
    function ph() {
        Oi.call(this),
        this.type = 'InstancedBufferGeometry',
        this.maxInstancedCount = void 0
    }
    function dh(t, e, n, i) {
        'number' == typeof n && (i = n,
        n = !1),
        fi.call(this, t, e, n),
        this.meshPerAttribute = i || 1
    }
    function fh(t) {
        bc.call(this, t)
    }
    ph.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: ph,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return Oi.prototype.copy.call(this, t),
            this.maxInstancedCount = t.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = Oi.prototype.toJSON.call(this);
            return t.maxInstancedCount = this.maxInstancedCount,
            t.isInstancedBufferGeometry = !0,
            t
        }
    }),
    dh.prototype = Object.assign(Object.create(fi.prototype), {
        constructor: dh,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return fi.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        },
        toJSON: function() {
            var t = fi.prototype.toJSON.call(this);
            return t.meshPerAttribute = this.meshPerAttribute,
            t.isInstancedBufferAttribute = !0,
            t
        }
    }),
    fh.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: fh,
        load: function(t, e, n, i) {
            var r = this
              , o = new Mc(r.manager);
            o.setPath(r.path),
            o.load(t, (function(t) {
                e(r.parse(JSON.parse(t)))
            }
            ), n, i)
        },
        parse: function(t) {
            var e = t.isInstancedBufferGeometry ? new ph : new Oi
              , n = t.data.index;
            if (void 0 !== n) {
                var i = new mh[n.type](n.array);
                e.setIndex(new fi(i,1))
            }
            var r = t.data.attributes;
            for (var o in r) {
                var a = r[o]
                  , s = (i = new mh[a.type](a.array),
                new (a.isInstancedBufferAttribute ? dh : fi)(i,a.itemSize,a.normalized));
                void 0 !== a.name && (s.name = a.name),
                e.setAttribute(o, s)
            }
            var l = t.data.morphAttributes;
            if (l)
                for (var o in l) {
                    for (var c = l[o], h = [], u = 0, p = c.length; u < p; u++) {
                        a = c[u],
                        s = new fi(i = new mh[a.type](a.array),a.itemSize,a.normalized);
                        void 0 !== a.name && (s.name = a.name),
                        h.push(s)
                    }
                    e.morphAttributes[o] = h
                }
            t.data.morphTargetsRelative && (e.morphTargetsRelative = !0);
            var d = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== d) {
                u = 0;
                for (var f = d.length; u !== f; ++u) {
                    var m = d[u];
                    e.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var g = t.data.boundingSphere;
            if (void 0 !== g) {
                var v = new Oe;
                void 0 !== g.center && v.fromArray(g.center),
                e.boundingSphere = new On(v,g.radius)
            }
            return t.name && (e.name = t.name),
            t.userData && (e.userData = t.userData),
            e
        }
    });
    var mh = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: 'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function gh(t) {
        bc.call(this, t)
    }
    gh.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: gh,
        load: function(t, e, n, i) {
            var r = this
              , o = '' === this.path ? uh(t) : this.path;
            this.resourcePath = this.resourcePath || o;
            var a = new Mc(r.manager);
            a.setPath(this.path),
            a.load(t, (function(t) {
                var n = null;
                try {
                    n = JSON.parse(t)
                } catch (t) {
                    return void (void 0 !== i && i(t))
                }
                var o = n.metadata;
                void 0 !== o && void 0 !== o.type && 'geometry' !== o.type.toLowerCase() && r.parse(n, e)
            }
            ), n, i)
        },
        parse: function(t, e) {
            var n = this.parseShape(t.shapes)
              , i = this.parseGeometries(t.geometries, n)
              , r = this.parseImages(t.images, (function() {
                void 0 !== e && e(s)
            }
            ))
              , o = this.parseTextures(t.textures, r)
              , a = this.parseMaterials(t.materials, o)
              , s = this.parseObject(t.object, i, a);
            return t.animations && (s.animations = this.parseAnimations(t.animations)),
            void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s),
            s
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, i = t.length; n < i; n++) {
                    var r = (new Kc).fromJSON(t[n]);
                    e[r.uuid] = r
                }
            return e
        },
        parseGeometries: function(t, e) {
            var n = {};
            if (void 0 !== t)
                for (var i = new fh, r = 0, o = t.length; r < o; r++) {
                    var a, s = t[r];
                    switch (s.type) {
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':
                        a = new Hl[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                        break;
                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                    case 'CubeGeometry':
                        a = new Hl[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                        break;
                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':
                        a = new Hl[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                        break;
                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':
                        a = new Hl[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':
                        a = new Hl[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case 'SphereGeometry':
                    case 'SphereBufferGeometry':
                        a = new Hl[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                        break;
                    case 'DodecahedronGeometry':
                    case 'DodecahedronBufferGeometry':
                    case 'IcosahedronGeometry':
                    case 'IcosahedronBufferGeometry':
                    case 'OctahedronGeometry':
                    case 'OctahedronBufferGeometry':
                    case 'TetrahedronGeometry':
                    case 'TetrahedronBufferGeometry':
                        a = new Hl[s.type](s.radius,s.detail);
                        break;
                    case 'RingGeometry':
                    case 'RingBufferGeometry':
                        a = new Hl[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                        break;
                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':
                        a = new Hl[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                        break;
                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':
                        a = new Hl[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                        break;
                    case 'TubeGeometry':
                    case 'TubeBufferGeometry':
                        a = new Hl[s.type]((new Yc[s.path.type]).fromJSON(s.path),s.tubularSegments,s.radius,s.radialSegments,s.closed);
                        break;
                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':
                        a = new Hl[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                        break;
                    case 'PolyhedronGeometry':
                    case 'PolyhedronBufferGeometry':
                        a = new Hl[s.type](s.vertices,s.indices,s.radius,s.details);
                        break;
                    case 'ShapeGeometry':
                    case 'ShapeBufferGeometry':
                        for (var l = [], c = 0, h = s.shapes.length; c < h; c++) {
                            var u = e[s.shapes[c]];
                            l.push(u)
                        }
                        a = new Hl[s.type](l,s.curveSegments);
                        break;
                    case 'ExtrudeGeometry':
                    case 'ExtrudeBufferGeometry':
                        for (l = [],
                        c = 0,
                        h = s.shapes.length; c < h; c++) {
                            u = e[s.shapes[c]];
                            l.push(u)
                        }
                        var p = s.options.extrudePath;
                        void 0 !== p && (s.options.extrudePath = (new Yc[p.type]).fromJSON(p)),
                        a = new Hl[s.type](l,s.options);
                        break;
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        a = i.parse(s);
                        break;
                    case 'Geometry':
                        if ('THREE'in window && 'LegacyJSONLoader'in THREE)
                            a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                        break;
                    default:
                        continue
                    }
                    a.uuid = s.uuid,
                    void 0 !== s.name && (a.name = s.name),
                    !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData),
                    n[s.uuid] = a
                }
            return n
        },
        parseMaterials: function(t, e) {
            var n = {}
              , i = {};
            if (void 0 !== t) {
                var r = new hh;
                r.setTextures(e);
                for (var o = 0, a = t.length; o < a; o++) {
                    var s = t[o];
                    if ('MultiMaterial' === s.type) {
                        for (var l = [], c = 0; c < s.materials.length; c++) {
                            var h = s.materials[c];
                            void 0 === n[h.uuid] && (n[h.uuid] = r.parse(h)),
                            l.push(n[h.uuid])
                        }
                        i[s.uuid] = l
                    } else
                        void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                        i[s.uuid] = n[s.uuid]
                }
            }
            return i
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var i = t[n]
                  , r = mc.parse(i);
                void 0 !== i.uuid && (r.uuid = i.uuid),
                e.push(r)
            }
            return e
        },
        parseImages: function(t, e) {
            var n = this
              , i = {};
            function r(t) {
                return n.manager.itemStart(t),
                o.load(t, (function() {
                    n.manager.itemEnd(t)
                }
                ), void 0, (function() {
                    n.manager.itemError(t),
                    n.manager.itemEnd(t)
                }
                ))
            }
            if (void 0 !== t && t.length > 0) {
                var o = new Cc(new yc(e));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var l = t[a]
                      , c = l.url;
                    if (Array.isArray(c)) {
                        i[l.uuid] = [];
                        for (var h = 0, u = c.length; h < u; h++) {
                            var p = c[h]
                              , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
                            i[l.uuid].push(r(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                        i[l.uuid] = r(d)
                    }
                }
            }
            return i
        },
        parseTextures: function(t, e) {
            function n(t, e) {
                return 'number' == typeof t ? t : e[t]
            }
            var i = {};
            if (void 0 !== t)
                for (var r = 0, o = t.length; r < o; r++) {
                    var a, s = t[r];
                    s.image,
                    e[s.image],
                    (a = Array.isArray(e[s.image]) ? new Ur(e[s.image]) : new Re(e[s.image])).needsUpdate = !0,
                    a.uuid = s.uuid,
                    void 0 !== s.name && (a.name = s.name),
                    void 0 !== s.mapping && (a.mapping = n(s.mapping, yh)),
                    void 0 !== s.offset && a.offset.fromArray(s.offset),
                    void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
                    void 0 !== s.center && a.center.fromArray(s.center),
                    void 0 !== s.rotation && (a.rotation = s.rotation),
                    void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], xh),
                    a.wrapT = n(s.wrap[1], xh)),
                    void 0 !== s.format && (a.format = s.format),
                    void 0 !== s.type && (a.type = s.type),
                    void 0 !== s.encoding && (a.encoding = s.encoding),
                    void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, bh)),
                    void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, bh)),
                    void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (a.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment),
                    i[s.uuid] = a
                }
            return i
        },
        parseObject: function(t, e, n) {
            var i;
            function r(t) {
                return e[t],
                e[t]
            }
            function o(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0, r = t.length; i < r; i++) {
                            var o = t[i];
                            n[o],
                            e.push(n[o])
                        }
                        return e
                    }
                    return n[t],
                    n[t]
                }
            }
            switch (t.type) {
            case 'Scene':
                i = new gn,
                void 0 !== t.background && Number.isInteger(t.background) && (i.background = new ai(t.background)),
                void 0 !== t.fog && ('Fog' === t.fog.type ? i.fog = new Oa(t.fog.color,t.fog.near,t.fog.far) : 'FogExp2' === t.fog.type && (i.fog = new Ia(t.fog.color,t.fog.density)));
                break;
            case 'PerspectiveCamera':
                i = new dr(t.fov,t.aspect,t.near,t.far),
                void 0 !== t.focus && (i.focus = t.focus),
                void 0 !== t.zoom && (i.zoom = t.zoom),
                void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
                void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
            case 'OrthographicCamera':
                i = new oh(t.left,t.right,t.top,t.bottom,t.near,t.far),
                void 0 !== t.zoom && (i.zoom = t.zoom),
                void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
            case 'AmbientLight':
                i = new lh(t.color,t.intensity);
                break;
            case 'DirectionalLight':
                i = new sh(t.color,t.intensity);
                break;
            case 'PointLight':
                i = new rh(t.color,t.intensity,t.distance,t.decay);
                break;
            case 'RectAreaLight':
                i = new ch(t.color,t.intensity,t.width,t.height);
                break;
            case 'SpotLight':
                i = new nh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);
                break;
            case 'HemisphereLight':
                i = new $c(t.color,t.groundColor,t.intensity);
                break;
            case 'SkinnedMesh':
            case 'Mesh':
                var a = r(t.geometry)
                  , s = o(t.material);
                i = a.bones && a.bones.length > 0 ? new ts(a,s) : new Ki(a,s);
                break;
            case 'InstancedMesh':
                a = r(t.geometry),
                s = o(t.material);
                var l = t.count
                  , c = t.instanceMatrix;
                (i = new cs(a,s,l)).instanceMatrix = new fi(new Float32Array(c.array),16);
                break;
            case 'LOD':
                i = new $a;
                break;
            case 'Line':
                i = new gs(r(t.geometry),o(t.material),t.mode);
                break;
            case 'LineLoop':
                i = new bs(r(t.geometry),o(t.material));
                break;
            case 'LineSegments':
                i = new xs(r(t.geometry),o(t.material));
                break;
            case 'PointCloud':
            case 'Points':
                i = new Cs(r(t.geometry),o(t.material));
                break;
            case 'Sprite':
                i = new Ja(o(t.material));
                break;
            case 'Group':
                i = new wa;
                break;
            default:
                i = new mn
            }
            if (i.uuid = t.uuid,
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix),
            void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate),
            i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position),
            void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
            void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
            void 0 !== t.scale && i.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (i.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
            t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
            void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.layers && (i.layers.mask = t.layers),
            void 0 !== t.drawMode && i.setDrawMode(t.drawMode),
            void 0 !== t.children)
                for (var h = t.children, u = 0; u < h.length; u++)
                    i.add(this.parseObject(h[u], e, n));
            if ('LOD' === t.type) {
                void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
                for (var p = t.levels, d = 0; d < p.length; d++) {
                    var f = p[d]
                      , m = i.getObjectByProperty('uuid', f.object);
                    void 0 !== m && i.addLevel(m, f.distance)
                }
            }
            return i
        }
    });
    var vh, yh = {
        UVMapping: 300,
        CubeReflectionMapping: tt,
        CubeRefractionMapping: et,
        EquirectangularReflectionMapping: nt,
        EquirectangularRefractionMapping: it,
        SphericalReflectionMapping: rt,
        CubeUVReflectionMapping: ot,
        CubeUVRefractionMapping: at
    }, xh = {
        RepeatWrapping: st,
        ClampToEdgeWrapping: lt,
        MirroredRepeatWrapping: ct
    }, bh = {
        NearestFilter: ht,
        NearestMipmapNearestFilter: ut,
        NearestMipmapLinearFilter: pt,
        LinearFilter: dt,
        LinearMipmapNearestFilter: ft,
        LinearMipmapLinearFilter: mt
    };
    function _h(t) {
        bc.call(this, t),
        this.options = void 0
    }
    function Mh() {
        this.type = 'ShapePath',
        this.color = new ai,
        this.subPaths = [],
        this.currentPath = null
    }
    function wh(t) {
        this.type = 'Font',
        this.data = t
    }
    function Sh(t, e, n, i, r) {
        var o = r.glyphs[t] || r.glyphs['?'];
        if (o) {
            var a, s, l, c, h, u, p, d, f = new Mh;
            if (o.o)
                for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(' ')), g = 0, v = m.length; g < v; ) {
                    switch (m[g++]) {
                    case 'm':
                        a = m[g++] * e + n,
                        s = m[g++] * e + i,
                        f.moveTo(a, s);
                        break;
                    case 'l':
                        a = m[g++] * e + n,
                        s = m[g++] * e + i,
                        f.lineTo(a, s);
                        break;
                    case 'q':
                        l = m[g++] * e + n,
                        c = m[g++] * e + i,
                        h = m[g++] * e + n,
                        u = m[g++] * e + i,
                        f.quadraticCurveTo(h, u, l, c);
                        break;
                    case 'b':
                        l = m[g++] * e + n,
                        c = m[g++] * e + i,
                        h = m[g++] * e + n,
                        u = m[g++] * e + i,
                        p = m[g++] * e + n,
                        d = m[g++] * e + i,
                        f.bezierCurveTo(h, u, p, d, l, c)
                    }
                }
            return {
                offsetX: o.ha * e,
                path: f
            }
        }
    }
    function Ph(t) {
        bc.call(this, t)
    }
    _h.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: _h,
        setOptions: function(t) {
            return this.options = t,
            this
        },
        load: function(t, e, n, i) {
            void 0 === t && (t = ''),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , o = vc.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            fetch(t).then((function(t) {
                return t.blob()
            }
            )).then((function(t) {
                return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
            }
            )).then((function(n) {
                vc.add(t, n),
                e && e(n),
                r.manager.itemEnd(t)
            }
            )).catch((function(e) {
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            )),
            r.manager.itemStart(t)
        }
    }),
    Object.assign(Mh.prototype, {
        moveTo: function(t, e) {
            return this.currentPath = new Zc,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
        },
        lineTo: function(t, e) {
            return this.currentPath.lineTo(t, e),
            this
        },
        quadraticCurveTo: function(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i),
            this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, o),
            this
        },
        splineThru: function(t) {
            return this.currentPath.splineThru(t),
            this
        },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) {
                    var r = t[n]
                      , o = new Kc;
                    o.curves = r.curves,
                    e.push(o)
                }
                return e
            }
            function i(t, e) {
                for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                    var a = e[r]
                      , s = e[o]
                      , l = s.x - a.x
                      , c = s.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (a = e[o],
                        l = -l,
                        s = e[r],
                        c = -c),
                        t.y < a.y || t.y > s.y)
                            continue;
                        if (t.y === a.y) {
                            if (t.x === a.x)
                                return !0
                        } else {
                            var h = c * (t.x - a.x) - l * (t.y - a.y);
                            if (0 === h)
                                return !0;
                            if (h < 0)
                                continue;
                            i = !i
                        }
                    } else {
                        if (t.y !== a.y)
                            continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)
                            return !0
                    }
                }
                return i
            }
            var r = xl.isClockWise
              , o = this.subPaths;
            if (0 === o.length)
                return [];
            if (!0 === e)
                return n(o);
            var a, s, l, c = [];
            if (1 === o.length)
                return s = o[0],
                (l = new Kc).curves = s.curves,
                c.push(l),
                c;
            var h = !r(o[0].getPoints());
            h = t ? !h : h;
            var u, p, d = [], f = [], m = [], g = 0;
            f[g] = void 0,
            m[g] = [];
            for (var v = 0, y = o.length; v < y; v++)
                a = r(u = (s = o[v]).getPoints()),
                (a = t ? !a : a) ? (!h && f[g] && g++,
                f[g] = {
                    s: new Kc,
                    p: u
                },
                f[g].s.curves = s.curves,
                h && g++,
                m[g] = []) : m[g].push({
                    h: s,
                    p: u[0]
                });
            if (!f[0])
                return n(o);
            if (f.length > 1) {
                for (var x = !1, b = [], _ = 0, M = f.length; _ < M; _++)
                    d[_] = [];
                for (_ = 0,
                M = f.length; _ < M; _++)
                    for (var w = m[_], S = 0; S < w.length; S++) {
                        for (var P = w[S], C = !0, A = 0; A < f.length; A++)
                            i(P.p, f[A].p) && (_ !== A && b.push({
                                froms: _,
                                tos: A,
                                hole: S
                            }),
                            C ? (C = !1,
                            d[A].push(P)) : x = !0);
                        C && d[_].push(P)
                    }
                b.length > 0 && (x || (m = d))
            }
            v = 0;
            for (var E = f.length; v < E; v++) {
                l = f[v].s,
                c.push(l);
                for (var T = 0, L = (p = m[v]).length; T < L; T++)
                    l.holes.push(p[T].h)
            }
            return c
        }
    }),
    Object.assign(wh.prototype, {
        isFont: !0,
        generateShapes: function(t, e) {
            void 0 === e && (e = 100);
            for (var n = [], i = function(t, e, n) {
                for (var i = Array.from ? Array.from(t) : String(t).split(''), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, l = 0, c = 0; c < i.length; c++) {
                    var h = i[c];
                    if ('\n' === h)
                        s = 0,
                        l -= o;
                    else {
                        var u = Sh(h, r, s, l, n);
                        s += u.offsetX,
                        a.push(u.path)
                    }
                }
                return a
            }(t, e, this.data), r = 0, o = i.length; r < o; r++)
                Array.prototype.push.apply(n, i[r].toShapes());
            return n
        }
    }),
    Ph.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Ph,
        load: function(t, e, n, i) {
            var r = this
              , o = new Mc(this.manager);
            o.setPath(this.path),
            o.load(t, (function(t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    n = JSON.parse(t.substring(65, t.length - 2))
                }
                var i = r.parse(n);
                e && e(i)
            }
            ), n, i)
        },
        parse: function(t) {
            return new wh(t)
        }
    });
    var Ch = {
        getContext: function() {
            return void 0 === vh && (vh = new (window.AudioContext || window.webkitAudioContext)),
            vh
        },
        setContext: function(t) {
            vh = t
        }
    };
    function Ah(t) {
        bc.call(this, t)
    }
    function Eh() {
        this.coefficients = [];
        for (var t = 0; t < 9; t++)
            this.coefficients.push(new Oe)
    }
    function Th(t, e) {
        Qc.call(this, void 0, e),
        this.sh = void 0 !== t ? t : new Eh
    }
    function Lh(t, e, n) {
        Th.call(this, void 0, n);
        var i = (new ai).set(t)
          , r = (new ai).set(e)
          , o = new Oe(i.r,i.g,i.b)
          , a = new Oe(r.r,r.g,r.b)
          , s = Math.sqrt(Math.PI)
          , l = s * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l)
    }
    function Dh(t, e) {
        Th.call(this, void 0, e);
        var n = (new ai).set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Ah.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Ah,
        load: function(t, e, n, i) {
            var r = new Mc(this.manager);
            r.setResponseType('arraybuffer'),
            r.setPath(this.path),
            r.load(t, (function(t) {
                var n = t.slice(0);
                Ch.getContext().decodeAudioData(n, (function(t) {
                    e(t)
                }
                ))
            }
            ), n, i)
        }
    }),
    Object.assign(Eh.prototype, {
        isSphericalHarmonics3: !0,
        set: function(t) {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].copy(t[e]);
            return this
        },
        zero: function() {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].set(0, 0, 0);
            return this
        },
        getAt: function(t, e) {
            var n = t.x
              , i = t.y
              , r = t.z
              , o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.282095),
            e.addScale(o[1], .488603 * i),
            e.addScale(o[2], .488603 * r),
            e.addScale(o[3], .488603 * n),
            e.addScale(o[4], n * i * 1.092548),
            e.addScale(o[5], i * r * 1.092548),
            e.addScale(o[6], .315392 * (3 * r * r - 1)),
            e.addScale(o[7], n * r * 1.092548),
            e.addScale(o[8], .546274 * (n * n - i * i)),
            e
        },
        getIrradianceAt: function(t, e) {
            var n = t.x
              , i = t.y
              , r = t.z
              , o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.886227),
            e.addScale(o[1], 1.023328 * i),
            e.addScale(o[2], 1.023328 * r),
            e.addScale(o[3], 1.023328 * n),
            e.addScale(o[4], .858086 * n * i),
            e.addScale(o[5], .858086 * i * r),
            e.addScale(o[6], .743125 * r * r - .247708),
            e.addScale(o[7], .858086 * n * r),
            e.addScale(o[8], .429043 * (n * n - i * i)),
            e
        },
        add: function(t) {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].add(t.coefficients[e]);
            return this
        },
        scale: function(t) {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].multiplyScalar(t);
            return this
        },
        lerp: function(t, e) {
            for (var n = 0; n < 9; n++)
                this.coefficients[n].lerp(t.coefficients[n], e);
            return this
        },
        equals: function(t) {
            for (var e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e]))
                    return !1;
            return !0
        },
        copy: function(t) {
            return this.set(t.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++)
                n[i].fromArray(t, e + 3 * i);
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            for (var n = this.coefficients, i = 0; i < 9; i++)
                n[i].toArray(t, e + 3 * i);
            return t
        }
    }),
    Object.assign(Eh, {
        getBasisAt: function(t, e) {
            var n = t.x
              , i = t.y
              , r = t.z;
            e[0] = .282095,
            e[1] = .488603 * i,
            e[2] = .488603 * r,
            e[3] = .488603 * n,
            e[4] = 1.092548 * n * i,
            e[5] = 1.092548 * i * r,
            e[6] = .315392 * (3 * r * r - 1),
            e[7] = 1.092548 * n * r,
            e[8] = .546274 * (n * n - i * i)
        }
    }),
    Th.prototype = Object.assign(Object.create(Qc.prototype), {
        constructor: Th,
        isLightProbe: !0,
        copy: function(t) {
            return Qc.prototype.copy.call(this, t),
            this.sh.copy(t.sh),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            return Qc.prototype.toJSON.call(this, t)
        }
    }),
    Lh.prototype = Object.assign(Object.create(Th.prototype), {
        constructor: Lh,
        isHemisphereLightProbe: !0,
        copy: function(t) {
            return Th.prototype.copy.call(this, t),
            this
        },
        toJSON: function(t) {
            return Th.prototype.toJSON.call(this, t)
        }
    }),
    Dh.prototype = Object.assign(Object.create(Th.prototype), {
        constructor: Dh,
        isAmbientLightProbe: !0,
        copy: function(t) {
            return Th.prototype.copy.call(this, t),
            this
        },
        toJSON: function(t) {
            return Th.prototype.toJSON.call(this, t)
        }
    });
    var Ih = new Ze
      , Oh = new Ze;
    function jh(t) {
        this.autoStart = void 0 === t || t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    Object.assign(function() {
        this.type = 'StereoCamera',
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new dr,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new dr,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    .prototype, {
        update: function(t) {
            var e = this._cache;
            if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                e.focus = t.focus,
                e.fov = t.fov,
                e.aspect = t.aspect * this.aspect,
                e.near = t.near,
                e.far = t.far,
                e.zoom = t.zoom,
                e.eyeSep = this.eyeSep;
                var n, i, r = t.projectionMatrix.clone(), o = e.eyeSep / 2, a = o * e.near / e.focus, s = e.near * Math.tan(Ee.DEG2RAD * e.fov * .5) / e.zoom;
                Oh.elements[12] = -o,
                Ih.elements[12] = o,
                n = -s * e.aspect + a,
                i = s * e.aspect + a,
                r.elements[0] = 2 * e.near / (i - n),
                r.elements[8] = (i + n) / (i - n),
                this.cameraL.projectionMatrix.copy(r),
                n = -s * e.aspect - a,
                i = s * e.aspect - a,
                r.elements[0] = 2 * e.near / (i - n),
                r.elements[8] = (i + n) / (i - n),
                this.cameraR.projectionMatrix.copy(r)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Oh),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ih)
        }
    }),
    Object.assign(jh.prototype, {
        start: function() {
            this.startTime = ('undefined' == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var e = ('undefined' == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    });
    var Nh = new Oe
      , kh = new Le
      , Fh = new Oe
      , zh = new Oe;
    function Rh() {
        mn.call(this),
        this.type = 'AudioListener',
        this.context = Ch.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new jh
    }
    function Uh(t) {
        mn.call(this),
        this.type = 'Audio',
        this.listener = t,
        this.context = t.context,
        this.gain = this.context.createGain(),
        this.gain.connect(t.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = 'empty',
        this._startedAt = 0,
        this._pausedAt = 0,
        this.filters = []
    }
    Rh.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Rh,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function(t) {
            mn.prototype.updateMatrixWorld.call(this, t);
            var e = this.context.listener
              , n = this.up;
            if (this.timeDelta = this._clock.getDelta(),
            this.matrixWorld.decompose(Nh, kh, Fh),
            zh.set(0, 0, -1).applyQuaternion(kh),
            e.positionX) {
                var i = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(Nh.x, i),
                e.positionY.linearRampToValueAtTime(Nh.y, i),
                e.positionZ.linearRampToValueAtTime(Nh.z, i),
                e.forwardX.linearRampToValueAtTime(zh.x, i),
                e.forwardY.linearRampToValueAtTime(zh.y, i),
                e.forwardZ.linearRampToValueAtTime(zh.z, i),
                e.upX.linearRampToValueAtTime(n.x, i),
                e.upY.linearRampToValueAtTime(n.y, i),
                e.upZ.linearRampToValueAtTime(n.z, i)
            } else
                e.setPosition(Nh.x, Nh.y, Nh.z),
                e.setOrientation(zh.x, zh.y, zh.z, n.x, n.y, n.z)
        }
    }),
    Uh.prototype = Object.assign(Object.create(mn.prototype), {
        constructor: Uh,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = 'audioNode',
            this.source = t,
            this.connect(),
            this
        },
        setMediaElementSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = 'mediaNode',
            this.source = this.context.createMediaElementSource(t),
            this.connect(),
            this
        },
        setMediaStreamSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = 'mediaStreamNode',
            this.source = this.context.createMediaStreamSource(t),
            this.connect(),
            this
        },
        setBuffer: function(t) {
            return this.buffer = t,
            this.sourceType = 'buffer',
            this.autoplay && this.play(),
            this
        },
        play: function(t) {
            if (void 0 === t && (t = 0),
            !0 !== this.isPlaying && !1 !== this.hasPlaybackControl) {
                this._startedAt = this.context.currentTime + t;
                var e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                e.loop = this.loop,
                e.loopStart = this.loopStart,
                e.loopEnd = this.loopEnd,
                e.onended = this.onEnded.bind(this),
                e.start(this._startedAt, this._pausedAt + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = e,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this._pausedAt = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = t,
            this.connect()) : this.filters = t,
            this
        },
        setDetune: function(t) {
            if (this.detune = t,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 !== this.hasPlaybackControl && this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
        },
        setLoopStart: function(t) {
            return this.loopStart = t,
            this
        },
        setLoopEnd: function(t) {
            return this.loopEnd = t,
            this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    });
    var Bh = new Oe
      , Vh = new Le
      , Gh = new Oe
      , Hh = new Oe;
    function Wh(t) {
        Uh.call(this, t),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = 'HRTF',
        this.panner.connect(this.gain)
    }
    function Xh(t, e) {
        this.analyser = t.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== e ? e : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        t.getOutput().connect(this.analyser)
    }
    function qh(t, e, n) {
        this.binding = t,
        this.valueSize = n;
        var i, r = Float64Array;
        switch (e) {
        case 'quaternion':
            i = this._slerp;
            break;
        case 'string':
        case 'bool':
            r = Array,
            i = this._select;
            break;
        default:
            i = this._lerp
        }
        this.buffer = new r(4 * n),
        this._mixBufferRegion = i,
        this.cumulativeWeight = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    Wh.prototype = Object.assign(Object.create(Uh.prototype), {
        constructor: Wh,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            return this.panner.refDistance = t,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            return this.panner.rolloffFactor = t,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            return this.panner.distanceModel = t,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            return this.panner.maxDistance = t,
            this
        },
        setDirectionalCone: function(t, e, n) {
            return this.panner.coneInnerAngle = t,
            this.panner.coneOuterAngle = e,
            this.panner.coneOuterGain = n,
            this
        },
        updateMatrixWorld: function(t) {
            if (mn.prototype.updateMatrixWorld.call(this, t),
            !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(Bh, Vh, Gh),
                Hh.set(0, 0, 1).applyQuaternion(Vh);
                var e = this.panner;
                if (e.positionX) {
                    var n = this.context.currentTime + this.listener.timeDelta;
                    e.positionX.linearRampToValueAtTime(Bh.x, n),
                    e.positionY.linearRampToValueAtTime(Bh.y, n),
                    e.positionZ.linearRampToValueAtTime(Bh.z, n),
                    e.orientationX.linearRampToValueAtTime(Hh.x, n),
                    e.orientationY.linearRampToValueAtTime(Hh.y, n),
                    e.orientationZ.linearRampToValueAtTime(Hh.z, n)
                } else
                    e.setPosition(Bh.x, Bh.y, Bh.z),
                    e.setOrientation(Hh.x, Hh.y, Hh.z)
            }
        }
    }),
    Object.assign(Xh.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
                t += e[n];
            return t / e.length
        }
    }),
    Object.assign(qh.prototype, {
        accumulate: function(t, e) {
            var n = this.buffer
              , i = this.valueSize
              , r = t * i + i
              , o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== i; ++a)
                    n[r + a] = n[a];
                o = e
            } else {
                var s = e / (o += e);
                this._mixBufferRegion(n, r, 0, s, i)
            }
            this.cumulativeWeight = o
        },
        apply: function(t) {
            var e = this.valueSize
              , n = this.buffer
              , i = t * e + e
              , r = this.cumulativeWeight
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            r < 1) {
                var a = 3 * e;
                this._mixBufferRegion(n, i, a, 1 - r, e)
            }
            for (var s = e, l = e + e; s !== l; ++s)
                if (n[s] !== n[s + e]) {
                    o.setValue(n, i);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.binding
              , e = this.buffer
              , n = this.valueSize
              , i = 3 * n;
            t.getValue(e, i);
            for (var r = n, o = i; r !== o; ++r)
                e[r] = e[i + r % n];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _select: function(t, e, n, i, r) {
            if (i >= .5)
                for (var o = 0; o !== r; ++o)
                    t[e + o] = t[n + o]
        },
        _slerp: function(t, e, n, i) {
            Le.slerpFlat(t, e, t, e, t, n, i)
        },
        _lerp: function(t, e, n, i, r) {
            for (var o = 1 - i, a = 0; a !== r; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * i
            }
        }
    });
    var Yh = new RegExp('[\\[\\]\\.:\\/]','g')
      , Jh = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']'
      , Zh = /((?:WC+[\/:])*)/.source.replace('WC', '[^\\[\\]\\.:\\/]')
      , Kh = /(WCOD+)?/.source.replace('WCOD', Jh)
      , Qh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', '[^\\[\\]\\.:\\/]')
      , $h = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', '[^\\[\\]\\.:\\/]')
      , tu = new RegExp('^' + Zh + Kh + Qh + $h + '$')
      , eu = ['material', 'materials', 'bones'];
    function nu(t, e, n) {
        var i = n || iu.parseTrackName(e);
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, i)
    }
    function iu(t, e, n) {
        this.path = e,
        this.parsedPath = n || iu.parseTrackName(e),
        this.node = iu.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t
    }
    function ru(t, e, n) {
        this._mixer = t,
        this._clip = e,
        this._localRoot = n || null;
        for (var i = e.tracks, r = i.length, o = new Array(r), a = {
            endingStart: ae,
            endingEnd: ae
        }, s = 0; s !== r; ++s) {
            var l = i[s].createInterpolant(null);
            o[s] = l,
            l.settings = a
        }
        this._interpolantSettings = a,
        this._interpolants = o,
        this._propertyBindings = new Array(r),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = oe,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function ou(t) {
        this._root = t,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function au(t) {
        'string' == typeof t && (t = arguments[1]),
        this.value = t
    }
    function su(t, e, n) {
        ja.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function lu(t, e) {
        return t.distance - e.distance
    }
    function cu(t, e, n, i) {
        if (!1 !== t.visible && (t.raycast(e, n),
        !0 === i))
            for (var r = t.children, o = 0, a = r.length; o < a; o++)
                cu(r[o], e, n, !0)
    }
    Object.assign(nu.prototype, {
        getValue: function(t, e) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_
              , i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        },
        setValue: function(t, e) {
            for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                n[i].setValue(t, e)
        },
        bind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].bind()
        },
        unbind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].unbind()
        }
    }),
    Object.assign(iu, {
        Composite: nu,
        create: function(t, e, n) {
            return t && t.isAnimationObjectGroup ? new iu.Composite(t,e,n) : new iu(t,e,n)
        },
        sanitizeNodeName: function(t) {
            return t.replace(/\s/g, '_').replace(Yh, '')
        },
        parseTrackName: function(t) {
            var e = tu.exec(t);
            if (!e)
                throw new Error('PropertyBinding: Cannot parse trackName: ' + t);
            var n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }
              , i = n.nodeName && n.nodeName.lastIndexOf('.');
            if (void 0 !== i && -1 !== i) {
                var r = n.nodeName.substring(i + 1);
                -1 !== eu.indexOf(r) && (n.nodeName = n.nodeName.substring(0, i),
                n.objectName = r)
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + t);
            return n
        },
        findNode: function(t, e) {
            if (!e || '' === e || 'root' === e || '.' === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                var n = t.skeleton.getBoneByName(e);
                if (void 0 !== n)
                    return n
            }
            if (t.children) {
                var i = function(t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        if (r.name === e || r.uuid === e)
                            return r;
                        var o = i(r.children);
                        if (o)
                            return o
                    }
                    return null
                }
                  , r = i(t.children);
                if (r)
                    return r
            }
            return null
        }
    }),
    Object.assign(iu.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                t[e++] = n[i]
        }
        , function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        , function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(t, e) {
            this.bind(),
            this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(),
            this.setValue(t, e)
        },
        bind: function() {
            var t = this.node
              , e = this.parsedPath
              , n = e.objectName
              , i = e.propertyName
              , r = e.propertyIndex;
            if (t || (t = iu.findNode(this.rootNode, e.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            t) {
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                    case 'materials':
                        if (!t.material)
                            return;
                        if (!t.material.materials)
                            return;
                        t = t.material.materials;
                        break;
                    case 'bones':
                        if (!t.skeleton)
                            return;
                        t = t.skeleton.bones;
                        for (var a = 0; a < t.length; a++)
                            if (t[a].name === o) {
                                o = a;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return;
                        t = t[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o])
                            return;
                        t = t[o]
                    }
                }
                var s = t[i];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    this.targetObject = t,
                    void 0 !== t.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ('morphTargetInfluences' === i) {
                            if (!t.geometry)
                                return;
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes)
                                    return;
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (t.geometry.morphAttributes.position[a].name === r) {
                                        r = a;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets)
                                    return;
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (t.geometry.morphTargets[a].name === r) {
                                        r = a;
                                        break
                                    }
                            }
                        }
                        c = this.BindingType.ArrayElement,
                        this.resolvedProperty = s,
                        this.propertyIndex = r
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray,
                        this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray,
                        this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[c],
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                } else
                    e.nodeName
            }
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(iu.prototype, {
        _getValue_unbound: iu.prototype.getValue,
        _setValue_unbound: iu.prototype.setValue
    }),
    Object.assign(function() {
        this.uuid = Ee.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {
                get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }
    .prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = 0, c = arguments.length; l !== c; ++l) {
                var h = arguments[l]
                  , u = h.uuid
                  , p = i[u];
                if (void 0 === p) {
                    p = e++,
                    i[u] = p,
                    t.push(h);
                    for (var d = 0, f = s; d !== f; ++d)
                        a[d].push(new iu(h,r[d],o[d]))
                } else if (p < n) {
                    t[p];
                    var m = --n
                      , g = t[m];
                    i[g.uuid] = p,
                    t[p] = g,
                    i[u] = m,
                    t[m] = h;
                    for (d = 0,
                    f = s; d !== f; ++d) {
                        var v = a[d]
                          , y = v[m]
                          , x = v[p];
                        v[p] = y,
                        void 0 === x && (x = new iu(h,r[d],o[d])),
                        v[m] = x
                    }
                } else
                    t[p]
            }
            this.nCachedObjects_ = n
        },
        remove: function() {
            for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o]
                  , l = s.uuid
                  , c = n[l];
                if (void 0 !== c && c >= e) {
                    var h = e++
                      , u = t[h];
                    n[u.uuid] = c,
                    t[c] = u,
                    n[l] = h,
                    t[h] = s;
                    for (var p = 0, d = r; p !== d; ++p) {
                        var f = i[p]
                          , m = f[h]
                          , g = f[c];
                        f[c] = m,
                        f[h] = g
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var l = arguments[a]
                  , c = l.uuid
                  , h = i[c];
                if (void 0 !== h)
                    if (delete i[c],
                    h < n) {
                        var u = --n
                          , p = t[u]
                          , d = t[y = --e];
                        i[p.uuid] = h,
                        t[h] = p,
                        i[d.uuid] = u,
                        t[u] = d,
                        t.pop();
                        for (var f = 0, m = o; f !== m; ++f) {
                            var g = (x = r[f])[u]
                              , v = x[y];
                            x[h] = g,
                            x[u] = v,
                            x.pop()
                        }
                    } else {
                        var y;
                        i[(d = t[y = --e]).uuid] = h,
                        t[h] = d,
                        t.pop();
                        for (f = 0,
                        m = o; f !== m; ++f) {
                            var x;
                            (x = r[f])[h] = x[y],
                            x.pop()
                        }
                    }
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function(t, e) {
            var n = this._bindingsIndicesByPath
              , i = n[t]
              , r = this._bindings;
            if (void 0 !== i)
                return r[i];
            var o = this._paths
              , a = this._parsedPaths
              , s = this._objects
              , l = s.length
              , c = this.nCachedObjects_
              , h = new Array(l);
            i = r.length,
            n[t] = i,
            o.push(t),
            a.push(e),
            r.push(h);
            for (var u = c, p = s.length; u !== p; ++u) {
                var d = s[u];
                h[u] = new iu(d,t,e)
            }
            return h
        },
        unsubscribe_: function(t) {
            var e = this._bindingsIndicesByPath
              , n = e[t];
            if (void 0 !== n) {
                var i = this._paths
                  , r = this._parsedPaths
                  , o = this._bindings
                  , a = o.length - 1
                  , s = o[a];
                e[t[a]] = n,
                o[n] = s,
                o.pop(),
                r[n] = r[a],
                r.pop(),
                i[n] = i[a],
                i.pop()
            }
        }
    }),
    Object.assign(ru.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t,
            this
        },
        setLoop: function(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, n) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            n) {
                var i = this._clip.duration
                  , r = t._clip.duration
                  , o = r / i
                  , a = i / r;
                t.warp(1, o, e),
                this.warp(a, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, n) {
            var i = this._mixer
              , r = i.time
              , o = this._timeScaleInterpolant
              , a = this.timeScale;
            null === o && (o = i._lendControlInterpolant(),
            this._timeScaleInterpolant = o);
            var s = o.parameterPositions
              , l = o.sampleValues;
            return s[0] = r,
            s[1] = r + n,
            l[0] = t / a,
            l[1] = e / a,
            this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, n, i) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var o = (t - r) * n;
                    if (o < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    e = n * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e)
                  , s = this._updateWeight(t);
                if (s > 0)
                    for (var l = this._interpolants, c = this._propertyBindings, h = 0, u = l.length; h !== u; ++h)
                        l[h].evaluate(a),
                        c[h].accumulate(i, s)
            } else
                this._updateWeight(t)
        },
        _updateWeight: function(t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var i = n.evaluate(t)[0];
                    e *= i,
                    t > n.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e,
            e
        },
        _updateTimeScale: function(t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var n = this._timeScaleInterpolant;
                if (null !== n)
                    e *= n.evaluate(t)[0],
                    t > n.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e)
            }
            return this._effectiveTimeScale = e,
            e
        },
        _updateTime: function(t) {
            var e = this.time + t
              , n = this._clip.duration
              , i = this.loop
              , r = this._loopCount
              , o = 2202 === i;
            if (0 === t)
                return -1 === r ? e : o && 1 == (1 & r) ? n - e : e;
            if (2200 === i) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                t: {
                    if (e >= n)
                        e = n;
                    else {
                        if (!(e < 0)) {
                            this.time = e;
                            break t
                        }
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = e,
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                e >= n || e < 0) {
                    var a = Math.floor(e / n);
                    e -= n * a,
                    r += Math.abs(a);
                    var s = this.repetitions - r;
                    if (s <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        e = t > 0 ? n : 0,
                        this.time = e,
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                    else {
                        if (1 === s) {
                            var l = t < 0;
                            this._setEndings(l, !l, o)
                        } else
                            this._setEndings(!1, !1, o);
                        this._loopCount = r,
                        this.time = e,
                        this._mixer.dispatchEvent({
                            type: 'loop',
                            action: this,
                            loopDelta: a
                        })
                    }
                } else
                    this.time = e;
                if (o && 1 == (1 & r))
                    return n - e
            }
            return e
        },
        _setEndings: function(t, e, n) {
            var i = this._interpolantSettings;
            n ? (i.endingStart = 2401,
            i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : ae : 2402,
            i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : ae : 2402)
        },
        _scheduleFading: function(t, e, n) {
            var i = this._mixer
              , r = i.time
              , o = this._weightInterpolant;
            null === o && (o = i._lendControlInterpolant(),
            this._weightInterpolant = o);
            var a = o.parameterPositions
              , s = o.sampleValues;
            return a[0] = r,
            s[0] = e,
            a[1] = r + t,
            s[1] = n,
            this
        }
    }),
    ou.prototype = Object.assign(Object.create(Pe.prototype), {
        constructor: ou,
        _bindAction: function(t, e) {
            var n = t._localRoot || this._root
              , i = t._clip.tracks
              , r = i.length
              , o = t._propertyBindings
              , a = t._interpolants
              , s = n.uuid
              , l = this._bindingsByRootAndName
              , c = l[s];
            void 0 === c && (c = {},
            l[s] = c);
            for (var h = 0; h !== r; ++h) {
                var u = i[h]
                  , p = u.name
                  , d = c[p];
                if (void 0 !== d)
                    o[h] = d;
                else {
                    if (void 0 !== (d = o[h])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = e && e._propertyBindings[h].binding.parsedPath;
                    ++(d = new qh(iu.create(n, p, f),u.ValueTypeName,u.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, s, p),
                    o[h] = d
                }
                a[h].resultBuffer = d.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid
                      , n = t._clip.uuid
                      , i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]),
                    this._addInactiveAction(t, n, e)
                }
                for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                    var s = r[o];
                    0 == s.useCount++ && (this._lendBinding(s),
                    s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                    var r = e[n];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            var i = this._actions
              , r = this._actionsByClip
              , o = r[e];
            if (void 0 === o)
                o = {
                    knownActions: [t],
                    actionByRoot: {}
                },
                t._byClipCacheIndex = 0,
                r[e] = o;
            else {
                var a = o.knownActions;
                t._byClipCacheIndex = a.length,
                a.push(t)
            }
            t._cacheIndex = i.length,
            i.push(t),
            o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions
              , n = e[e.length - 1]
              , i = t._cacheIndex;
            n._cacheIndex = i,
            e[i] = n,
            e.pop(),
            t._cacheIndex = null;
            var r = t._clip.uuid
              , o = this._actionsByClip
              , a = o[r]
              , s = a.knownActions
              , l = s[s.length - 1]
              , c = t._byClipCacheIndex;
            l._byClipCacheIndex = c,
            s[c] = l,
            s.pop(),
            t._byClipCacheIndex = null,
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete o[r],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                var r = e[n];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , i = this._nActiveActions++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , i = --this._nActiveActions
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _addInactiveBinding: function(t, e, n) {
            var i = this._bindingsByRootAndName
              , r = i[e]
              , o = this._bindings;
            void 0 === r && (r = {},
            i[e] = r),
            r[n] = t,
            t._cacheIndex = o.length,
            o.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings
              , n = t.binding
              , i = n.rootNode.uuid
              , r = n.path
              , o = this._bindingsByRootAndName
              , a = o[i]
              , s = e[e.length - 1]
              , l = t._cacheIndex;
            s._cacheIndex = l,
            e[l] = s,
            e.pop(),
            delete a[r],
            0 === Object.keys(a).length && delete o[i]
        },
        _lendBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , i = this._nActiveBindings++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , i = --this._nActiveBindings
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++
              , n = t[e];
            return void 0 === n && ((n = new oc(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = e,
            t[e] = n),
            n
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants
              , n = t.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , r = e[i];
            t.__cacheIndex = i,
            e[i] = t,
            r.__cacheIndex = n,
            e[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var n = e || this._root
              , i = n.uuid
              , r = 'string' == typeof t ? mc.findByName(n, t) : t
              , o = null !== r ? r.uuid : t
              , a = this._actionsByClip[o]
              , s = null;
            if (void 0 !== a) {
                var l = a.actionByRoot[i];
                if (void 0 !== l)
                    return l;
                s = a.knownActions[0],
                null === r && (r = s._clip)
            }
            if (null === r)
                return null;
            var c = new ru(this,r,e);
            return this._bindAction(c, s),
            this._addInactiveAction(c, o, i),
            c
        },
        existingAction: function(t, e) {
            var n = e || this._root
              , i = n.uuid
              , r = 'string' == typeof t ? mc.findByName(n, t) : t
              , o = r ? r.uuid : t
              , a = this._actionsByClip[o];
            return void 0 !== a && a.actionByRoot[i] || null
        },
        stopAllAction: function() {
            var t = this._actions
              , e = this._nActiveActions
              , n = this._bindings
              , i = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var r = 0; r !== e; ++r)
                t[r].reset();
            for (r = 0; r !== i; ++r)
                n[r].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                e[a]._update(i, t, r, o)
            }
            var s = this._bindings
              , l = this._nActiveBindings;
            for (a = 0; a !== l; ++a)
                s[a].apply(o);
            return this
        },
        setTime: function(t) {
            this.time = 0;
            for (var e = 0; e < this._actions.length; e++)
                this._actions[e].time = 0;
            return this.update(t)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions
              , n = t.uuid
              , i = this._actionsByClip
              , r = i[n];
            if (void 0 !== r) {
                for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                    var l = o[a];
                    this._deactivateAction(l);
                    var c = l._cacheIndex
                      , h = e[e.length - 1];
                    l._cacheIndex = null,
                    l._byClipCacheIndex = null,
                    h._cacheIndex = c,
                    e[c] = h,
                    e.pop(),
                    this._removeInactiveBindingsForAction(l)
                }
                delete i[n]
            }
        },
        uncacheRoot: function(t) {
            var e = t.uuid
              , n = this._actionsByClip;
            for (var i in n) {
                var r = n[i].actionByRoot[e];
                void 0 !== r && (this._deactivateAction(r),
                this._removeInactiveAction(r))
            }
            var o = this._bindingsByRootAndName[e];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(),
                    this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(t, e) {
            var n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n),
            this._removeInactiveAction(n))
        }
    }),
    au.prototype.clone = function() {
        return new au(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    su.prototype = Object.assign(Object.create(ja.prototype), {
        constructor: su,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return ja.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    Object.assign(function(t, e, n, i) {
        this.ray = new Bn(t,e),
        this.near = n || 0,
        this.far = i || 1 / 0,
        this.camera = null,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return this.Points
                }
            }
        })
    }
    .prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
            this.camera = e) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
            this.camera = e)
        },
        intersectObject: function(t, e, n) {
            var i = n || [];
            return cu(t, this, i, e),
            i.sort(lu),
            i
        },
        intersectObjects: function(t, e, n) {
            var i = n || [];
            if (!1 === Array.isArray(t))
                return i;
            for (var r = 0, o = t.length; r < o; r++)
                cu(t[r], this, i, e);
            return i.sort(lu),
            i
        }
    }),
    Object.assign(function(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.phi = void 0 !== e ? e : 0,
        this.theta = void 0 !== n ? n : 0,
        this
    }
    .prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, n) {
            return this.radius = Math.sqrt(t * t + e * e + n * n),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(t, n),
            this.phi = Math.acos(Ee.clamp(e / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(function(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.theta = void 0 !== e ? e : 0,
        this.y = void 0 !== n ? n : 0,
        this
    }
    .prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.theta = e,
            this.y = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.theta = t.theta,
            this.y = t.y,
            this
        },
        setFromVector3: function(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        },
        setFromCartesianCoords: function(t, e, n) {
            return this.radius = Math.sqrt(t * t + n * n),
            this.theta = Math.atan2(t, n),
            this.y = e,
            this
        }
    });
    var hu = new Te;
    function uu(t, e) {
        this.min = void 0 !== t ? t : new Te(1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new Te(-1 / 0,-1 / 0)
    }
    Object.assign(uu.prototype, {
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function(t, e) {
            var n = hu.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            return void 0 === t && (t = new Te),
            this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (t = new Te),
            this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return void 0 === e && (e = new Te),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return void 0 === e && (e = new Te),
            e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function(t) {
            return hu.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    var pu = new Oe
      , du = new Oe;
    function fu(t, e) {
        this.start = void 0 !== t ? t : new Oe,
        this.end = void 0 !== e ? e : new Oe
    }
    function mu(t) {
        mn.call(this),
        this.material = t,
        this.render = function() {}
    }
    Object.assign(fu.prototype, {
        set: function(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        },
        getCenter: function(t) {
            return void 0 === t && (t = new Oe),
            t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return void 0 === t && (t = new Oe),
            t.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            return void 0 === e && (e = new Oe),
            this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function(t, e) {
            pu.subVectors(t, this.start),
            du.subVectors(this.end, this.start);
            var n = du.dot(du)
              , i = du.dot(pu) / n;
            return e && (i = Ee.clamp(i, 0, 1)),
            i
        },
        closestPointToPoint: function(t, e, n) {
            var i = this.closestPointToPointParameter(t, e);
            return void 0 === n && (n = new Oe),
            this.delta(n).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }),
    mu.prototype = Object.create(mn.prototype),
    mu.prototype.constructor = mu,
    mu.prototype.isImmediateRenderObject = !0;
    var gu = new Oe
      , vu = new Oe
      , yu = new ke
      , xu = ['a', 'b', 'c'];
    function bu(t, e, n, i) {
        this.object = t,
        this.size = void 0 !== e ? e : 1;
        var r = void 0 !== n ? n : 16711680
          , o = void 0 !== i ? i : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var l = new Oi
          , c = new Mi(2 * a * 3,3);
        l.setAttribute('position', c),
        xs.call(this, l, new hs({
            color: r,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    bu.prototype = Object.create(xs.prototype),
    bu.prototype.constructor = bu,
    bu.prototype.update = function() {
        this.object.updateMatrixWorld(!0),
        yu.getNormalMatrix(this.object.matrixWorld);
        var t = this.object.matrixWorld
          , e = this.geometry.attributes.position
          , n = this.object.geometry;
        if (n && n.isGeometry)
            for (var i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++)
                for (var l = r[a], c = 0, h = l.vertexNormals.length; c < h; c++) {
                    var u = i[l[xu[c]]]
                      , p = l.vertexNormals[c];
                    gu.copy(u).applyMatrix4(t),
                    vu.copy(p).applyMatrix3(yu).normalize().multiplyScalar(this.size).add(gu),
                    e.setXYZ(o, gu.x, gu.y, gu.z),
                    o += 1,
                    e.setXYZ(o, vu.x, vu.y, vu.z),
                    o += 1
                }
        else if (n && n.isBufferGeometry) {
            var d = n.attributes.position
              , f = n.attributes.normal;
            for (o = 0,
            c = 0,
            h = d.count; c < h; c++)
                gu.set(d.getX(c), d.getY(c), d.getZ(c)).applyMatrix4(t),
                vu.set(f.getX(c), f.getY(c), f.getZ(c)),
                vu.applyMatrix3(yu).normalize().multiplyScalar(this.size).add(gu),
                e.setXYZ(o, gu.x, gu.y, gu.z),
                o += 1,
                e.setXYZ(o, vu.x, vu.y, vu.z),
                o += 1
        }
        e.needsUpdate = !0
    }
    ;
    var _u = new Oe;
    function Mu(t, e) {
        mn.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e;
        for (var n = new Oi, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++,
        o++) {
            var a = r / 32 * Math.PI * 2
              , s = o / 32 * Math.PI * 2;
            i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.setAttribute('position', new Mi(i,3));
        var l = new hs({
            fog: !1
        });
        this.cone = new xs(n,l),
        this.add(this.cone),
        this.update()
    }
    Mu.prototype = Object.create(mn.prototype),
    Mu.prototype.constructor = Mu,
    Mu.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    Mu.prototype.update = function() {
        this.light.updateMatrixWorld();
        var t = this.light.distance ? this.light.distance : 1e3
          , e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
        _u.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(_u),
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
    ;
    var wu = new Oe
      , Su = new Ze
      , Pu = new Ze;
    function Cu(t) {
        for (var e = function t(e) {
            var n = [];
            e && e.isBone && n.push(e);
            for (var i = 0; i < e.children.length; i++)
                n.push.apply(n, t(e.children[i]));
            return n
        }(t), n = new Oi, i = [], r = [], o = new ai(0,0,1), a = new ai(0,1,0), s = 0; s < e.length; s++) {
            var l = e[s];
            l.parent && l.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            r.push(o.r, o.g, o.b),
            r.push(a.r, a.g, a.b))
        }
        n.setAttribute('position', new Mi(i,3)),
        n.setAttribute('color', new Mi(r,3));
        var c = new hs({
            vertexColors: f,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        xs.call(this, n, c),
        this.root = t,
        this.bones = e,
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function Au(t, e, n) {
        this.light = t,
        this.light.updateMatrixWorld(),
        this.color = n;
        var i = new Tl(e,4,2)
          , r = new di({
            wireframe: !0,
            fog: !1
        });
        Ki.call(this, i, r),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Eu(t, e) {
        this.type = 'RectAreaLightHelper',
        this.light = t,
        this.color = e;
        var n = new Oi;
        n.setAttribute('position', new Mi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        n.computeBoundingSphere();
        var i = new hs({
            fog: !1
        });
        gs.call(this, n, i);
        var r = new Oi;
        r.setAttribute('position', new Mi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        r.computeBoundingSphere(),
        this.add(new Ki(r,new di({
            side: h,
            fog: !1
        }))),
        this.update()
    }
    Cu.prototype = Object.create(xs.prototype),
    Cu.prototype.constructor = Cu,
    Cu.prototype.updateMatrixWorld = function(t) {
        var e = this.bones
          , n = this.geometry
          , i = n.getAttribute('position');
        Pu.getInverse(this.root.matrixWorld);
        for (var r = 0, o = 0; r < e.length; r++) {
            var a = e[r];
            a.parent && a.parent.isBone && (Su.multiplyMatrices(Pu, a.matrixWorld),
            wu.setFromMatrixPosition(Su),
            i.setXYZ(o, wu.x, wu.y, wu.z),
            Su.multiplyMatrices(Pu, a.parent.matrixWorld),
            wu.setFromMatrixPosition(Su),
            i.setXYZ(o + 1, wu.x, wu.y, wu.z),
            o += 2)
        }
        n.getAttribute('position').needsUpdate = !0,
        mn.prototype.updateMatrixWorld.call(this, t)
    }
    ,
    Au.prototype = Object.create(Ki.prototype),
    Au.prototype.constructor = Au,
    Au.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Au.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    Eu.prototype = Object.create(gs.prototype),
    Eu.prototype.constructor = Eu,
    Eu.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color)
            this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var t = this.material.color
              , e = Math.max(t.r, t.g, t.b);
            e > 1 && t.multiplyScalar(1 / e),
            this.children[0].material.color.copy(this.material.color)
        }
    }
    ,
    Eu.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ;
    var Tu = new Oe
      , Lu = new ai
      , Du = new ai;
    function Iu(t, e, n) {
        mn.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n;
        var i = new Us(e);
        i.rotateY(.5 * Math.PI),
        this.material = new di({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = f);
        var r = i.getAttribute('position')
          , o = new Float32Array(3 * r.count);
        i.setAttribute('color', new fi(o,3)),
        this.add(new Ki(i,this.material)),
        this.update()
    }
    function Ou(t, e) {
        this.lightProbe = t,
        this.size = e;
        var n = {
            GAMMA_OUTPUT: ''
        }
          , i = new ur({
            defines: n,
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
            fragmentShader: ['#define RECIPROCAL_PI 0.318309886', 'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {', '\t// matrix is assumed to be orthogonal', '\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );', '}', 'vec3 linearToOutput( in vec3 a ) {', '\t#ifdef GAMMA_OUTPUT', '\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );', '\t#else', '\t\treturn a;', '\t#endif', '}', '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf', 'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {', '\t// normal is assumed to have unit length', '\tfloat x = normal.x, y = normal.y, z = normal.z;', '\t// band 0', '\tvec3 result = shCoefficients[ 0 ] * 0.886227;', '\t// band 1', '\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;', '\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;', '\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;', '\t// band 2', '\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;', '\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;', '\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );', '\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;', '\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );', '\treturn result;', '}', 'uniform vec3 sh[ 9 ]; // sh coefficients', 'uniform float intensity; // light probe intensity', 'varying vec3 vNormal;', 'void main() {', '\tvec3 normal = normalize( vNormal );', '\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', '\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );', '\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;', '\toutgoingLight = linearToOutput( outgoingLight );', '\tgl_FragColor = vec4( outgoingLight, 1.0 );', '}'].join('\n')
        })
          , r = new Tl(1,32,16);
        Ki.call(this, r, i),
        this.onBeforeRender()
    }
    function ju(t, e, n, i) {
        t = t || 10,
        e = e || 10,
        n = new ai(void 0 !== n ? n : 4473924),
        i = new ai(void 0 !== i ? i : 8947848);
        for (var r = e / 2, o = t / e, a = t / 2, s = [], l = [], c = 0, h = 0, u = -a; c <= e; c++,
        u += o) {
            s.push(-a, 0, u, a, 0, u),
            s.push(u, 0, -a, u, 0, a);
            var p = c === r ? n : i;
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3
        }
        var d = new Oi;
        d.setAttribute('position', new Mi(s,3)),
        d.setAttribute('color', new Mi(l,3));
        var m = new hs({
            vertexColors: f
        });
        xs.call(this, d, m)
    }
    function Nu(t, e, n, i, r, o) {
        t = t || 10,
        e = e || 16,
        n = n || 8,
        i = i || 64,
        r = new ai(void 0 !== r ? r : 4473924),
        o = new ai(void 0 !== o ? o : 8947848);
        var a, s, l, c, h, u, p, d = [], m = [];
        for (c = 0; c <= e; c++)
            l = c / e * (2 * Math.PI),
            a = Math.sin(l) * t,
            s = Math.cos(l) * t,
            d.push(0, 0, 0),
            d.push(a, 0, s),
            p = 1 & c ? r : o,
            m.push(p.r, p.g, p.b),
            m.push(p.r, p.g, p.b);
        for (c = 0; c <= n; c++)
            for (p = 1 & c ? r : o,
            u = t - t / n * c,
            h = 0; h < i; h++)
                l = h / i * (2 * Math.PI),
                a = Math.sin(l) * u,
                s = Math.cos(l) * u,
                d.push(a, 0, s),
                m.push(p.r, p.g, p.b),
                l = (h + 1) / i * (2 * Math.PI),
                a = Math.sin(l) * u,
                s = Math.cos(l) * u,
                d.push(a, 0, s),
                m.push(p.r, p.g, p.b);
        var g = new Oi;
        g.setAttribute('position', new Mi(d,3)),
        g.setAttribute('color', new Mi(m,3));
        var v = new hs({
            vertexColors: f
        });
        xs.call(this, g, v)
    }
    function ku(t, e, n, i) {
        this.audio = t,
        this.range = e || 1,
        this.divisionsInnerAngle = n || 16,
        this.divisionsOuterAngle = i || 2;
        var r = new Oi
          , o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle
          , a = new Float32Array(3 * (3 * o + 3));
        r.setAttribute('position', new fi(a,3));
        var s = new hs({
            color: 65280
        })
          , l = new hs({
            color: 16776960
        });
        gs.call(this, r, [l, s]),
        this.update()
    }
    Iu.prototype = Object.create(mn.prototype),
    Iu.prototype.constructor = Iu,
    Iu.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Iu.prototype.update = function() {
        var t = this.children[0];
        if (void 0 !== this.color)
            this.material.color.set(this.color);
        else {
            var e = t.geometry.getAttribute('color');
            Lu.copy(this.light.color),
            Du.copy(this.light.groundColor);
            for (var n = 0, i = e.count; n < i; n++) {
                var r = n < i / 2 ? Lu : Du;
                e.setXYZ(n, r.r, r.g, r.b)
            }
            e.needsUpdate = !0
        }
        t.lookAt(Tu.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
    ,
    Ou.prototype = Object.create(Ki.prototype),
    Ou.prototype.constructor = Ou,
    Ou.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Ou.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position),
        this.scale.set(1, 1, 1).multiplyScalar(this.size),
        this.material.uniforms.intensity.value = this.lightProbe.intensity
    }
    ,
    ju.prototype = Object.assign(Object.create(xs.prototype), {
        constructor: ju,
        copy: function(t) {
            return xs.prototype.copy.call(this, t),
            this.geometry.copy(t.geometry),
            this.material.copy(t.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Nu.prototype = Object.create(xs.prototype),
    Nu.prototype.constructor = Nu,
    ku.prototype = Object.create(gs.prototype),
    ku.prototype.constructor = ku,
    ku.prototype.update = function() {
        var t, e, n = this.audio, i = this.range, r = this.divisionsInnerAngle, o = this.divisionsOuterAngle, a = Ee.degToRad(n.panner.coneInnerAngle), s = Ee.degToRad(n.panner.coneOuterAngle), l = a / 2, c = s / 2, h = 0, u = 0, p = this.geometry, d = p.attributes.position;
        function f(n, r, o, a) {
            var s = (r - n) / o;
            for (d.setXYZ(h, 0, 0, 0),
            u++,
            t = n; t < r; t += s)
                e = h + u,
                d.setXYZ(e, Math.sin(t) * i, 0, Math.cos(t) * i),
                d.setXYZ(e + 1, Math.sin(Math.min(t + s, r)) * i, 0, Math.cos(Math.min(t + s, r)) * i),
                d.setXYZ(e + 2, 0, 0, 0),
                u += 3;
            p.addGroup(h, u, a),
            h += u,
            u = 0
        }
        p.clearGroups(),
        f(-c, -l, o, 0),
        f(-l, l, r, 1),
        f(l, c, o, 0),
        d.needsUpdate = !0,
        a === s && (this.material[0].visible = !1)
    }
    ,
    ku.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material[0].dispose(),
        this.material[1].dispose()
    }
    ;
    var Fu = new Oe
      , zu = new Oe
      , Ru = new ke;
    function Uu(t, e, n, i) {
        this.object = t,
        this.size = void 0 !== e ? e : 1;
        var r = void 0 !== n ? n : 16776960
          , o = void 0 !== i ? i : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry && (a = s.faces.length);
        var l = new Oi
          , c = new Mi(2 * a * 3,3);
        l.setAttribute('position', c),
        xs.call(this, l, new hs({
            color: r,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    Uu.prototype = Object.create(xs.prototype),
    Uu.prototype.constructor = Uu,
    Uu.prototype.update = function() {
        this.object.updateMatrixWorld(!0),
        Ru.getNormalMatrix(this.object.matrixWorld);
        for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++) {
            var l = r[a]
              , c = l.normal;
            Fu.copy(i[l.a]).add(i[l.b]).add(i[l.c]).divideScalar(3).applyMatrix4(t),
            zu.copy(c).applyMatrix3(Ru).normalize().multiplyScalar(this.size).add(Fu),
            e.setXYZ(o, Fu.x, Fu.y, Fu.z),
            o += 1,
            e.setXYZ(o, zu.x, zu.y, zu.z),
            o += 1
        }
        e.needsUpdate = !0
    }
    ;
    var Bu = new Oe
      , Vu = new Oe
      , Gu = new Oe;
    function Hu(t, e, n) {
        mn.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        void 0 === e && (e = 1);
        var i = new Oi;
        i.setAttribute('position', new Mi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3));
        var r = new hs({
            fog: !1
        });
        this.lightPlane = new gs(i,r),
        this.add(this.lightPlane),
        (i = new Oi).setAttribute('position', new Mi([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new gs(i,r),
        this.add(this.targetLine),
        this.update()
    }
    Hu.prototype = Object.create(mn.prototype),
    Hu.prototype.constructor = Hu,
    Hu.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    Hu.prototype.update = function() {
        Bu.setFromMatrixPosition(this.light.matrixWorld),
        Vu.setFromMatrixPosition(this.light.target.matrixWorld),
        Gu.subVectors(Vu, Bu),
        this.lightPlane.lookAt(Vu),
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Vu),
        this.targetLine.scale.z = Gu.length()
    }
    ;
    var Wu = new Oe
      , Xu = new pr;
    function qu(t) {
        var e = new Oi
          , n = new hs({
            color: 16777215,
            vertexColors: d
        })
          , i = []
          , r = []
          , o = {}
          , a = new ai(16755200)
          , s = new ai(16711680)
          , l = new ai(43775)
          , c = new ai(16777215)
          , h = new ai(3355443);
        function u(t, e, n) {
            p(t, n),
            p(e, n)
        }
        function p(t, e) {
            i.push(0, 0, 0),
            r.push(e.r, e.g, e.b),
            void 0 === o[t] && (o[t] = []),
            o[t].push(i.length / 3 - 1)
        }
        u('n1', 'n2', a),
        u('n2', 'n4', a),
        u('n4', 'n3', a),
        u('n3', 'n1', a),
        u('f1', 'f2', a),
        u('f2', 'f4', a),
        u('f4', 'f3', a),
        u('f3', 'f1', a),
        u('n1', 'f1', a),
        u('n2', 'f2', a),
        u('n3', 'f3', a),
        u('n4', 'f4', a),
        u('p', 'n1', s),
        u('p', 'n2', s),
        u('p', 'n3', s),
        u('p', 'n4', s),
        u('u1', 'u2', l),
        u('u2', 'u3', l),
        u('u3', 'u1', l),
        u('c', 't', c),
        u('p', 'c', h),
        u('cn1', 'cn2', h),
        u('cn3', 'cn4', h),
        u('cf1', 'cf2', h),
        u('cf3', 'cf4', h),
        e.setAttribute('position', new Mi(i,3)),
        e.setAttribute('color', new Mi(r,3)),
        xs.call(this, e, n),
        this.camera = t,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update()
    }
    function Yu(t, e, n, i, r, o, a) {
        Wu.set(r, o, a).unproject(i);
        var s = e[t];
        if (void 0 !== s)
            for (var l = n.getAttribute('position'), c = 0, h = s.length; c < h; c++)
                l.setXYZ(s[c], Wu.x, Wu.y, Wu.z)
    }
    qu.prototype = Object.create(xs.prototype),
    qu.prototype.constructor = qu,
    qu.prototype.update = function() {
        var t = this.geometry
          , e = this.pointMap;
        Xu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        Yu('c', e, t, Xu, 0, 0, -1),
        Yu('t', e, t, Xu, 0, 0, 1),
        Yu('n1', e, t, Xu, -1, -1, -1),
        Yu('n2', e, t, Xu, 1, -1, -1),
        Yu('n3', e, t, Xu, -1, 1, -1),
        Yu('n4', e, t, Xu, 1, 1, -1),
        Yu('f1', e, t, Xu, -1, -1, 1),
        Yu('f2', e, t, Xu, 1, -1, 1),
        Yu('f3', e, t, Xu, -1, 1, 1),
        Yu('f4', e, t, Xu, 1, 1, 1),
        Yu('u1', e, t, Xu, .7, 1.1, -1),
        Yu('u2', e, t, Xu, -.7, 1.1, -1),
        Yu('u3', e, t, Xu, 0, 2, -1),
        Yu('cf1', e, t, Xu, -1, 0, 1),
        Yu('cf2', e, t, Xu, 1, 0, 1),
        Yu('cf3', e, t, Xu, 0, -1, 1),
        Yu('cf4', e, t, Xu, 0, 1, 1),
        Yu('cn1', e, t, Xu, -1, 0, -1),
        Yu('cn2', e, t, Xu, 1, 0, -1),
        Yu('cn3', e, t, Xu, 0, -1, -1),
        Yu('cn4', e, t, Xu, 0, 1, -1),
        t.getAttribute('position').needsUpdate = !0
    }
    ;
    var Ju = new Ln;
    function Zu(t, e) {
        this.object = t,
        void 0 === e && (e = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Float32Array(24)
          , r = new Oi;
        r.setIndex(new fi(n,1)),
        r.setAttribute('position', new fi(i,3)),
        xs.call(this, r, new hs({
            color: e
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Ku(t, e) {
        this.type = 'Box3Helper',
        this.box = t,
        e = e || 16776960;
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Oi;
        i.setIndex(new fi(n,1)),
        i.setAttribute('position', new Mi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        xs.call(this, i, new hs({
            color: e
        })),
        this.geometry.computeBoundingSphere()
    }
    function Qu(t, e, n) {
        this.type = 'PlaneHelper',
        this.plane = t,
        this.size = void 0 === e ? 1 : e;
        var i = void 0 !== n ? n : 16776960
          , r = new Oi;
        r.setAttribute('position', new Mi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        r.computeBoundingSphere(),
        gs.call(this, r, new hs({
            color: i
        }));
        var o = new Oi;
        o.setAttribute('position', new Mi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        o.computeBoundingSphere(),
        this.add(new Ki(o,new di({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    Zu.prototype = Object.create(xs.prototype),
    Zu.prototype.constructor = Zu,
    Zu.prototype.update = function(t) {
        if (void 0 !== this.object && Ju.setFromObject(this.object),
        !Ju.isEmpty()) {
            var e = Ju.min
              , n = Ju.max
              , i = this.geometry.attributes.position
              , r = i.array;
            r[0] = n.x,
            r[1] = n.y,
            r[2] = n.z,
            r[3] = e.x,
            r[4] = n.y,
            r[5] = n.z,
            r[6] = e.x,
            r[7] = e.y,
            r[8] = n.z,
            r[9] = n.x,
            r[10] = e.y,
            r[11] = n.z,
            r[12] = n.x,
            r[13] = n.y,
            r[14] = e.z,
            r[15] = e.x,
            r[16] = n.y,
            r[17] = e.z,
            r[18] = e.x,
            r[19] = e.y,
            r[20] = e.z,
            r[21] = n.x,
            r[22] = e.y,
            r[23] = e.z,
            i.needsUpdate = !0,
            this.geometry.computeBoundingSphere()
        }
    }
    ,
    Zu.prototype.setFromObject = function(t) {
        return this.object = t,
        this.update(),
        this
    }
    ,
    Zu.prototype.copy = function(t) {
        return xs.prototype.copy.call(this, t),
        this.object = t.object,
        this
    }
    ,
    Zu.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Ku.prototype = Object.create(xs.prototype),
    Ku.prototype.constructor = Ku,
    Ku.prototype.updateMatrixWorld = function(t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        mn.prototype.updateMatrixWorld.call(this, t))
    }
    ,
    Qu.prototype = Object.create(gs.prototype),
    Qu.prototype.constructor = Qu,
    Qu.prototype.updateMatrixWorld = function(t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, e),
        this.children[0].material.side = e < 0 ? h : c,
        this.lookAt(this.plane.normal),
        mn.prototype.updateMatrixWorld.call(this, t)
    }
    ;
    var $u, tp, ep = new Oe;
    function np(t, e, n, i, r, o) {
        mn.call(this),
        void 0 === t && (t = new Oe(0,0,1)),
        void 0 === e && (e = new Oe(0,0,0)),
        void 0 === n && (n = 1),
        void 0 === i && (i = 16776960),
        void 0 === r && (r = .2 * n),
        void 0 === o && (o = .2 * r),
        void 0 === $u && (($u = new Oi).setAttribute('position', new Mi([0, 0, 0, 0, 1, 0],3)),
        (tp = new Rl(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(e),
        this.line = new gs($u,new hs({
            color: i
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Ki(tp,new di({
            color: i
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, r, o)
    }
    function ip(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]
          , n = new Oi;
        n.setAttribute('position', new Mi(e,3)),
        n.setAttribute('color', new Mi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var i = new hs({
            vertexColors: f
        });
        xs.call(this, n, i)
    }
    np.prototype = Object.create(mn.prototype),
    np.prototype.constructor = np,
    np.prototype.setDirection = function(t) {
        if (t.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            ep.set(t.z, 0, -t.x).normalize();
            var e = Math.acos(t.y);
            this.quaternion.setFromAxisAngle(ep, e)
        }
    }
    ,
    np.prototype.setLength = function(t, e, n) {
        void 0 === e && (e = .2 * t),
        void 0 === n && (n = .2 * e),
        this.line.scale.set(1, Math.max(1e-4, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, e, n),
        this.cone.position.y = t,
        this.cone.updateMatrix()
    }
    ,
    np.prototype.setColor = function(t) {
        this.line.material.color.set(t),
        this.cone.material.color.set(t)
    }
    ,
    np.prototype.copy = function(t) {
        return mn.prototype.copy.call(this, t, !1),
        this.line.copy(t.line),
        this.cone.copy(t.cone),
        this
    }
    ,
    np.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    ip.prototype = Object.create(xs.prototype),
    ip.prototype.constructor = ip;
    function rp(t) {
        Fc.call(this, t),
        this.type = 'catmullrom'
    }
    Tc.create = function(t, e) {
        return t.prototype = Object.create(Tc.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    Object.assign(Jc.prototype, {
        createPointsGeometry: function(t) {
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            for (var e = new rr, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.vertices.push(new Oe(r.x,r.y,r.z || 0))
            }
            return e
        }
    }),
    Object.assign(Zc.prototype, {
        fromPoints: function(t) {
            return this.setFromPoints(t)
        }
    }),
    Object.create(Fc.prototype),
    Object.create(Fc.prototype),
    rp.prototype = Object.create(Fc.prototype),
    Object.assign(rp.prototype, {
        initFromArray: function() {},
        getControlPointsArray: function() {},
        reparametrizeByArcLength: function() {}
    }),
    ju.prototype.setColors = function() {}
    ,
    Cu.prototype.update = function() {}
    ,
    Object.assign(bc.prototype, {
        extractUrlBase: function(t) {
            return uh(t)
        }
    }),
    bc.Handlers = {
        add: function() {},
        get: function() {}
    },
    Object.assign(gh.prototype, {
        setTexturePath: function(t) {
            return this.setResourcePath(t)
        }
    }),
    Object.assign(uu.prototype, {
        center: function(t) {
            return this.getCenter(t)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        size: function(t) {
            return this.getSize(t)
        }
    }),
    Object.assign(Ln.prototype, {
        center: function(t) {
            return this.getCenter(t)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return this.intersectsSphere(t)
        },
        size: function(t) {
            return this.getSize(t)
        }
    }),
    fu.prototype.center = function(t) {
        return this.getCenter(t)
    }
    ,
    Object.assign(Ee, {
        random16: function() {
            return Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return Ee.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return Ee.ceilPowerOfTwo(t)
        }
    }),
    Object.assign(ke.prototype, {
        flattenToArrayOffset: function(t, e) {
            return this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {},
        applyToBuffer: function(t) {
            return this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {}
    }),
    Object.assign(Ze.prototype, {
        extractPosition: function(t) {
            return this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return this.toArray(t, e)
        },
        getPosition: function() {
            return (new Oe).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(t) {
            return this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {},
        multiplyVector3: function(t) {
            return t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {},
        rotateAxis: function(t) {
            t.transformDirection(this)
        },
        crossVector: function(t) {
            return t.applyMatrix4(this)
        },
        translate: function() {},
        rotateX: function() {},
        rotateY: function() {},
        rotateZ: function() {},
        rotateByAxis: function() {},
        applyToBuffer: function(t) {
            return this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {},
        makeFrustum: function(t, e, n, i, r, o) {
            return this.makePerspective(t, e, i, n, r, o)
        }
    }),
    Wn.prototype.isIntersectionLine = function(t) {
        return this.intersectsLine(t)
    }
    ,
    Le.prototype.multiplyVector3 = function(t) {
        return t.applyQuaternion(this)
    }
    ,
    Object.assign(Bn.prototype, {
        isIntersectionBox: function(t) {
            return this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return this.intersectsSphere(t)
        }
    }),
    Object.assign(ni.prototype, {
        area: function() {
            return this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return this.getMidpoint(t)
        },
        normal: function(t) {
            return this.getNormal(t)
        },
        plane: function(t) {
            return this.getPlane(t)
        }
    }),
    Object.assign(ni, {
        barycoordFromPoint: function(t, e, n, i, r) {
            return ni.getBarycoord(t, e, n, i, r)
        },
        normal: function(t, e, n, i) {
            return ni.getNormal(t, e, n, i)
        }
    }),
    Object.assign(Kc.prototype, {
        extractAllPoints: function(t) {
            return this.extractPoints(t)
        },
        extrude: function(t) {
            return new Ml(this,t)
        },
        makeGeometry: function(t) {
            return new jl(this,t)
        }
    }),
    Object.assign(Te.prototype, {
        fromAttribute: function(t, e, n) {
            return this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(Oe.prototype, {
        setEulerFromRotationMatrix: function() {},
        setEulerFromQuaternion: function() {},
        getPositionFromMatrix: function(t) {
            return this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(Ue.prototype, {
        fromAttribute: function(t, e, n) {
            return this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(rr.prototype, {
        computeTangents: function() {},
        computeLineDistances: function() {}
    }),
    Object.assign(mn.prototype, {
        getChildByName: function(t) {
            return this.getObjectByName(t)
        },
        renderDepth: function() {},
        translate: function(t, e) {
            return this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {}
    }),
    Object.defineProperties(mn.prototype, {
        eulerOrder: {
            get: function() {
                return this.rotation.order
            },
            set: function(t) {
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties($a.prototype, {
        objects: {
            get: function() {
                return this.levels
            }
        }
    }),
    Object.defineProperty(is.prototype, 'useVertexTexture', {
        get: function() {},
        set: function() {}
    }),
    ts.prototype.initBones = function() {}
    ,
    Object.defineProperty(Tc.prototype, '__arcLengthDivisions', {
        get: function() {
            return this.arcLengthDivisions
        },
        set: function(t) {
            this.arcLengthDivisions = t
        }
    }),
    dr.prototype.setLens = function(t, e) {
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(Qc.prototype, {
        onlyShadow: {
            set: function() {}
        },
        shadowCameraFov: {
            set: function(t) {
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {}
        },
        shadowBias: {
            set: function(t) {
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {}
        },
        shadowMapWidth: {
            set: function(t) {
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(fi.prototype, {
        length: {
            get: function() {
                return this.array.length
            }
        },
        dynamic: {
            get: function() {
                return 35048 === this.usage
            },
            set: function() {
                this.setUsage(35048)
            }
        }
    }),
    Object.assign(fi.prototype, {
        setDynamic: function(t) {
            return this.setUsage(!0 === t ? 35048 : Se),
            this
        },
        copyIndicesArray: function() {},
        setArray: function() {}
    }),
    Object.assign(Oi.prototype, {
        addIndex: function(t) {
            this.setIndex(t)
        },
        addAttribute: function(t, e) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? 'index' === t ? (this.setIndex(e),
            this) : this.setAttribute(t, e) : this.setAttribute(t, new fi(arguments[1],arguments[2]))
        },
        addDrawCall: function(t, e, n) {
            this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            this.clearGroups()
        },
        computeTangents: function() {},
        computeOffsets: function() {},
        removeAttribute: function(t) {
            return this.deleteAttribute(t)
        }
    }),
    Object.defineProperties(Oi.prototype, {
        drawcalls: {
            get: function() {
                return this.groups
            }
        },
        offsets: {
            get: function() {
                return this.groups
            }
        }
    }),
    Object.defineProperties(ja.prototype, {
        dynamic: {
            get: function() {
                return 35048 === this.usage
            },
            set: function(t) {
                this.setUsage(t)
            }
        }
    }),
    Object.assign(ja.prototype, {
        setDynamic: function(t) {
            return this.setUsage(!0 === t ? 35048 : Se),
            this
        },
        setArray: function() {}
    }),
    Object.assign(wl.prototype, {
        getArrays: function() {},
        addShapeList: function() {},
        addShape: function() {}
    }),
    Object.defineProperties(au.prototype, {
        dynamic: {
            set: function() {}
        },
        onUpdate: {
            value: function() {
                return this
            }
        }
    }),
    Object.defineProperties(pi.prototype, {
        wrapAround: {
            get: function() {},
            set: function() {}
        },
        overdraw: {
            get: function() {},
            set: function() {}
        },
        wrapRGB: {
            get: function() {
                return new ai
            }
        },
        shading: {
            get: function() {},
            set: function(t) {
                this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function() {
                return this.stencilFuncMask
            },
            set: function(t) {
                this.stencilFuncMask = t
            }
        }
    }),
    Object.defineProperties(Jl.prototype, {
        metal: {
            get: function() {
                return !1
            },
            set: function() {}
        }
    }),
    Object.defineProperties(ur.prototype, {
        derivatives: {
            get: function() {
                return this.extensions.derivatives
            },
            set: function(t) {
                this.extensions.derivatives = t
            }
        }
    }),
    Object.assign(Da.prototype, {
        clearTarget: function(t, e, n, i) {
            this.setRenderTarget(t),
            this.clear(e, n, i)
        },
        animate: function(t) {
            this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function() {
            return this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return this.capabilities.precision
        },
        resetGLState: function() {
            return this.state.reset()
        },
        supportsFloatTextures: function() {
            return this.extensions.get('OES_texture_float')
        },
        supportsHalfFloatTextures: function() {
            return this.extensions.get('OES_texture_half_float')
        },
        supportsStandardDerivatives: function() {
            return this.extensions.get('OES_standard_derivatives')
        },
        supportsCompressedTextureS3TC: function() {
            return this.extensions.get('WEBGL_compressed_texture_s3tc')
        },
        supportsCompressedTexturePVRTC: function() {
            return this.extensions.get('WEBGL_compressed_texture_pvrtc')
        },
        supportsBlendMinMax: function() {
            return this.extensions.get('EXT_blend_minmax')
        },
        supportsVertexTextures: function() {
            return this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return this.extensions.get('ANGLE_instanced_arrays')
        },
        enableScissorTest: function(t) {
            this.setScissorTest(t)
        },
        initMaterial: function() {},
        addPrePlugin: function() {},
        addPostPlugin: function() {},
        updateShadowMap: function() {},
        setFaceCulling: function() {},
        allocTextureUnit: function() {},
        setTexture: function() {},
        setTexture2D: function() {},
        setTextureCube: function() {},
        getActiveMipMapLevel: function() {
            return this.getActiveMipmapLevel()
        }
    }),
    Object.defineProperties(Da.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {},
            set: function() {}
        },
        context: {
            get: function() {
                return this.getContext()
            }
        }
    }),
    Object.defineProperties(va.prototype, {
        cullFace: {
            get: function() {},
            set: function() {}
        },
        renderReverseSided: {
            get: function() {},
            set: function() {}
        },
        renderSingleSided: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(vr.prototype, {
        activeCubeFace: {
            set: function() {}
        },
        activeMipMapLevel: {
            set: function() {}
        }
    }),
    Object.defineProperties(Be.prototype, {
        wrapS: {
            get: function() {
                return this.texture.wrapS
            },
            set: function(t) {
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return this.texture.wrapT
            },
            set: function(t) {
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return this.texture.magFilter
            },
            set: function(t) {
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return this.texture.minFilter
            },
            set: function(t) {
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return this.texture.anisotropy
            },
            set: function(t) {
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return this.texture.offset
            },
            set: function(t) {
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return this.texture.repeat
            },
            set: function(t) {
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return this.texture.format
            },
            set: function(t) {
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return this.texture.type
            },
            set: function(t) {
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return this.texture.generateMipmaps
            },
            set: function(t) {
                this.texture.generateMipmaps = t
            }
        }
    }),
    Object.defineProperties(Ta.prototype, {
        standing: {
            set: function() {}
        },
        userHeight: {
            set: function() {}
        }
    }),
    Object.defineProperties(Uh.prototype, {
        load: {
            value: function(t) {
                var e = this;
                return (new Ah).load(t, (function(t) {
                    e.setBuffer(t)
                }
                )),
                this
            }
        },
        startTime: {
            set: function() {}
        }
    }),
    Xh.prototype.getData = function() {
        return this.getFrequencyData()
    }
    ,
    gr.prototype.updateCubeMap = function(t, e) {
        return this.update(t, e)
    }
    ;
    Fe.crossOrigin = void 0,
    Fe.loadTexture = function(t, e, n, i) {
        var r = new Ec;
        r.setCrossOrigin(this.crossOrigin);
        var o = r.load(t, n, void 0, i);
        return e && (o.mapping = e),
        o
    }
    ,
    Fe.loadTextureCube = function(t, e, n, i) {
        var r = new Ac;
        r.setCrossOrigin(this.crossOrigin);
        var o = r.load(t, n, void 0, i);
        return e && (o.mapping = e),
        o
    }
    ,
    Fe.loadCompressedTexture = function() {}
    ,
    Fe.loadCompressedTextureCube = function() {}
    ;
    'undefined' != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{
        detail: {
            revision: '111'
        }
    }));
    var op = n(0)
      , ap = n(1);
    const sp = 100
      , lp = .5
      , cp = 25e3
      , hp = cp
      , up = document.getElementById('trigger-indicator')
      , pp = ()=>0;
    let dp, fp, mp, gp, vp, yp, xp, bp, _p, Mp, wp, Sp, Pp = sp, Cp = 0, Ap = 0;
    function Ep() {
        switch (vp = op.globalState.adjustValue.intensity,
        yp = op.globalState.adjustValue.trace,
        xp = op.globalState.adjustValue.focus,
        bp = op.globalState.triggerSettings.triggerLevel,
        Mp = op.globalState.triggerSettings.mode,
        wp = op.globalState.triggerSettings.auto,
        _p = op.globalState.triggerSettings.slope,
        fp = void 0,
        Sp = op.globalState.triggerSettings.channel,
        Sp) {
        case op.TriggerChannel.CH1:
            gp = Tp(op.OscilloscopeChannelMode.CH1);
            break;
        case op.TriggerChannel.CH2:
            gp = Tp(op.OscilloscopeChannelMode.CH2);
            break;
        case op.TriggerChannel.EXT:
            gp = Tp(op.OscilloscopeChannelMode.EXT)
        }
        const t = op.globalState.displayChannelMode;
        switch (Pp = op.globalState.xMag && t !== op.DisplayChannelMode.XY ? 10 * sp : sp,
        t) {
        case op.DisplayChannelMode.CH1:
            dp = Tp(op.OscilloscopeChannelMode.CH1),
            mp = Lp();
            break;
        case op.DisplayChannelMode.CH2:
            dp = Tp(op.OscilloscopeChannelMode.CH2),
            mp = Lp();
            break;
        case op.DisplayChannelMode.XY:
            dp = Tp(op.OscilloscopeChannelMode.CH2),
            mp = Tp(op.OscilloscopeChannelMode.CH1);
            break;
        case op.DisplayChannelMode.DUAL:
            dp = Tp(op.OscilloscopeChannelMode.CH1),
            fp = Tp(op.OscilloscopeChannelMode.CH2),
            mp = Lp();
            break;
        case op.DisplayChannelMode.ADD:
            const t = Tp(op.OscilloscopeChannelMode.CH1)
              , e = Tp(op.OscilloscopeChannelMode.CH2);
            dp = n=>t.apply(null, [n]) + e.apply(null, [n]),
            mp = Lp()
        }
    }
    function Tp(t) {
        let e;
        if (void 0 === op.globalState.connections[t])
            e = pp;
        else
            switch (op.globalState.connections[t].target) {
            case op.ChannelMode.CH1:
                e = ap.functionGenerator.getCH1Function();
                break;
            case op.ChannelMode.CH2:
                e = ap.functionGenerator.getCH2Function();
                break;
            case op.ChannelMode.CH3:
                e = ap.functionGenerator.getCH3Function()
            }
        switch (t) {
        case op.OscilloscopeChannelMode.CH1:
            op.globalState.controlPane.ch1.GND && (e = pp);
            const t = op.globalState.rotaryPane.position1
              , n = op.globalState.rotaryPane.voltsCH1 / 10;
            return i=>e.apply(null, [i]) / n + t;
        case op.OscilloscopeChannelMode.CH2:
            op.globalState.controlPane.ch2.GND && (e = pp);
            const i = op.globalState.rotaryPane.position2
              , r = op.globalState.rotaryPane.voltsCH2 / 10
              , o = op.globalState.controlPane.ch2.INV ? -1 : 1;
            return t=>e.apply(null, [t]) / r * o + i
        }
    }
    function Lp() {
        let t, e, n;
        const i = op.globalState.displayChannelMode === op.DisplayChannelMode.DUAL
          , r = op.globalState.rotaryPane.xPosition
          , o = 10 * op.globalState.rotaryPane.time;
        let a = Sp !== op.TriggerChannel.NONE
          , s = !a;
        return (l,c)=>{
            if (t)
                if (!a && l >= e) {
                    if (t = e,
                    e = t + o,
                    i) {
                        const t = dp;
                        dp = fp,
                        fp = t
                    }
                } else
                    l >= e && !s && a && function(t, e) {
                        const n = gp(t - e)
                          , i = gp(t)
                          , r = wp ? Math.min(Cp - .01, Math.max(Ap + .01, bp)) : bp;
                        if (Mp === op.TriggerMode.DC && !wp)
                            return _p ? i <= Math.max(Ap + .05, r) && n > i && i > r - .05 : i >= r && n < i && i < Math.max(Ap, r) + .05;
                        return _p ? n > r && i <= r : n < r && i >= r
                    }(l, c) && (t = l,
                    e = t + o,
                    s = !0,
                    up.classList.add('active'),
                    clearTimeout(n),
                    n = setTimeout(()=>{
                        up.classList.remove('active')
                    }
                    , 100));
            else
                t = l,
                e = l + o;
            if (a && s && l >= e && (s = !1,
            i)) {
                const t = dp;
                dp = fp,
                fp = t
            }
            return s ? (l - t) / o * Pp - Pp / 2 + r : -Pp
        }
    }
    Ep(),
    Object(op.addListener)(()=>{
        Ep()
    }
    ),
    window.addEventListener('focus', (function() {
        Ep()
    }
    ), !1);
    const Dp = new gn
      , Ip = new oh(-Pp / 2,Pp / 2,40,-40,1,1e3);
    Ip.position.z = 5;
    const Op = new Da({
        canvas: display,
        preserveDrawingBuffer: !0
    });
    Op.autoClearColor = !0,
    Op.setPixelRatio(2 * window.devicePixelRatio),
    Op.setClearColor(436122);
    const jp = new hs({
        color: 37770
    });
    for (var Np = -3; Np <= 3; Np++) {
        const t = new rr;
        t.vertices.push(new Oe(-Pp / 2,80 * Np / 8,0), new Oe(Pp / 2,80 * Np / 8,0));
        const e = new gs(t,jp);
        Dp.add(e)
    }
    for (Np = -4; Np <= 4; Np++) {
        const t = new rr;
        t.vertices.push(new Oe(Np * Pp / 10,-40,0), new Oe(Np * Pp / 10,40,0));
        const e = new gs(t,jp);
        Dp.add(e)
    }
    const kp = new or(Pp,80)
      , Fp = new di({
        color: 436122,
        opacity: .02,
        transparent: !0,
        blending: b
    });
    Fp.blendEquation = w,
    Fp.blendSrc = L,
    Fp.blendDst = A;
    const zp = new Ki(kp,Fp);
    zp.position.z = -1,
    Dp.add(zp);
    var Rp = new ur({
        uniforms: {
            fadeOpacity: {
                type: 'float',
                value: .02
            }
        },
        fragmentShader: '\n        uniform float fadeOpacity;\n        varying vec2 vUv;\n        varying float vAlpha;\n        void main()\n        {\n            float alpha = 1.0 - abs(vUv.x);\n            float fade = mix(1.0 - fadeOpacity, 1.0, vUv.y);\n            gl_FragColor = vec4(0.0, 1.0, 0.0, alpha * alpha * fade * vAlpha);\n        }\n    ',
        vertexShader: '\n        varying vec2 vUv;\n        varying float vAlpha;\n        void main() {\n            vec4 modelViewPosition = modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition;\n            vUv = uv;\n            vAlpha = position.z;\n        }\n    ',
        side: u,
        blending: g,
        transparent: !0
    });
    const Up = new Oi;
    Up.setAttribute('position', new fi(new Float32Array(3 * hp * 2),3)),
    Up.setAttribute('uv', new fi(new Float32Array(2 * hp * 2),2)),
    Up.boundingSphere = new On;
    const Bp = new Ki(Up,Rp);
    Bp.drawMode = le,
    Dp.add(Bp);
    var Vp = Date.now()
      , Gp = 0;
    !function t() {
        requestAnimationFrame(t);
        var e = Date.now()
          , n = Math.max(e - Vp, 1);
        Vp = e;
        var i = Math.min(hp - 1, Math.max(1, Math.ceil(n * cp)))
          , r = Up.attributes.position.array
          , o = Up.attributes.uv.array
          , a = 1 / i * n
          , s = mp(Vp - a)
          , l = dp(Vp - a)
          , c = .2 * Pp;
        let h = 0
          , u = 0;
        for (var p = 0, d = 0; d <= i; ++d) {
            const t = Vp + d * a
              , e = mp(t, a)
              , n = dp(t);
            if (gp) {
                const e = gp(t);
                h = Math.max(h, e),
                u = Math.min(u, e)
            }
            const f = e - s
              , m = n - l
              , g = Math.sqrt(f * f + m * m);
            let v = 1 / g;
            isNaN(v) && (v = 0);
            const y = -m * v * lp
              , x = f * v * lp
              , b = Math.pow(Math.max(0, 1 - g / c), 20);
            p > 0 && (r[3 * p - 4] *= b,
            r[3 * p - 1] *= b),
            r[3 * p + 0] = e - y,
            r[3 * p + 1] = n - x,
            r[3 * p + 2] = b * Gp,
            r[3 * p + 3] = e + y,
            r[3 * p + 4] = n + x,
            r[3 * p + 5] = b * Gp,
            Gp = b,
            o[2 * p + 0] = -1,
            o[2 * p + 1] = d / i,
            o[2 * p + 2] = 1,
            o[2 * p + 3] = d / i,
            p += 2,
            s = e,
            l = n
        }
        Ap = (u + Ap) / 2,
        Cp = (h + Cp) / 2,
        Up.setDrawRange(0, p),
        Up.attributes.position.needsUpdate = !0,
        Up.attributes.uv.needsUpdate = !0,
        Op.render(Dp, Ip),
        !1 && (Op.autoClear = !1)
    }()
}
]);
